<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>250811-250817 周记 linux命令与shell编程学习(2) | Elian's blog page</title><meta name="author" content="Eliano"><meta name="copyright" content="Eliano"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="855148"><meta name="description" content="2. 第二部分 shell 脚本编程基础2.11 构建基础脚本2.11.2 创建 shell 脚本文件 其中输入命令。 在创建 shell 脚本文件时,必须在文件的第一行指定要使用的 shell,格式如下:  #!&#x2F;bin&#x2F;bash  在普通的 shell 脚本中,#用作注释行。shell 并不会处理 shell 脚本中的注释行。然而,shell 脚本文件的第一行是个例外,#后">
<meta property="og:type" content="article">
<meta property="og:title" content="250811-250817 周记 linux命令与shell编程学习(2)">
<meta property="og:url" content="https://eliano64.github.io/2025/08/19/250811-250817-%E5%91%A8%E8%AE%B0-linux%E5%91%BD%E4%BB%A4%E4%B8%8Eshell%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-2/index.html">
<meta property="og:site_name" content="Elian&#39;s blog page">
<meta property="og:description" content="2. 第二部分 shell 脚本编程基础2.11 构建基础脚本2.11.2 创建 shell 脚本文件 其中输入命令。 在创建 shell 脚本文件时,必须在文件的第一行指定要使用的 shell,格式如下:  #!&#x2F;bin&#x2F;bash  在普通的 shell 脚本中,#用作注释行。shell 并不会处理 shell 脚本中的注释行。然而,shell 脚本文件的第一行是个例外,#后">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://avatars.githubusercontent.com/u/149126004?v=4">
<meta property="article:published_time" content="2025-08-19T01:23:00.000Z">
<meta property="article:modified_time" content="2025-08-20T01:22:42.244Z">
<meta property="article:author" content="Eliano">
<meta property="article:tag" content="shell">
<meta property="article:tag" content="reading note">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="Linux Command Line and Shell Scripting Bible">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://avatars.githubusercontent.com/u/149126004?v=4"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "250811-250817 周记 linux命令与shell编程学习(2)",
  "url": "https://eliano64.github.io/2025/08/19/250811-250817-%E5%91%A8%E8%AE%B0-linux%E5%91%BD%E4%BB%A4%E4%B8%8Eshell%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-2/",
  "image": "https://avatars.githubusercontent.com/u/149126004?v=4",
  "datePublished": "2025-08-19T01:23:00.000Z",
  "dateModified": "2025-08-20T01:22:42.244Z",
  "author": [
    {
      "@type": "Person",
      "name": "Eliano",
      "url": "https://eliano64.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://eliano64.github.io/2025/08/19/250811-250817-%E5%91%A8%E8%AE%B0-linux%E5%91%BD%E4%BB%A4%E4%B8%8Eshell%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '855148')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '250811-250817 周记 linux命令与shell编程学习(2)',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://avatars.githubusercontent.com/u/149126004?v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> home</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><i class="fa-fw fas fa-archive"></i><span> archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> categories</span></a></div><div class="menus_item"><a class="site-page" href="/about"><i class="fa-fw fas fa-user"></i><span> about</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Elian's blog page</span></a><a class="nav-page-title" href="/"><span class="site-name">250811-250817 周记 linux命令与shell编程学习(2)</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> home</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><i class="fa-fw fas fa-archive"></i><span> archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> categories</span></a></div><div class="menus_item"><a class="site-page" href="/about"><i class="fa-fw fas fa-user"></i><span> about</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">250811-250817 周记 linux命令与shell编程学习(2)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-19T01:23:00.000Z" title="发表于 2025-08-19 09:23:00">2025-08-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-20T01:22:42.244Z" title="更新于 2025-08-20 09:22:42">2025-08-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux-Command-Line-and-Shell-Scripting-Bible/">Linux Command Line and Shell Scripting Bible</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">5.6k</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="2-第二部分-shell-脚本编程基础"><a href="#2-第二部分-shell-脚本编程基础" class="headerlink" title="2. 第二部分 shell 脚本编程基础"></a>2. 第二部分 shell 脚本编程基础</h1><h2 id="2-11-构建基础脚本"><a href="#2-11-构建基础脚本" class="headerlink" title="2.11 构建基础脚本"></a>2.11 构建基础脚本</h2><h3 id="2-11-2-创建-shell-脚本文件"><a href="#2-11-2-创建-shell-脚本文件" class="headerlink" title="2.11.2 创建 shell 脚本文件"></a>2.11.2 创建 shell 脚本文件</h3><ul>
<li>其中输入命令。 在创建 shell 脚本文件时,必须在文件的第一行指定要使用的 shell,格式如下:  #!&#x2F;bin&#x2F;bash  在普通的 shell 脚本中,#用作注释行。shell 并不会处理 shell 脚本中的注释行。然而,shell 脚本文件的第一行是个例外,#后面的惊叹号会告诉 shell 用哪个 shell 来运行脚本。(是的,可以使用 bash shell,然后使用另一个 shell 来运行你的脚本。)</li>
<li>通过 chmod 命令(参见第 7 章)赋予文件属主执行文件的权限后，就可以直接<code>./script.sh</code>来运行脚本了。</li>
</ul>
<h3 id="2-11-3-显示消息"><a href="#2-11-3-显示消息" class="headerlink" title="2.11.3 显示消息"></a>2.11.3 显示消息</h3><ul>
<li>如果在 echo 命令后面加上字符串,那么 echo 命令就会显示出这个字符串</li>
<li>echo输出默认句末带一个换行符<code>\n</code>,可以使用<code>-n</code>选项取消换行符</li>
</ul>
<h3 id="2-11-4-使用变量"><a href="#2-11-4-使用变量" class="headerlink" title="2.11.4 使用变量"></a>2.11.4 使用变量</h3><h4 id="2-11-4-1-环境变量"><a href="#2-11-4-1-环境变量" class="headerlink" title="2.11.4.1 环境变量"></a>2.11.4.1 环境变量</h4><ul>
<li>反斜线允许 shell 脚本按照字面意义解释$,而不是引用变量</li>
<li>通过${variable}形式引用的变量。花括号通常用于帮助界定$后的变量名。</li>
</ul>
<h4 id="2-11-4-2-用户自定义变量"><a href="#2-11-4-2-用户自定义变量" class="headerlink" title="2.11.4.2 用户自定义变量"></a>2.11.4.2 用户自定义变量</h4><ul>
<li>使用等号为变量赋值。在变量、等号和值之间不能出现空格</li>
<li>shell 脚本会以字符串形式存储所有的变量值,脚本中的各个命令可以自行决定变量值的数据类型。</li>
<li>shell 脚本中定义的变量在脚本的整个生命周期里会一直保持着它们的值,在脚本结束时会被删除。</li>
<li><strong>引用变量值时要加$,对变量赋值时则不用加$</strong></li>
</ul>
<h4 id="2-11-4-3-命令替换"><a href="#2-11-4-3-命令替换" class="headerlink" title="2.11.4.3 命令替换"></a>2.11.4.3 命令替换</h4><ul>
<li>将命令输出赋给变量: <code>var=$(command)</code>或者: <code>var=`command` </code>注意,赋值号和命令替换 符之间没有空格</li>
</ul>
<h3 id="2-11-5-重定向输入和输出"><a href="#2-11-5-重定向输入和输出" class="headerlink" title="2.11.5 重定向输入和输出"></a>2.11.5 重定向输入和输出</h3><h4 id="2-11-5-1-输出重定向"><a href="#2-11-5-1-输出重定向" class="headerlink" title="2.11.5.1 输出重定向"></a>2.11.5.1 输出重定向</h4><ul>
<li>最基本的重定向会将命令的输出发送至文件。bash shell 使用“&gt;”来实现该操作</li>
<li>将命令输出追加到已有文件中：&gt;&gt;</li>
</ul>
<h4 id="2-11-5-2-输入重定向"><a href="#2-11-5-2-输入重定向" class="headerlink" title="2.11.5.2 输入重定向"></a>2.11.5.2 输入重定向</h4><ul>
<li>输入重定向会将文件的内容作为命令的输入。使用“&lt;”来实现该操作 <code>command &lt; inputfile</code></li>
<li>一种简单的记忆方法是,<strong>在命令行中,命令总是在左侧,而重定向运算符“指向”数据流动的方向。</strong>小于号说明数据正在从输入文件流向命令。</li>
<li>还有另外一种输入重定向的方法,称为内联输入重定向。这种方法 无须使用文件进行重定向,只需在命令行中指定用于输入重定向的数据即可。<ul>
<li>内联输入重定向的格式如下: <code>command &lt;&lt; delimiter</code></li>
<li>其中,delimiter 是一个用户定义的字符串,用于标识输入重定向的结束。</li>
<li>内联输入重定向的工作原理是,shell 会将命令行中所有位于 delimiter 之前的文本作为命令的输入。<br>例如：</li>
</ul>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">wc</span> &lt;&lt; <span class="string">EOF </span></span><br><span class="line"><span class="string">&gt; test string 1 </span></span><br><span class="line"><span class="string">&gt; test string 2 </span></span><br><span class="line"><span class="string">&gt; test string 3 </span></span><br><span class="line"><span class="string">&gt; EOF</span> </span><br></pre></td></tr></table></figure>

<ul>
<li>因此可以在脚本中像这样用：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt;&gt; <span class="variable">$outfile</span> &lt;&lt; <span class="string">EOF </span></span><br><span class="line"><span class="string">INSERT INTO members (lname,fname,address,city,state,zip) VALUES (&#x27;$lname&#x27;, &#x27;$fname&#x27;, &#x27;$address&#x27;, &#x27;$city&#x27;, &#x27;$state&#x27;, &#x27;$zip&#x27;); </span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<ul>
<li>快速地根据csv文件生成sql语句</li>
</ul>
<h3 id="2-11-6-管道"><a href="#2-11-6-管道" class="headerlink" title="2.11.6 管道"></a>2.11.6 管道</h3><ul>
<li>将一个命令的输出作为另一个命令的输入 <code>command1 | command2</code></li>
<li>实际上,Linux 系统会同时运行这两个命令, 在系统内部将二者连接起来。当第一个命令产生输出时,它会被立即传给第二个命令。数据传输 不会用到任何中间文件或缓冲区。</li>
<li>管道可以串联的命令数量没有限制。可以持续地将命令输出通过管道传给其他命令来细化操作。</li>
<li></li>
</ul>
<h3 id="2-11-7-执行数学运算"><a href="#2-11-7-执行数学运算" class="headerlink" title="2.11.7 执行数学运算"></a>2.11.7 执行数学运算</h3><h4 id="2-11-7-2-使用括号"><a href="#2-11-7-2-使用括号" class="headerlink" title="2.11.7.2 使用括号"></a>2.11.7.2 使用括号</h4><ul>
<li>要将数学运算结果赋给变量,使用<code>var=$((expression))</code></li>
<li>bash shell 的数学运算符只支持整数运算, z shell(zsh)提供了完整的浮点数操作。</li>
</ul>
<h3 id="2-11-8-退出脚本"><a href="#2-11-8-退出脚本" class="headerlink" title="2.11.8 退出脚本"></a>2.11.8 退出脚本</h3><h4 id="2-11-8-1-查看退出状态码"><a href="#2-11-8-1-查看退出状态码" class="headerlink" title="2.11.8.1 查看退出状态码"></a>2.11.8.1 查看退出状态码</h4><ul>
<li>Linux 提供了专门的变量$?来保存最后一个已执行命令的退出状态码。</li>
<li>按照惯例,对于成功结束的命令,其退出状态码是 0。对于因错误而结束的命令,其退出状态码是一个正整数。</li>
</ul>
<h4 id="2-1-8-2-exit-命令"><a href="#2-1-8-2-exit-命令" class="headerlink" title="2.1.8.2 exit 命令"></a>2.1.8.2 exit 命令</h4><ul>
<li>exit 命令允许在脚本结束时指定一个退出状态码</li>
<li>退出状态码必须是 0 到 255 之间的整数。如果指定了超出这个范围的值,则会自动对256取模。</li>
</ul>
<h2 id="2-12-结构化命令"><a href="#2-12-结构化命令" class="headerlink" title="2.12 结构化命令"></a>2.12 结构化命令</h2><h3 id="2-12-1-使用-if-then-语句"><a href="#2-12-1-使用-if-then-语句" class="headerlink" title="2.12.1 使用 if-then 语句"></a>2.12.1 使用 if-then 语句</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">command</span>; <span class="keyword">then</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h3 id="2-12-2-if-then-else"><a href="#2-12-2-if-then-else" class="headerlink" title="2.12.2 if-then-else"></a>2.12.2 if-then-else</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">command</span>; <span class="keyword">then</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h3 id="2-12-3-if-then-elif-else"><a href="#2-12-3-if-then-elif-else" class="headerlink" title="2.12.3 if-then-elif-else"></a>2.12.3 if-then-elif-else</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">command</span>; <span class="keyword">then</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">command</span>; <span class="keyword">then</span></span><br><span class="line">    commands</span><br><span class="line">(省略可能的多个<span class="keyword">elif</span>语句)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h3 id="2-12-4-test-命令"><a href="#2-12-4-test-命令" class="headerlink" title="2.12.4 test 命令"></a>2.12.4 test 命令</h3><ul>
<li>bash shell 提供了另一种条件测试方式:</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition ]; <span class="keyword">then</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>第一个方括号之后和第二个方括号之前必须留有空格</strong></li>
</ul>
<h4 id="2-12-4-1-数值比较"><a href="#2-12-4-1-数值比较" class="headerlink" title="2.12.4.1 数值比较"></a>2.12.4.1 数值比较</h4><table>
<thead>
<tr>
<th>比较</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>n1 -eq n2</td>
<td>检查 n1 是否等于 n2</td>
</tr>
<tr>
<td>n1 -ge n2</td>
<td>检查 n1 是否大于或等于 n2</td>
</tr>
<tr>
<td>n1 -gt n2</td>
<td>检查 n1 是否大于 n2</td>
</tr>
<tr>
<td>n1 -le n2</td>
<td>检查 n1 是否小于或等于 n2</td>
</tr>
<tr>
<td>n1 -lt n2</td>
<td>检查 n1 是否小于 n2</td>
</tr>
<tr>
<td>n1 -ne n2</td>
<td>检查 n1 是否不等于 n2</td>
</tr>
</tbody></table>
<h4 id="2-12-4-2-字符串比较"><a href="#2-12-4-2-字符串比较" class="headerlink" title="2.12.4.2 字符串比较"></a>2.12.4.2 字符串比较</h4><table>
<thead>
<tr>
<th>比较</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-z string</td>
<td>检查字符串是否为空</td>
</tr>
<tr>
<td>-n string</td>
<td>检查字符串是否不为空</td>
</tr>
<tr>
<td>string1 &#x3D; string2</td>
<td>检查字符串是否相等</td>
</tr>
<tr>
<td>string1 !&#x3D; string2</td>
<td>检查字符串是否不相等</td>
</tr>
<tr>
<td>string1 &lt; string2</td>
<td>检查字符串是否小于 string2</td>
</tr>
<tr>
<td>string1 &gt; string2</td>
<td>检查字符串是否大于 string2</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>测试表达式使用标准的数学比较符号来表示字符串比较,而用文本代码来表示数值比较。</strong></p>
</blockquote>
<h4 id="2-12-4-3-文件比较"><a href="#2-12-4-3-文件比较" class="headerlink" title="2.12.4.3 文件比较"></a>2.12.4.3 文件比较</h4><table>
<thead>
<tr>
<th>比较</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-e filename</td>
<td>检查文件是否存在</td>
</tr>
<tr>
<td>-f filename</td>
<td>检查文件是否存在且是一个普通文件</td>
</tr>
<tr>
<td>-d filename</td>
<td>检查文件是否存在且是一个目录</td>
</tr>
<tr>
<td>-r filename</td>
<td>检查文件是否存在且可读</td>
</tr>
<tr>
<td>-w filename</td>
<td>检查文件是否存在且可写</td>
</tr>
<tr>
<td>-x filename</td>
<td>检查文件是否存在且可执行</td>
</tr>
<tr>
<td>-s filename</td>
<td>检查文件是否存在且非空</td>
</tr>
<tr>
<td>filename1 -nt filename2</td>
<td>检查 filename1 是否比 filename2 新</td>
</tr>
<tr>
<td>filename1 -ot filename2</td>
<td>检查 filename1 是否比 filename2 旧</td>
</tr>
</tbody></table>
<h3 id="2-12-5-复合条件测试"><a href="#2-12-5-复合条件测试" class="headerlink" title="2.12.5 复合条件测试"></a>2.12.5 复合条件测试</h3><ul>
<li>if-then 语句允许使用布尔逻辑将测试条件组合起来。可以使用以下两种布尔运算符：<ul>
<li>[ condition1 ] &amp;&amp; [ condition2 ] </li>
<li>[ condition1 ] || [ condition2 ]</li>
</ul>
</li>
</ul>
<h3 id="2-12-6-if-then-的高级特性"><a href="#2-12-6-if-then-的高级特性" class="headerlink" title="2.12.6 if-then 的高级特性"></a>2.12.6 if-then 的高级特性</h3><h4 id="2-12-6-1-使用单括号"><a href="#2-12-6-1-使用单括号" class="headerlink" title="2.12.6.1 使用单括号"></a>2.12.6.1 使用单括号</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">command</span>); <span class="keyword">then</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<ul>
<li>单括号中的命令会在子 shell 中执行,而不是在当前 shell 中执行。</li>
<li>单括号中的命令可以使用分号分隔多个命令。</li>
<li>单括号中的命令可以使用反引号或美元符号引用变量。</li>
</ul>
<h4 id="2-12-6-2-使用双括号"><a href="#2-12-6-2-使用双括号" class="headerlink" title="2.12.6.2 使用双括号"></a>2.12.6.2 使用双括号</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((expression)); <span class="keyword">then</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<ul>
<li>双括号中的表达式可以使用的运算符：</li>
</ul>
<table>
<thead>
<tr>
<th>符号</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>val++</td>
<td>后增</td>
</tr>
<tr>
<td>val–</td>
<td>后减</td>
</tr>
<tr>
<td>++val</td>
<td>先增</td>
</tr>
<tr>
<td>–val</td>
<td>先减</td>
</tr>
<tr>
<td>!</td>
<td>逻辑求反</td>
</tr>
<tr>
<td>~</td>
<td>位求反</td>
</tr>
<tr>
<td>**</td>
<td>幂运算</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左位移</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右位移</td>
</tr>
<tr>
<td>&amp;</td>
<td>位布尔 AND</td>
</tr>
<tr>
<td>|</td>
<td>位布尔 OR</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑 AND</td>
</tr>
<tr>
<td>||</td>
<td>逻辑 OR</td>
</tr>
</tbody></table>
<ul>
<li>双括号命令既可以在 if 语句中使用,也可以在脚本中的普通命令里用来赋值</li>
<li>双括号中表达式的大于号和小于号不用转义。这是双括号命令又一个优越性的体现。</li>
</ul>
<h4 id="2-12-6-3-使用双方括号"><a href="#2-12-6-3-使用双方括号" class="headerlink" title="2.12.6.3 使用双方括号"></a>2.12.6.3 使用双方括号</h4><ul>
<li>双方括号命令提供了针对字符串比较的高级特性</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ expression ]]; <span class="keyword">then</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<ul>
<li>提供了 test 命令所不具备的另一个特性——模式匹配。</li>
<li>双等号(&#x3D;&#x3D;)会将右侧的字符串视为一个模式并应用模式匹配规则。</li>
</ul>
<h3 id="2-12-7-case-命令"><a href="#2-12-7-case-命令" class="headerlink" title="2.12.7 case 命令"></a>2.12.7 case 命令</h3><ul>
<li>有了 case 命令,就无须再写大量的 elif 语句来检查同一个变量的值了。case 命令会采 用列表格式来检查变量的多个值:</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> variable <span class="keyword">in</span></span><br><span class="line">    pattern1)</span><br><span class="line">        commands</span><br><span class="line">        ;;</span><br><span class="line">    pattern2)</span><br><span class="line">        commands</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        commands</span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<h2 id="2-13-更多的结构化命令"><a href="#2-13-更多的结构化命令" class="headerlink" title="2.13 更多的结构化命令"></a>2.13 更多的结构化命令</h2><h3 id="2-13-1-for-命令"><a href="#2-13-1-for-命令" class="headerlink" title="2.13.1 for 命令"></a>2.13.1 for 命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> variable <span class="keyword">in</span> list; <span class="keyword">do</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h4 id="2-13-1-2-读取列表中的复杂值"><a href="#2-13-1-2-读取列表中的复杂值" class="headerlink" title="2.13.1.2 读取列表中的复杂值"></a>2.13.1.2 读取列表中的复杂值</h4><ul>
<li>for 循环假定各个值之间是 以空格分隔的。如果某个值含有空格, 则必须将其放入双引号内。</li>
</ul>
<h4 id="2-13-1-5-更改字段分隔符"><a href="#2-13-1-5-更改字段分隔符" class="headerlink" title="2.13.1.5 更改字段分隔符"></a>2.13.1.5 更改字段分隔符</h4><ul>
<li>IFS 环境变量定义了 bash shell 用作字段分隔符的一系列字符。在默认情况下,bash shell 会将下列字符视为字段分隔符。<ul>
<li>空格</li>
<li>制表符</li>
<li>换行符</li>
</ul>
</li>
<li>修改 IFS 环境变量可以改变 bash shell 用作字段分隔符的字符。修改 IFS 的值,使其只能识别换行符: <code>IFS=$&#39;\n&#39;</code></li>
</ul>
<blockquote>
<p>在 Bash 里，$’…’ 是 ANSI-C 风格的字符串，会识别 C 语言风格的转义符<br>$’\n’ → 真正的换行符<br>$’\t’ → 制表符（Tab）<br>$’\x41’ → 字符 A</p>
</blockquote>
<blockquote>
<p>在处理代码量较大的脚本时,可能在一个地方需要修改 IFS 的值,然后再将其恢复原状,而脚本的其他地方则继续沿用 IFS 的默认值。一种安全的做法是在修改 IFS 之前保存原来的 IFS 值,之后再恢复它。这种技术可以像下面这样来实现:<br><code>IFS.OLD=$IFS IFS=$&#39;\n&#39;</code><br>&lt;在代码中使用新的 IFS 值&gt;<br><code>IFS=$IFS.OLD</code><br>这就保证了在脚本的后续操作中使用的是 IFS 的默认值。</p>
</blockquote>
<h4 id="2-13-1-6-使用通配符读取目录"><a href="#2-13-1-6-使用通配符读取目录" class="headerlink" title="2.13.1.6 使用通配符读取目录"></a>2.13.1.6 使用通配符读取目录</h4><ul>
<li>用 for 命令来自动遍历目录中的文件。</li>
<li>在文件名或路径名中使用 通配符,这会强制 shell 使用文件名通配符匹配(file globbing)。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> /path/*; <span class="keyword">do</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 Linux 中,目录名和文件名中包含空格是完全合法的。要应对这种情况,应该将$file 变 量放入双引号内。否则,遇到含有空格的目录名或文件名时会产生错误</p>
</blockquote>
<ul>
<li>可以在 for 命令中列出多个目录通配符</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> /path/* /path2/*; <span class="keyword">do</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h3 id="2-13-2-C-语言风格的-for-命令"><a href="#2-13-2-C-语言风格的-for-命令" class="headerlink" title="2.13.2 C 语言风格的 for 命令"></a>2.13.2 C 语言风格的 for 命令</h3><ul>
<li>bash 中仿 C 语言的 for 循环的基本格式如下:  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (( variable assignment ; condition ; iteration process )); <span class="keyword">do</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-13-3-while-命令"><a href="#2-13-3-while-命令" class="headerlink" title="2.13.3 while 命令"></a>2.13.3 while 命令</h3><h4 id="2-13-3-1-while-的基本格式"><a href="#2-13-3-1-while-的基本格式" class="headerlink" title="2.13.3.1 while 的基本格式"></a>2.13.3.1 while 的基本格式</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ condition ]; <span class="keyword">do</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h3 id="2-13-7-循环控制"><a href="#2-13-7-循环控制" class="headerlink" title="2.13.7 循环控制"></a>2.13.7 循环控制</h3><h4 id="2-13-7-1-break-命令"><a href="#2-13-7-1-break-命令" class="headerlink" title="2.13.7.1 break 命令"></a>2.13.7.1 break 命令</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> list; <span class="keyword">do</span></span><br><span class="line">    commands</span><br><span class="line">    <span class="keyword">if</span> [ condition ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h4 id="2-13-7-2-continue-命令"><a href="#2-13-7-2-continue-命令" class="headerlink" title="2.13.7.2 continue 命令"></a>2.13.7.2 continue 命令</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> list; <span class="keyword">do</span></span><br><span class="line">    commands</span><br><span class="line">    <span class="keyword">if</span> [ condition ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">continue</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h3 id="2-13-8-处理循环的输出"><a href="#2-13-8-处理循环的输出" class="headerlink" title="2.13.8 处理循环的输出"></a>2.13.8 处理循环的输出</h3><ul>
<li>对循环的输出使用管道或进行重定向。通过在 done 命令之后 添加一个处理命令来实现</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> list; <span class="keyword">do</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">done</span> &gt; output.txt</span><br></pre></td></tr></table></figure>

<ul>
<li>“|”以及”&lt;”都可以像这样用</li>
</ul>
<h2 id="2-14-处理用户输入"><a href="#2-14-处理用户输入" class="headerlink" title="2.14 处理用户输入"></a>2.14 处理用户输入</h2><h3 id="2-14-1-传递参数"><a href="#2-14-1-传递参数" class="headerlink" title="2.14.1 传递参数"></a>2.14.1 传递参数</h3><h4 id="2-14-1-1-读取参数"><a href="#2-14-1-1-读取参数" class="headerlink" title="2.14.1.1 读取参数"></a>2.14.1.1 读取参数</h4><ul>
<li>bash shell 会将所有的命令行参数都指派给称作位置参数(positional parameter)的特殊变量。 这也包括 shell 脚本名称。</li>
<li>位置变量的名称都是标准数字:$0 对应脚本名,$1 对应第一个命令行参数,$2 对应第二个命令行参数,以此类推。</li>
</ul>
<h4 id="2-14-1-2-读取脚本名"><a href="#2-14-1-2-读取脚本名" class="headerlink" title="2.14.1.2 读取脚本名"></a>2.14.1.2 读取脚本名</h4><ul>
<li>basename 命令可以返回不包含路径的脚本名</li>
</ul>
<h3 id="2-14-2-特殊参数变量"><a href="#2-14-2-特殊参数变量" class="headerlink" title="2.14.2 特殊参数变量"></a>2.14.2 特殊参数变量</h3><h4 id="2-14-2-1-参数统计"><a href="#2-14-2-1-参数统计" class="headerlink" title="2.14.2.1 参数统计"></a>2.14.2.1 参数统计</h4><ul>
<li>$#含有脚本运行时携带的命令行参数的个数，不包含脚本名。</li>
<li><code>$&#123;!#&#125;</code> 代表了最后一个位置变量</li>
</ul>
<h4 id="2-14-2-2-获取所有的数据"><a href="#2-14-2-2-获取所有的数据" class="headerlink" title="2.14.2.2 获取所有的数据"></a>2.14.2.2 获取所有的数据</h4><ul>
<li>$*变量和$@变量可以轻松访问所有参数,它们各自包含了所有的命令行参数</li>
<li>$*变量会将所有的命令行参数视为一个单词。这个单词含有命令行中出现的每一个参数。 基本上,$*变量会将这些参数视为一个整体,而不是一系列个体。</li>
<li>$@变量会将所有的命令行参数视为同一字符串中的多个独立的单词,以便你能遍历并处理全部参数。这通常使用 for 命令完成。</li>
</ul>
<h3 id="2-14-3-移动参数"><a href="#2-14-3-移动参数" class="headerlink" title="2.14.3 移动参数"></a>2.14.3 移动参数</h3><ul>
<li><code>shift</code> 命令会将所有的位置参数向左移动。每个位置参数的变量名都会减 1。$1 会变成$0,$2 会变成$1,以此类推。被删除的参数会被丢弃。</li>
<li><code>shift</code> 命令可以接受一个可选的参数,用于指定要左移几位。默认情况下,它会将所有的位置参数向左移动一个位置。</li>
</ul>
<h4 id="2-14-4-3-使用-getopts-命令"><a href="#2-14-4-3-使用-getopts-命令" class="headerlink" title="2.14.4.3 使用 getopts 命令"></a>2.14.4.3 使用 getopts 命令</h4><ul>
<li><code>getopts optstring variable</code></li>
<li>getopts 命令要用到两个环境变量。如果选项需要加带参数值,那么 OPTARG 环境变量保存的就是这个值。OPTIND 环境变量保存着参数列表中 getopts 正在处理的参数位置。这样在处理完当前选项之后就能继续处理其他命令行参数了。<br>使用举例：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> :ab: opt; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$opt</span> <span class="keyword">in</span></span><br><span class="line">        a)</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;Option a&quot;</span> ;;</span><br><span class="line">        b)</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;Option b with value <span class="variable">$OPTARG</span>&quot;</span> ;;</span><br><span class="line">        \?)</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;Invalid option: -<span class="variable">$opt</span>&quot;</span> ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在解析命令行选项时,getopts 命令会移 除起始的连字符,所以在 case 语句中不用连字符。</li>
<li>选项字符串中的冒号(:)表示该选项需要一个参数值。</li>
</ul>
<h3 id="2-14-6-获取用户输入"><a href="#2-14-6-获取用户输入" class="headerlink" title="2.14.6 获取用户输入"></a>2.14.6 获取用户输入</h3><h4 id="2-14-6-1-基本的读取"><a href="#2-14-6-1-基本的读取" class="headerlink" title="2.14.6.1 基本的读取"></a>2.14.6.1 基本的读取</h4><ul>
<li>read 命令从标准输入(键盘)或另一个文件描述符中接受输入。获取输入后,read 命令会 将数据存入变量。<code>read variable</code></li>
<li>read 命令也提供了-p 选项,允许直接指定提示符:<code>read -p &quot;Enter your name: &quot; name</code></li>
</ul>
<h4 id="2-14-6-2-超时"><a href="#2-14-6-2-超时" class="headerlink" title="2.14.6.2 超时"></a>2.14.6.2 超时</h4><ul>
<li>用-t 选项来指定一个计时器。-t 选项会指定 read 命令等待输入的 秒数。如果计时器超时,则 read 命令会返回非 0 退出状态码</li>
<li>用-n 选项来指定 read 命令读取的字符数，read会在接收到设定个数的字符后自动退出。</li>
</ul>
<h4 id="2-14-6-3-无显示读取"><a href="#2-14-6-3-无显示读取" class="headerlink" title="2.14.6.3 无显示读取"></a>2.14.6.3 无显示读取</h4><ul>
<li>-s 选项可以避免在 read 命令中输入的数据出现在屏幕上(其实数据还是会被显示,只不 过 read 命令将文本颜色设成了跟背景色一样)</li>
</ul>
<h4 id="2-14-6-4-从文件中读取"><a href="#2-14-6-4-从文件中读取" class="headerlink" title="2.14.6.4 从文件中读取"></a>2.14.6.4 从文件中读取</h4><ul>
<li>每次调用 read 命令都会从指定文件中读取一行文本。 当文件中没有内容可读时,read 命令会退出并返回非 0 退出状态码。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$line</span></span><br><span class="line"><span class="keyword">done</span> &lt; input.txt</span><br></pre></td></tr></table></figure>

<h2 id="2-15-呈现数据"><a href="#2-15-呈现数据" class="headerlink" title="2.15 呈现数据"></a>2.15 呈现数据</h2><h3 id="2-15-1-理解输入和输出"><a href="#2-15-1-理解输入和输出" class="headerlink" title="2.15.1 理解输入和输出"></a>2.15.1 理解输入和输出</h3><table>
<thead>
<tr>
<th>文件描述符</th>
<th>缩写</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>STDIN</td>
<td>标准输入</td>
</tr>
<tr>
<td>1</td>
<td>STDOUT</td>
<td>标准输出</td>
</tr>
<tr>
<td>2</td>
<td>STDERR</td>
<td>标准错误</td>
</tr>
</tbody></table>
<ul>
<li>shell 对于错误消息的处理是跟普通输出分开的。只使用“&gt;”重定向只能重定向标准输出,而不能重定向标准错误。</li>
<li>在默认情况下,STDERR 和 STDOUT 指向同一个地方————显示器。</li>
</ul>
<h4 id="2-15-1-2-重定向错误"><a href="#2-15-1-2-重定向错误" class="headerlink" title="2.15.1.2 重定向错误"></a>2.15.1.2 重定向错误</h4><ol>
<li>只重定向错误</li>
</ol>
<ul>
<li><code>command 2&gt; &amp;1</code> 2与“&gt;”必须紧挨着,否则无法正常工作</li>
</ul>
<ol start="2">
<li>重定向错误消息和正常输出</li>
</ol>
<ul>
<li>如果想重定向错误消息和正常输出,则必须使用两个重定向符号。你需要在重定向符号之前 放上需要重定向的文件描述符,然后让它们指向用于保存数据的输出文件</li>
<li>将 STDERR 和 STDOUT 的输出重定向到同一个文件：<code>&amp;&gt;</code></li>
</ul>
<h3 id="2-15-2-在脚本中重定向输出"><a href="#2-15-2-在脚本中重定向输出" class="headerlink" title="2.15.2 在脚本中重定向输出"></a>2.15.2 在脚本中重定向输出</h3><ul>
<li>有意在脚本中生成错误消息,可以将单独的一行输出重定向到 STDERR: <code>&gt;&amp;2</code> </li>
<li>在重定向到文件描述符时,必须在文件 描述符索引值之前加一个&amp;</li>
<li>可以理解为：0、1、2为文件描述符，而&amp;1、&amp;2、&amp;3为文件描述符所指代的具体的文件&#x2F;设备名。</li>
</ul>
<h4 id="2-15-2-2-永久重定向"><a href="#2-15-2-2-永久重定向" class="headerlink" title="2.15.2.2 永久重定向"></a>2.15.2.2 永久重定向</h4><ul>
<li>exec 命令会告诉 shell 在脚本执行期间重定向某个特定文件描述符: <code>exec 1&gt; output.txt</code>。还可以用来创建新的文件描述符。<code>exec 3&gt; testfile</code></li>
</ul>
<h3 id="2-15-3-在脚本中重定向输入"><a href="#2-15-3-在脚本中重定向输入" class="headerlink" title="2.15.3 在脚本中重定向输入"></a>2.15.3 在脚本中重定向输入</h3><ul>
<li>exec 命令允许将 STDIN 重定向为文件: <code>exec 0&lt; input.txt</code></li>
<li>只要脚本需要输入, 这个重定向就会起作用：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> 0&lt; testfile </span><br><span class="line">count=1  </span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Line #<span class="variable">$count</span>: <span class="variable">$line</span>&quot;</span> </span><br><span class="line">    count=$[ <span class="variable">$count</span> + 1 ] </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h3 id="2-15-4-创建自己的重定向"><a href="#2-15-4-创建自己的重定向" class="headerlink" title="2.15.4 创建自己的重定向"></a>2.15.4 创建自己的重定向</h3><h4 id="2-15-4-2-重定向文件描述符"><a href="#2-15-4-2-重定向文件描述符" class="headerlink" title="2.15.4.2 重定向文件描述符"></a>2.15.4.2 重定向文件描述符</h4><ul>
<li>恢复已重定向的文件描述符：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> 3&gt;&amp;1 </span><br><span class="line"><span class="built_in">exec</span> 1&gt;test14out</span><br><span class="line">...</span><br><span class="line"><span class="built_in">exec</span> 1&gt;&amp;3</span><br><span class="line"><span class="comment"># 1恢复</span></span><br></pre></td></tr></table></figure>


<h4 id="2-15-4-5-关闭文件描述符"><a href="#2-15-4-5-关闭文件描述符" class="headerlink" title="2.15.4.5 关闭文件描述符"></a>2.15.4.5 关闭文件描述符</h4><ul>
<li>要关闭文件描述符,只需将其重定向到特殊符号&amp;-即可: <code>exec 3&gt;&amp;-</code></li>
</ul>
<h3 id="2-15-5-列出打开的文件描述符"><a href="#2-15-5-列出打开的文件描述符" class="headerlink" title="2.15.5 列出打开的文件描述符"></a>2.15.5 列出打开的文件描述符</h3><ul>
<li>lsof 命令可以列出当前系统中打开的所有文件描述符。</li>
<li>最常用的选项包括-p 和-d,前者允许指定进程 ID(PID),后者允许指定要显示的文件描述符编号(多个编号之间以逗号分隔)。</li>
<li>$$: 当前进程的 PID</li>
<li>lsof的默认输出：</li>
</ul>
<table>
<thead>
<tr>
<th>列</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>COMMAND</td>
<td>进程对应的命令名的前 9 个字符</td>
</tr>
<tr>
<td>PID</td>
<td>进程的 PID</td>
</tr>
<tr>
<td>USER</td>
<td>进程属主的登录名</td>
</tr>
<tr>
<td>FD</td>
<td>文件描述符编号以及访问类型(r 代表读,w 代表写,u 代表读&#x2F;写)</td>
</tr>
<tr>
<td>TYPE</td>
<td>文件的类型(CHR 代表字符型,BLK 代表块型,DIR 代表目录,REG 代表常规文件)</td>
</tr>
<tr>
<td>DEVICE</td>
<td>设备号(主设备号和从设备号)</td>
</tr>
<tr>
<td>SIZE</td>
<td>如果有的话,表示文件的大小</td>
</tr>
<tr>
<td>NODE</td>
<td>本地文件的节点号</td>
</tr>
<tr>
<td>NAME</td>
<td>文件名</td>
</tr>
</tbody></table>
<h3 id="2-15-6-抑制命令输出"><a href="#2-15-6-抑制命令输出" class="headerlink" title="2.15.6 抑制命令输出"></a>2.15.6 抑制命令输出</h3><ul>
<li>重定向到 &#x2F;dev&#x2F;null 可以抑制命令的输出</li>
<li>也可以在输入重定向中将&#x2F;dev&#x2F;null 作为输入文件，快速清除现有文件中的数据：<code>cat /dev/null &gt; testfile</code></li>
</ul>
<h3 id="2-15-7-使用临时文件"><a href="#2-15-7-使用临时文件" class="headerlink" title="2.15.7 使用临时文件"></a>2.15.7 使用临时文件</h3><h4 id="2-15-7-1-创建本地临时文件"><a href="#2-15-7-1-创建本地临时文件" class="headerlink" title="2.15.7.1 创建本地临时文件"></a>2.15.7.1 创建本地临时文件</h4><ul>
<li>mktemp 会在本地目录中创建一个文件。在使用 mktemp 命令时,只需指定 一个文件名模板即可。模板可以包含任意文本字符,同时在文件名末尾要加上 6 个 X。</li>
<li>mktemp 命令会任意地将 6 个 X 替换为同等数量的字符,以保证文件名在目录中是唯一的。 你可以创建多个临时文件,并确保每个文件名都不重复</li>
<li>mktemp 命令的输出正是它所创建的文件名。</li>
</ul>
<h4 id="2-15-7-2-在-tmp-目录中创建临时文件"><a href="#2-15-7-2-在-tmp-目录中创建临时文件" class="headerlink" title="2.15.7.2 在&#x2F;tmp 目录中创建临时文件"></a>2.15.7.2 在&#x2F;tmp 目录中创建临时文件</h4><ul>
<li>-t 选项会强制 mktemp 命令在系统的临时目录中创建文件。在使用这个特性时,mktemp 命令会返回所创建的临时文件的完整路径名,而不只是文件名</li>
</ul>
<h4 id="2-15-7-3-创建临时目录"><a href="#2-15-7-3-创建临时目录" class="headerlink" title="2.15.7.3 创建临时目录"></a>2.15.7.3 创建临时目录</h4><ul>
<li>-d 选项会告诉 mktemp 命令创建一个临时目录。你可以根据需要使用该目录,比如在其中 创建其他的临时文件</li>
</ul>
<h3 id="2-15-8-记录消息"><a href="#2-15-8-记录消息" class="headerlink" title="2.15.8 记录消息"></a>2.15.8 记录消息</h3><ul>
<li>tee 命令就像是连接管道的 T 型接头,它能将来自 STDIN 的数据同时送往两处。一处是 STDOUT,另一处是 tee 命令行所指定的文件名（这个文件不需要先前存在）</li>
<li>配合管道命令来重定向命令输出: <code>command | tee testfile</code></li>
<li>tee 命令的 -a 选项会将输出追加到文件中,而不是覆盖文件内容</li>
</ul>
<h2 id="2-16-脚本控制"><a href="#2-16-脚本控制" class="headerlink" title="2.16 脚本控制"></a>2.16 脚本控制</h2><h3 id="2-16-1-处理信号"><a href="#2-16-1-处理信号" class="headerlink" title="2.16.1 处理信号"></a>2.16.1 处理信号</h3><h4 id="2-16-1-1-重温-Linux-信号"><a href="#2-16-1-1-重温-Linux-信号" class="headerlink" title="2.16.1.1 重温 Linux 信号"></a>2.16.1.1 重温 Linux 信号</h4><table>
<thead>
<tr>
<th>信号值</th>
<th>信号名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIGHUP</td>
<td>挂起(hang up)进程</td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>中断(interrupt)进程</td>
</tr>
<tr>
<td>3</td>
<td>SIGQUIT</td>
<td>停止(stop)进程</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>无条件终止(terminate)进程</td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>尽可能终止进程</td>
</tr>
<tr>
<td>18</td>
<td>SIGCONT</td>
<td>继续运行停止的进程</td>
</tr>
<tr>
<td>19</td>
<td>SIGSTOP</td>
<td>无条件停止,但不终止进程</td>
</tr>
<tr>
<td>20</td>
<td>SIGTSTP</td>
<td>停止或暂停(pause),但不终止进程</td>
</tr>
</tbody></table>
<h3 id="2-16-2-以后台模式运行脚本"><a href="#2-16-2-以后台模式运行脚本" class="headerlink" title="2.16.2 以后台模式运行脚本"></a>2.16.2 以后台模式运行脚本</h3><h4 id="2-16-2-1-后台运行脚本"><a href="#2-16-2-1-后台运行脚本" class="headerlink" title="2.16.2.1 后台运行脚本"></a>2.16.2.1 后台运行脚本</h4><ul>
<li>以后台模式运行 shell 脚本非常简单,只需在脚本名后面加上&amp;即可</li>
</ul>
<h3 id="2-16-3-在非控制台下运行脚本"><a href="#2-16-3-在非控制台下运行脚本" class="headerlink" title="2.16.3 在非控制台下运行脚本"></a>2.16.3 在非控制台下运行脚本</h3><ul>
<li>有时候,即便退出了终端会话,你也想在终端会话中启动 shell 脚本,让脚本一直以后台模 式运行到结束。这可以用 nohup 命令来实现</li>
<li>nohup 命令能阻断发给特定进程的 SIGHUP 信号。当退出终端会话时,这可以避免进程退出</li>
<li><code>nohup command</code></li>
</ul>
<h3 id="2-16-4-作业控制"><a href="#2-16-4-作业控制" class="headerlink" title="2.16.4 作业控制"></a>2.16.4 作业控制</h3><h4 id="2-16-4-1-查看作业"><a href="#2-16-4-1-查看作业" class="headerlink" title="2.16.4.1 查看作业"></a>2.16.4.1 查看作业</h4><ul>
<li>jobs 是作业控制中的关键命令,该命令允许用户查看 shell 当前正在处理的作业</li>
<li>可以使用 jobs 命令的-l 选项(小写字母 l)查看作业的 PID</li>
</ul>
<h4 id="2-16-4-2-重启已停止的作业"><a href="#2-16-4-2-重启已停止的作业" class="headerlink" title="2.16.4.2 重启已停止的作业"></a>2.16.4.2 重启已停止的作业</h4><ul>
<li>暂停： ^Z</li>
<li>要以后台模式重启作业,可以使用 bg 命令</li>
<li>如果存在多个作业,则需要在 bg 命令后加上作业号</li>
</ul>
<h3 id="2-16-6-定时运行作业"><a href="#2-16-6-定时运行作业" class="headerlink" title="2.16.6 定时运行作业"></a>2.16.6 定时运行作业</h3><h4 id="2-16-6-1-使用-at-命令调度作业"><a href="#2-16-6-1-使用-at-命令调度作业" class="headerlink" title="2.16.6.1 使用 at 命令调度作业"></a>2.16.6.1 使用 at 命令调度作业</h4><ul>
<li><code>at [-f filename] time</code>。适用于计划运行少数几次。</li>
</ul>
<h4 id="2-16-6-2-调度需要定期运行的脚本"><a href="#2-16-6-2-调度需要定期运行的脚本" class="headerlink" title="2.16.6.2 调度需要定期运行的脚本"></a>2.16.6.2 调度需要定期运行的脚本</h4><ul>
<li>Linux 系统使用 cron 程序调度需要定期执行的作业。cron 在后台运行,并会检查一个特殊的 表(cron 时间表),从中获知已安排执行的作业</li>
<li>cron 时间表通过一种特别的格式指定作业何时运行,其格式如下:<br><code>minutepasthour hourofday dayofmonth month dayofweek command</code></li>
<li>cron 时间表允许使用特定值、取值范围(比如 1-5)或者通配符(*)来指定各个字段。</li>
<li>如果想在每天的 10:15 运行一个命令,可以使用如下 cron 时间表字段: <code>15 10 * * * command</code></li>
<li>列出已有的 cron 时间表：<code>crontab -l</code></li>
<li>向cron 时间表添加字段： <code>crontab -e</code>, 然后添加<code>15 10 * * * command</code></li>
<li>保存并退出编辑器后, cron 会在指定的时间运行命令</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://Eliano64.github.io">Eliano</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://eliano64.github.io/2025/08/19/250811-250817-%E5%91%A8%E8%AE%B0-linux%E5%91%BD%E4%BB%A4%E4%B8%8Eshell%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-2/">https://eliano64.github.io/2025/08/19/250811-250817-%E5%91%A8%E8%AE%B0-linux%E5%91%BD%E4%BB%A4%E4%B8%8Eshell%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://Eliano64.github.io" target="_blank">Elian's blog page</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/shell/">shell</a><a class="post-meta__tags" href="/tags/reading-note/">reading note</a><a class="post-meta__tags" href="/tags/linux/">linux</a><a class="post-meta__tags" href="/tags/Linux-Command-Line-and-Shell-Scripting-Bible/">Linux Command Line and Shell Scripting Bible</a></div><div class="post-share"><div class="social-share" data-image="https://avatars.githubusercontent.com/u/149126004?v=4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/08/18/250811-250817-%E5%91%A8%E8%AE%B0-linux%E5%91%BD%E4%BB%A4%E4%B8%8Eshell%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-1/" title="250811-250817 周记 linux命令与shell编程学习(1)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">250811-250817 周记 linux命令与shell编程学习(1)</div></div><div class="info-2"><div class="info-item-1">本周学习了Linux Command Line and Shell Scripting Bible这本书的第一部分到第二部分。这里对一些我自己不熟悉的、我自己觉得比较重要的内容进行记录摘要。 1. 第一部分 linux命令行1.3 bash shell基础命令1.3.5 列出文件和目录1.3.5.3 过滤输出列表 模式匹配: 问号(?)代表任意单个字符; 星号(*)代表零个或多个字符。 方括号代表单个字符位置并给出了该位置上的多个可能的选择。你可以将可能的字符逐一列出,也可以指定字符范围,比如字母范围[a–i]。 还可以使用惊叹号(!)将不需要的内容排除在外。  1.3.6 处理文件1.3.6.2 复制文件 cp 命令可以完成文件和目录从文件系统的一个位置复制到另一个位置的操作。  cp 命令最基本的用法需要两个参数,即源对象和目标对象:cp source destination。 当参数 source 和 destination 都是文件名时,cp 命令会将源文件复制成一个新的目标文件,并以 destination...</div></div></div></a><a class="pagination-related" href="/2025/08/24/250824-thinking-Trie/" title="250824 thinking Trie"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">250824 thinking Trie</div></div><div class="info-2"><div class="info-item-1">字典树（Trie）是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。每个节点有26个子节点，子节点的序号分别代表26个字母。因此，从根节点到某个节点的路径表示一个字符串。有时候，每个节点会有一个标记，用于表示是否为一个字符串的结束。如果一个节点的标记为true，那么从根节点到该节点的路径表示的字符串就是一个单词。 C++示例以下是一个简单的C++实现，支持插入、搜索和前缀搜索。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Node &#123;public:    int end;    vector&lt;unique_ptr&lt;Node&gt;&gt; son;    Node():end(0),son(26)&#123;&#125;;&#125;;class Trie &#123;public:    unique_ptr&lt;Node&gt; root;    Trie() &#123;       ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/08/18/250811-250817-%E5%91%A8%E8%AE%B0-linux%E5%91%BD%E4%BB%A4%E4%B8%8Eshell%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-1/" title="250811-250817 周记 linux命令与shell编程学习(1)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-18</div><div class="info-item-2">250811-250817 周记 linux命令与shell编程学习(1)</div></div><div class="info-2"><div class="info-item-1">本周学习了Linux Command Line and Shell Scripting Bible这本书的第一部分到第二部分。这里对一些我自己不熟悉的、我自己觉得比较重要的内容进行记录摘要。 1. 第一部分 linux命令行1.3 bash shell基础命令1.3.5 列出文件和目录1.3.5.3 过滤输出列表 模式匹配: 问号(?)代表任意单个字符; 星号(*)代表零个或多个字符。 方括号代表单个字符位置并给出了该位置上的多个可能的选择。你可以将可能的字符逐一列出,也可以指定字符范围,比如字母范围[a–i]。 还可以使用惊叹号(!)将不需要的内容排除在外。  1.3.6 处理文件1.3.6.2 复制文件 cp 命令可以完成文件和目录从文件系统的一个位置复制到另一个位置的操作。  cp 命令最基本的用法需要两个参数,即源对象和目标对象:cp source destination。 当参数 source 和 destination 都是文件名时,cp 命令会将源文件复制成一个新的目标文件,并以 destination...</div></div></div></a><a class="pagination-related" href="/2025/08/24/250824-thinking-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" title="250824 thinking 单例模式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-24</div><div class="info-item-2">250824 thinking 单例模式</div></div><div class="info-2"><div class="info-item-1">1. 什么是单例模式？单例模式（Singleton Pattern）是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点来访问该实例。 2. 为什么需要单例模式？在多线程环境下，我们需要多个线程使用同一份资源。 2.1 为什么不使用全局变量？在一些较为简单的环境中，直接使用一些全局变量供所有线程使用是很好的。 但是，如果这个对象是资源密集型的，使用全局变量会导致资源的浪费。而且，简单的全局变量没有提供访问控制（封装），线程可以任意地访问和修改。 而单例模式就可以实现按需创建实例，避免了资源的浪费。而且提供了类封装，确保不会有意外的修改。 3. 单例模式的实现（C++）这其实体现了一种static关键字的妙用。 123456789101112131415class Singleton &#123;public:    static Singleton* getInstance() &#123;        static Singleton instance;        return &amp;instance;    &#125;    //...other...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://avatars.githubusercontent.com/u/149126004?v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Eliano</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Eliano64"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-text">2. 第二部分 shell 脚本编程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-11-%E6%9E%84%E5%BB%BA%E5%9F%BA%E7%A1%80%E8%84%9A%E6%9C%AC"><span class="toc-text">2.11 构建基础脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-11-2-%E5%88%9B%E5%BB%BA-shell-%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="toc-text">2.11.2 创建 shell 脚本文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-11-3-%E6%98%BE%E7%A4%BA%E6%B6%88%E6%81%AF"><span class="toc-text">2.11.3 显示消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-11-4-%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F"><span class="toc-text">2.11.4 使用变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-11-4-1-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">2.11.4.1 环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-11-4-2-%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="toc-text">2.11.4.2 用户自定义变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-11-4-3-%E5%91%BD%E4%BB%A4%E6%9B%BF%E6%8D%A2"><span class="toc-text">2.11.4.3 命令替换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-11-5-%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="toc-text">2.11.5 重定向输入和输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-11-5-1-%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">2.11.5.1 输出重定向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-11-5-2-%E8%BE%93%E5%85%A5%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">2.11.5.2 输入重定向</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-11-6-%E7%AE%A1%E9%81%93"><span class="toc-text">2.11.6 管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-11-7-%E6%89%A7%E8%A1%8C%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97"><span class="toc-text">2.11.7 执行数学运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-11-7-2-%E4%BD%BF%E7%94%A8%E6%8B%AC%E5%8F%B7"><span class="toc-text">2.11.7.2 使用括号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-11-8-%E9%80%80%E5%87%BA%E8%84%9A%E6%9C%AC"><span class="toc-text">2.11.8 退出脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-11-8-1-%E6%9F%A5%E7%9C%8B%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">2.11.8.1 查看退出状态码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-8-2-exit-%E5%91%BD%E4%BB%A4"><span class="toc-text">2.1.8.2 exit 命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-12-%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4"><span class="toc-text">2.12 结构化命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-12-1-%E4%BD%BF%E7%94%A8-if-then-%E8%AF%AD%E5%8F%A5"><span class="toc-text">2.12.1 使用 if-then 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-12-2-if-then-else"><span class="toc-text">2.12.2 if-then-else</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-12-3-if-then-elif-else"><span class="toc-text">2.12.3 if-then-elif-else</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-12-4-test-%E5%91%BD%E4%BB%A4"><span class="toc-text">2.12.4 test 命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-12-4-1-%E6%95%B0%E5%80%BC%E6%AF%94%E8%BE%83"><span class="toc-text">2.12.4.1 数值比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-12-4-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83"><span class="toc-text">2.12.4.2 字符串比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-12-4-3-%E6%96%87%E4%BB%B6%E6%AF%94%E8%BE%83"><span class="toc-text">2.12.4.3 文件比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-12-5-%E5%A4%8D%E5%90%88%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95"><span class="toc-text">2.12.5 复合条件测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-12-6-if-then-%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="toc-text">2.12.6 if-then 的高级特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-12-6-1-%E4%BD%BF%E7%94%A8%E5%8D%95%E6%8B%AC%E5%8F%B7"><span class="toc-text">2.12.6.1 使用单括号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-12-6-2-%E4%BD%BF%E7%94%A8%E5%8F%8C%E6%8B%AC%E5%8F%B7"><span class="toc-text">2.12.6.2 使用双括号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-12-6-3-%E4%BD%BF%E7%94%A8%E5%8F%8C%E6%96%B9%E6%8B%AC%E5%8F%B7"><span class="toc-text">2.12.6.3 使用双方括号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-12-7-case-%E5%91%BD%E4%BB%A4"><span class="toc-text">2.12.7 case 命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-13-%E6%9B%B4%E5%A4%9A%E7%9A%84%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4"><span class="toc-text">2.13 更多的结构化命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-13-1-for-%E5%91%BD%E4%BB%A4"><span class="toc-text">2.13.1 for 命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-13-1-2-%E8%AF%BB%E5%8F%96%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%A4%8D%E6%9D%82%E5%80%BC"><span class="toc-text">2.13.1.2 读取列表中的复杂值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-13-1-5-%E6%9B%B4%E6%94%B9%E5%AD%97%E6%AE%B5%E5%88%86%E9%9A%94%E7%AC%A6"><span class="toc-text">2.13.1.5 更改字段分隔符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-13-1-6-%E4%BD%BF%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E8%AF%BB%E5%8F%96%E7%9B%AE%E5%BD%95"><span class="toc-text">2.13.1.6 使用通配符读取目录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-13-2-C-%E8%AF%AD%E8%A8%80%E9%A3%8E%E6%A0%BC%E7%9A%84-for-%E5%91%BD%E4%BB%A4"><span class="toc-text">2.13.2 C 语言风格的 for 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-13-3-while-%E5%91%BD%E4%BB%A4"><span class="toc-text">2.13.3 while 命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-13-3-1-while-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F"><span class="toc-text">2.13.3.1 while 的基本格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-13-7-%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6"><span class="toc-text">2.13.7 循环控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-13-7-1-break-%E5%91%BD%E4%BB%A4"><span class="toc-text">2.13.7.1 break 命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-13-7-2-continue-%E5%91%BD%E4%BB%A4"><span class="toc-text">2.13.7.2 continue 命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-13-8-%E5%A4%84%E7%90%86%E5%BE%AA%E7%8E%AF%E7%9A%84%E8%BE%93%E5%87%BA"><span class="toc-text">2.13.8 处理循环的输出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-14-%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5"><span class="toc-text">2.14 处理用户输入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-14-1-%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-text">2.14.1 传递参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-14-1-1-%E8%AF%BB%E5%8F%96%E5%8F%82%E6%95%B0"><span class="toc-text">2.14.1.1 读取参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-14-1-2-%E8%AF%BB%E5%8F%96%E8%84%9A%E6%9C%AC%E5%90%8D"><span class="toc-text">2.14.1.2 读取脚本名</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-14-2-%E7%89%B9%E6%AE%8A%E5%8F%82%E6%95%B0%E5%8F%98%E9%87%8F"><span class="toc-text">2.14.2 特殊参数变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-14-2-1-%E5%8F%82%E6%95%B0%E7%BB%9F%E8%AE%A1"><span class="toc-text">2.14.2.1 参数统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-14-2-2-%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-text">2.14.2.2 获取所有的数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-14-3-%E7%A7%BB%E5%8A%A8%E5%8F%82%E6%95%B0"><span class="toc-text">2.14.3 移动参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-14-4-3-%E4%BD%BF%E7%94%A8-getopts-%E5%91%BD%E4%BB%A4"><span class="toc-text">2.14.4.3 使用 getopts 命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-14-6-%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5"><span class="toc-text">2.14.6 获取用户输入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-14-6-1-%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%AF%BB%E5%8F%96"><span class="toc-text">2.14.6.1 基本的读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-14-6-2-%E8%B6%85%E6%97%B6"><span class="toc-text">2.14.6.2 超时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-14-6-3-%E6%97%A0%E6%98%BE%E7%A4%BA%E8%AF%BB%E5%8F%96"><span class="toc-text">2.14.6.3 无显示读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-14-6-4-%E4%BB%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96"><span class="toc-text">2.14.6.4 从文件中读取</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-15-%E5%91%88%E7%8E%B0%E6%95%B0%E6%8D%AE"><span class="toc-text">2.15 呈现数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-15-1-%E7%90%86%E8%A7%A3%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="toc-text">2.15.1 理解输入和输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-15-1-2-%E9%87%8D%E5%AE%9A%E5%90%91%E9%94%99%E8%AF%AF"><span class="toc-text">2.15.1.2 重定向错误</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-15-2-%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%87%BA"><span class="toc-text">2.15.2 在脚本中重定向输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-15-2-2-%E6%B0%B8%E4%B9%85%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">2.15.2.2 永久重定向</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-15-3-%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%85%A5"><span class="toc-text">2.15.3 在脚本中重定向输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-15-4-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">2.15.4 创建自己的重定向</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-15-4-2-%E9%87%8D%E5%AE%9A%E5%90%91%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-text">2.15.4.2 重定向文件描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-15-4-5-%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-text">2.15.4.5 关闭文件描述符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-15-5-%E5%88%97%E5%87%BA%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-text">2.15.5 列出打开的文件描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-15-6-%E6%8A%91%E5%88%B6%E5%91%BD%E4%BB%A4%E8%BE%93%E5%87%BA"><span class="toc-text">2.15.6 抑制命令输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-15-7-%E4%BD%BF%E7%94%A8%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6"><span class="toc-text">2.15.7 使用临时文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-15-7-1-%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6"><span class="toc-text">2.15.7.1 创建本地临时文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-15-7-2-%E5%9C%A8-tmp-%E7%9B%AE%E5%BD%95%E4%B8%AD%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6"><span class="toc-text">2.15.7.2 在&#x2F;tmp 目录中创建临时文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-15-7-3-%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E7%9B%AE%E5%BD%95"><span class="toc-text">2.15.7.3 创建临时目录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-15-8-%E8%AE%B0%E5%BD%95%E6%B6%88%E6%81%AF"><span class="toc-text">2.15.8 记录消息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-16-%E8%84%9A%E6%9C%AC%E6%8E%A7%E5%88%B6"><span class="toc-text">2.16 脚本控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-16-1-%E5%A4%84%E7%90%86%E4%BF%A1%E5%8F%B7"><span class="toc-text">2.16.1 处理信号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-16-1-1-%E9%87%8D%E6%B8%A9-Linux-%E4%BF%A1%E5%8F%B7"><span class="toc-text">2.16.1.1 重温 Linux 信号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-16-2-%E4%BB%A5%E5%90%8E%E5%8F%B0%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC"><span class="toc-text">2.16.2 以后台模式运行脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-16-2-1-%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC"><span class="toc-text">2.16.2.1 后台运行脚本</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-16-3-%E5%9C%A8%E9%9D%9E%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%8B%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC"><span class="toc-text">2.16.3 在非控制台下运行脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-16-4-%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6"><span class="toc-text">2.16.4 作业控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-16-4-1-%E6%9F%A5%E7%9C%8B%E4%BD%9C%E4%B8%9A"><span class="toc-text">2.16.4.1 查看作业</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-16-4-2-%E9%87%8D%E5%90%AF%E5%B7%B2%E5%81%9C%E6%AD%A2%E7%9A%84%E4%BD%9C%E4%B8%9A"><span class="toc-text">2.16.4.2 重启已停止的作业</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-16-6-%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C%E4%BD%9C%E4%B8%9A"><span class="toc-text">2.16.6 定时运行作业</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-16-6-1-%E4%BD%BF%E7%94%A8-at-%E5%91%BD%E4%BB%A4%E8%B0%83%E5%BA%A6%E4%BD%9C%E4%B8%9A"><span class="toc-text">2.16.6.1 使用 at 命令调度作业</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-16-6-2-%E8%B0%83%E5%BA%A6%E9%9C%80%E8%A6%81%E5%AE%9A%E6%9C%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E8%84%9A%E6%9C%AC"><span class="toc-text">2.16.6.2 调度需要定期运行的脚本</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/26/250926-thinking-%E5%B7%AE%E5%88%86/" title="250926 thinking 差分">250926 thinking 差分</a><time datetime="2025-09-26T02:56:12.000Z" title="发表于 2025-09-26 10:56:12">2025-09-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/26/250926-thinking-%E5%AD%90%E5%BA%8F%E5%88%97%E5%88%A4%E6%96%AD/" title="250926 thinking 子序列判断">250926 thinking 子序列判断</a><time datetime="2025-09-26T02:49:05.000Z" title="发表于 2025-09-26 10:49:05">2025-09-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/26/250926-tool-docker-install-command/" title="250926 tool docker install&amp;command">250926 tool docker install&amp;command</a><time datetime="2025-09-26T00:53:57.000Z" title="发表于 2025-09-26 08:53:57">2025-09-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/25/250824-thinking-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" title="250824 thinking 快速排序">250824 thinking 快速排序</a><time datetime="2025-08-25T00:54:27.000Z" title="发表于 2025-08-25 08:54:27">2025-08-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/24/250824-thinking-Trie/" title="250824 thinking Trie">250824 thinking Trie</a><time datetime="2025-08-24T11:03:00.000Z" title="发表于 2025-08-24 19:03:00">2025-08-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2025 By Eliano</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div><div class="footer_custom_text">All Rights Reserved.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js')
    await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/auto-render.min.js')
    if (false) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  // 渲染数学公式
  if (window.renderMathInElement) {
    renderMathInElement(document.body, {
      delimiters: [
        {left: '$$', right: '$$', display: true},
        {left: '$', right: '$', display: false},
        {left: '\\[', right: '\\]', display: true},
        {left: '\\(', right: '\\)', display: false}
      ],
      throwOnError: false
    })
  }

  showKatex()
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script></div></body></html>