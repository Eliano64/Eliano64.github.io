<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>250707-250714 周记 2024-xv6-labs(1)</title>
    <url>/2025/07/14/250707-250714-%E5%91%A8%E8%AE%B0-2024-xv6-labs-1/</url>
    <content><![CDATA[本周主要完成了2024-xv6-labs的util到cow的五个实验。
1. util lab1.1 sleep这个算是最简单的实验了。按照hints一步步写即可。没有任何额外需要注意的地方。
1.2 pingpong这个实验的主要难点是理解pipe函数的使用。先查看 sys_pipe函数：
voidsys_pipe(void)&#123;   uint64 fdarray; // user pointer to array of two integers   struct file *rf, *wf;   int fd0, fd1;   struct proc *p = myproc();      argaddr(0, &amp;fdarray);   if(pipealloc(&amp;rf, &amp;wf) &lt; 0)&#123;    ...   &#125;     ...   if((fd0 = fdalloc(rf)) &lt; 0 || (fd1 = fdalloc(wf)) &lt; 0)&#123;    ...   &#125;   if(copyout(p-&gt;pagetable, fdarray, (char*)&amp;fd0, sizeof(fd0)) &lt; 0 ||    copyout(p-&gt;pagetable, fdarray+sizeof(fd0), (char *)&amp;fd1, sizeof(fd1)) &lt; 0)&#123;    ...    &#125;    ...&#125;

再继续查看 pipealloc fdalloc copyout等相关函数的定义。可见，pipe是把两个文件描述符分别传给了fdarray[0]和fdarray[1]，且fdarray[0]只读，fdarray[1]只写。
而本题中，需要父-&gt;子 子-&gt;父两个管道。且对于父进程和子进程都需要读和写，最后代码如下：
int p1[2]; // 父进程-&gt;子进程int p2[2]; // 子进程-&gt;父进程pipe(p1);pipe(p2);char buf;if(pid&gt;0)&#123;    close(p1[0]); // 关闭p1读端    close(p2[1]); // 关闭p2写端    write(p1[1], &quot;a&quot;, 1);    close(p1[1]);    read(p2[0],&amp;buf,1);    close(p2[0]);    wait(0);    fprintf(2, &quot;%d: received pong\n&quot;, getpid());&#125;else&#123;    close(p1[1]);    close(p2[0]);    read(p1[0],&amp;buf,1);    close(p1[0]);    fprintf(2, &quot;%d: received ping\n&quot;, getpid());    write(p2[1],&quot;a&quot;,1);    close(p2[1]);&#125;

1.3 primes这题更为考验 pipe的使用，而且要特别小心，需留意哪些文件描述符不会使用了并把他们都关闭。否则会导致资源耗尽，在大约37的地方输出乱码。
该题提取质数的流程如下：
//Input: file descriptor//Output: void//print the &quot;first&quot; prime in the sequence filtered by last process, and past the  //left sequence to next process recursively.primes(fd) :     if the sequence is empty do:        close(fd);        exit;    print the first number of the sequence;    fork;    pipe;    if is parent proc do:        pass the first number&#x27;s multiples;        write the left numnbers to son proc via pipe;        close(fd);        close(pipe&#x27;s write);        wait;    if is son proc do:        close(fd);        close(pipe&#x27;s write);        primes(pipe&#x27;s read);    exit;

1.4 find实际上，find的写法跟 ls写法几乎相同，对于目录文件而言 ls是打印下面的所有文件，而 find只打印下面名字与第二个参数相同的文件。只是要注意到 find是递归查看目录文件，所以要额外处理”.”和”..”。
1.5 xargs这题的关键是，如何处理 xargs前 |之前的部分的输出。
首先要查明，这些输出是被管道重定向到了 stdin里，而 stdin对应的 fd为0.
然后就是使用read将 stdin里的拼接在原argv后面。注意 &#39; &#39;和 &#39;\n&#39;的情况，前者代表一个参数输入结束，后者不仅代表结束，还需要立即执行一次。
注意在 exec()中，argv末尾需以 0标志。
2. syscall lab2.1 trace这题其实理清流程即可，并不复杂：
将 trace的第一个参数（掩码）给 myproc()保存 ———— 所以 proc结构体需要新添加一个属性 mask来存。然后每当 myproc()执行系统调用时候，检查掩码中对于该系统调用对应的位是否为1（p-&gt;mask&amp;(1&lt;&lt;num)），以此来决定是否打印该系统调用。
2.2 attack这道题。。。。emmmm。。。说实话我现在都没有想通。
这道题思路很明显：既然新分配的内存保留了其先前使用的內容，那么attack也申请内存，在其中的某一页中的32个偏移开始8字节就一定是 secrest。
关键在于：哪一页？
说实话，我真是万策尽矣，无论是打印申请的每一页开头40字节，还是用前缀字符来比较（这个甚至诡异得一塌糊涂：attack申请后那一存着secret的页开头2字节是乱码），都一一失败了😭。
最后是在不得已，去github上找到了参考：申请32页的第16页。
以下是作者的原话：不能理解！这个16是怎么来的？？
（我也不能理解。。。）
3. pgtbl lab第3章是我目前为止xv6中做过的最痛苦的实验了😭,我真花了两三天时间做这个。尤其是最后一个超级块的部分，我搞了约14个小时，才过测试。。。
3.1 ugetpid这个题目的难点。。。在于看不懂题目，找不到该在哪里写什么（bushi）。
但其实也很简单：在用户空间里拿一页空间 USYSCALL存 usyscall，usyscall来存一些东西（这里是 getpid()）proc定义里添加它的地址，allocproc freeproc proc_pagetable proc_freepagetable这些与进程内存分配释放的函数里面也类似地加上处理 USYSCALL的部分即可。
但是有一点要注意：关于 USYSCALL页”user can access but read only”.
3.2 vmprint这个的关键点在于，搞清楚虚拟页和对应的三级页表。

如果PTE叶在0级页表上，则对应的虚拟页相对于初始虚拟页的偏移是在30~38位上；
如果PTE叶在1级页表上，则对应的虚拟页相对于初始虚拟页的偏移是在21~29位上；
如果PTE叶在2级页表上，则对应的虚拟页相对于初始虚拟页的偏移是在12~20位上。

（PTE叶指的是有效的，且不表示下一级页表的pte项）
3.3 super block太困难了！太困难了！😭
我最后甚至也是钻了空子（我留了10个超级块，而测试最多用8个超级块）才过的。
题目的思路很清晰：留几个”super block”使得申请大内存空间时不是给他很多个小页而是给他几个超级块。那么，只要在管理分配页的数据结构中添加超级页并给它们标志，并在处理页的申请释放的函数中类似地加上相应处理逻辑即可。
但是！！！有一些坑！

当地址未对齐时，普通页可以直接 PGROUNDUP对齐。但超级页不能类比！如果直接SUPERPGROUNDUP再分配超级块的话，会导致内存地址空间出现“空隙”，panic(“uvmcopy: page not present”)。所以为了防止这个问题，要先通过分配普通块的方式进行对齐。
超级页必须是在第1级页表上的pte表示，而不是普通页的第0级。因为超级页2MB，普通页4KB，一个第1级页表上的pte表示512个第0级pte————第1级的pte表示2MB。

4. trap lab4.1 backtrace这题也比较简单，照着这个笔记上关于栈帧布局的示意图写代码并打印即可。
4.2 alarm虽是 红 题，但我觉得比 pgtbl那道 蓝 题超级块简单得多。。。
事实上，跟着hints一步步做就好，只是要注意：在进入handler函数时，时钟计数并不会自然停止，我们该在 proc额外设置一个属性来判断当前是否处于handler中。
而且，为了恢复上下文，我们还应该设一个结构体属性作为备份，来存进入handler之前的trapframe的所有内容。
5. cow lab这个实验也挺。。。先是filetest死活过不了，花了我几个小时找bug，然后把bug一改，嘿！您猜怎么着？threetest也过不了了🤣。最后找了两个多小时才找到原来是 kfree这边的问题。
做法其实也是跟着hints一步步来，（注意trap要处理的是  r_scause()==15的情景）只是还是有坑：
由于我把减引用计数的逻辑与kfree写一起的，所以我天真的以为只需要开始减引用计数时和末尾更新 freelist才需要加锁，而中间是不用锁的。然后 kerneltrap给我狠狠上了一课。😂
最后还得别忘了在 usetrap添加处理虚拟地址超出最大值时杀死进程的逻辑，否则 usertests -q过不了。🤣
6. 感谢
MIT的cs6.828以及xv6-labs的设计者们，感谢他们提供如此优质的项目。虽然写的时候很痛苦😂但确实我感到自己对于C语言和操作系统的理解与认识有所深入。
siriusyaoz，在做实验的时候，你的关于这个实验的代码给予了我很多启发🥹。

]]></content>
      <categories>
        <category>2024-xv6-labs</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Projects</tag>
        <tag>Operating System</tag>
        <tag>2024-xv6-labs</tag>
      </tags>
  </entry>
  <entry>
    <title>250714-250720 周记 2024-xv6-labs(2)</title>
    <url>/2025/07/21/250714-250720-%E5%91%A8%E8%AE%B0-2024-xv6-labs-2/</url>
    <content><![CDATA[本周完成了剩下的实验。上一篇见2024-xv6-labs-1
1. net lab1.1 NIC第一个实验是补全e1000_transmit() 和 e1000_recv()
重点在于先要理解e1000初始化的代码，以及e1000_dev.h里给出的各寄存器的定义。
然后理清一下工作流程：transmit所做的，其实就是将发送区和发送环的尾部更新为带发送的数据对应的元数据。注意此时status应为0而不是E1000_TXD_STAT_DD，因为这只是代表将数据填入发送区，并没有真正发送。然后更新E100_TDT的值。但为了防止竞态条件，所以还要注意用e1000_lock加锁。
而receive所做的就是以帧为单位，不断地将缓冲区里的数据交给net_rx()，并更新缓冲区和E1000_RDT，直到遇见E1000_RXD_STAT_DD。这里不用加锁，但值得注意的是E1000_RDT必须在最后更新？想不通。
1.2 UDP Receive说来惭愧，这个部分我实在没有思路，是让ai写的。。。
2. lock2.1 Memory allocator这里需要做的，就是kinit初始化内存管理的数据结构时，是初始化kmem[NCPU]而不是单个kmem，即通过格式化字符串的方式为每个kmem分配一把锁。然后其他跟单个kmem几乎一致。但是在kalloc里，如果某个kmem没有空闲页了，应找一个还有空闲页的kmem，拿一页进行分配。
注意在调用cpuid取当前cpu的id的时候要push_off()关中断，调用完毕要pop_off()重新开启。
但这个实验部分我个人觉得很有意思的就是格式化字符串。
2.2 Buffer cache这个题虽然是红题。但实际上本质并不复杂，它实际上说的是：
原有一个链表和一把大锁，可是这样太低效了，因为需要进行修改的可能是两个不同的节点，没有必要一把大锁把全局锁死。于是使用哈希表，将大链表拆成多个小链表分别存入每个哈希桶里，然后对每个哈希桶给予锁。这样需要进行修改的若是两个不同的节点，则可以实现并发了。
将原bcache的定义改为：
  struct bucket&#123;  struct spinlock lock;  // Linked list of all buffers, through prev/next.  // Sorted by how recently the buffer was used.  // head.next is most recent, head.prev is least.  struct buf head;&#125;;struct &#123;  struct bucket table[NHASH];  struct buf buf[NBUF];&#125; bcache;

然后修改下面的代码，使其符合这个新数据结构即可。。。
才怪！！！🤣🤣🤣
还得有一步，否则panic: bget: no buffers：
因为初始化时候，所有的缓存区都在同一个桶里，其他桶全为空！
此时就应该像上一题一样，从key对应的桶处“偷”一块缓存：
b-&gt;next-&gt;prev = b-&gt;prev;b-&gt;prev-&gt;next = b-&gt;next;release(&amp;bcache.table[key].lock);acquire(&amp;bcache.table[gethash(blockno)].lock);b-&gt;next = bcache.table[gethash(blockno)].head.next;b-&gt;prev = &amp;bcache.table[gethash(blockno)].head;bcache.table[gethash(blockno)].head.next-&gt;prev = b;bcache.table[gethash(blockno)].head.next = b;release(&amp;bcache.table[gethash(blockno)].lock);

3. fs这个实验很奇怪，make grade时会因为qemu-system-riscv64: terminating on signal 15 from pid xxxx(make)导致fail，但是单独地在qemu环境中运行bigfile symlinktest usertests -q却没有问题。难道是我wsl2 ubuntu系统的版本问题吗？
3.1 Large files这里就是将fs.h里面NDIRECT再减少一块作为双重间接块。然后添加定义
#define NDOUBLE (NINDIRECT*NINDIRECT)#define MAXFILE (NDIRECT + NINDIRECT + NDOUBLE)
在bmap里仿照分配间接块的写法，分配双重间接块。
在itrunc里仿照释放间接块的写法，释放双重间接块。
（不过，这个是真绕啊）
这里一定要理清楚：对于双重间接块，256个块为一组，第0层的data就表示每一组。第一层的data则表示每一组的每一块的地址，而第二层的data才表示真正的数据。
所以，对于分配，bn / NINDIRECT计算得组号；对于每个块在该组的序号则由bn % NINDIRECT给出。
对于释放，ip-&gt;addrs[NDIRECT+1]!=0意味着存在未释放的组。因此要对每一个未释放的组，读取它对应的第一层间接块的data，因为一个data[i]!=0就表示一个这一组未释放掉的块的地址。就这样从第2层一直到第0层逐层释放。
3.2 Symbolic links首先是sys_symlink，要在目标路径处创建一个T_SYMLINK类型的文件。并在对应的inode里分配一个缓冲块，写入target，即源文件的路径。
后一步看起来复杂，实际上就是writei函数的调用。
然后是改写sys_open。这里主要是添加一个T_SYMLINK且不是O_NOFOLLOW的处理。
为了方便处理链接的文件也是符号链接的情况，用了一个递归的函数follow
  struct inode*follow(char *path, int cnt)&#123;  if(cnt&gt;=10)&#123;    return 0;  &#125;  struct inode *ip = namei(path);  if(ip==0)&#123;    return 0;  &#125;  ilock(ip);  if(ip-&gt;type != T_SYMLINK)&#123;    return ip;  &#125;  char target[MAXPATH];  if(readi(ip, 0, (uint64)target, 0, MAXPATH) != MAXPATH)&#123;    iunlockput(ip);    return 0;  &#125;  iunlockput(ip);  struct inode *ans = follow(target,cnt+1);  return ans;&#125;


ps:sys_open是在干什么？它是创建一个文件描述符（fd），将它绑定到一个 struct file*，供后续 read(fd) &#x2F;write(fd) 使用。示意如下：

// 1. 从用户拿参数：路径 和 打开方式argstr(0, path);argint(1, &amp;omode);// 2. 找到这个文件的 inode（如果没有而且带 O_CREATE，则创建）ip = namei(path) / create(path);// 3. 分配一个 file 结构f = filealloc();// 4. 分配一个 fd 并将其与 file* 绑定fd = fdalloc(f);      // 进程的 proc-&gt;ofile[fd] = f;// 5. 初始化 file 结构：指向 inode，设置读写权限f-&gt;ip = ip;f-&gt;readable = ...f-&gt;writable = ...

4. mmap呃呃，这个也不是我自己写的。。。😭
这个实验我打算后面再“补票”。（虽然这个flag大概率会倒）
]]></content>
      <categories>
        <category>2024-xv6-labs</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Projects</tag>
        <tag>Operating System</tag>
        <tag>2024-xv6-labs</tag>
      </tags>
  </entry>
  <entry>
    <title>250721 thinking 二分查找</title>
    <url>/2025/07/21/250721-thinking-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[1. 总结二分查找的原理非常简单，但是一些细节例如是 l&lt;r还是 l&lt;=r、更新 r时是 r=mid还是 r=mid-1（l同理）等地方却有些让人头疼，实际写来如果不注意就可能会造成死循环。
于是总结一种模板：
定义域为[lo, hi)的单增的f(x), 找出最小的ans, 使得f(ans)&gt;0成立。
单减同理，甚至可以进行预处理先转化为单增的情况。
伪代码如下：
algorithm binary-search(lo,hi)	while the search area has elments do:		mid &lt;- lo + (hi-lo)/2;		if f(mid) satisfied: // the answer may occur here            		ans := mid;			hi &lt;- mid;             // the search area could have no elments when in the next loop, so return ans;             // but mid&gt;ans if next loop continues,              // for this is a right-open area, hi &lt;- mid;		else :			lo &lt;- mid + 1;             // mid is not the answer, and mid &lt; answer;            // for this is a left-close area, lo &lt;- mid + 1;	end while	return ans;

2. 例
已知一个有序数组，查找一个元素的位置并返回。若该元素不存在，则返回元素应插入的位置。

定义域为[0, nums.size())，找出最小的ans, nums[ans] &gt;&#x3D; target成立
int searchInsert(vector&lt;int&gt;&amp; nums, int target)&#123;        int left=0,right=nums.size(),ans; // f(ans)= nums[ans] 的定义域： ans \in [left, right)        while(left&lt;right)&#123;            int mid=(right-left)/2 + left;//防止直接right+left造成溢出            if(nums[mid]&gt;=target)&#123;//因为我们要找的就是nums[ans]&gt;=target                ans=mid; //所以mid可能为答案。                right=mid; //也可能mid不是答案，更新开的上界为mid            &#125;            else&#123;                left=mid+1; // 否则mid绝对不是答案。更新闭的下界为mid+1。            &#125;        &#125;        return ans; &#125;


给你一个非负整数 x ，计算并返回 x 的 算术平方根 。由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。

定义域为$[0, +\infty)$, 找出最大的$\text{ans}$, $\text{ans}^2 \leqslant x$
int mySqrt(int x) &#123;       long long l = 0, r = x+1, ans; // ans \in [0, +\infty), 但这里对r这样赋值只是为了让ans快速收敛。为什么x+1: x=0,1时 ans = x &lt; x+1。          while (l &lt; r) &#123;            long long  mid = (l+r)&gt;&gt;1;            if (mid * mid &lt;= x) &#123;//因为要找的就是ans*ans&lt;=x                ans = mid; //所以mid可能为答案。                l = mid + 1; //也可能mid不是答案，更新闭的下界为mid+1            &#125; else &#123;                r = mid; // 否则mid绝对不是答案。更新开的上界为mid。            &#125;        &#125;        return ans;     &#125;
]]></content>
      <categories>
        <category>data structure &amp; algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>data structure &amp; algorithm</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title>250721 thinking 单调栈</title>
    <url>/2025/07/21/250721-thinking-%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    <content><![CDATA[
他向远方望去，无法看到高山背后的矮山，只看到一座座更高的山峰。————by 灵神

1. 总结单调栈就是保持栈内元素单调的栈。当新元素破坏单调性时，弹出栈顶元素，弹出的瞬间就找到栈顶元素对应的答案。
栈里存放着暂时还没有找到对应答案的元素。新元素入栈时，如果栈顶元素使得栈单调性被破环，那么栈顶元素的答案产生，栈顶元素找到答案，出栈。因此需要建立的栈的单调性与题目的答案需求往往是“反过来”。要下一个更大就要单减；要下一个更小就要单增。
algorithm generalized-monotonic-stack(A, cmp, process)    stack S ← ∅    for i ← 0 to n-1 do:        while S ≠ ∅ and condition(A[i], A[S.top()]) do: // 栈的单调性被破坏，while是为了让栈里满足条件的元素都可以出栈            j ← S.pop() // 栈顶出栈            recordAnswer(j, i)  // 计算并记录栈顶对应的答案        end while        S.push(i) // 栈为空或者栈的单调性没有被破坏，则新元素一定不是某个元素的答案，入栈    end forend algorithm

时间复杂度为什么是 O(n)？每个元素最多入栈一次，出栈一次，总操作数 ≤ 2n。
2. 问题分类类型1：找下一个更大&#x2F;更小元素模板：
// 下一个更大元素while (!st.empty() &amp;&amp; arr[i] &gt; arr[st.top()]) &#123;    result[st.top()] = arr[i];    st.pop();&#125;// 下一个更小元素  while (!st.empty() &amp;&amp; arr[i] &lt; arr[st.top()]) &#123;    result[st.top()] = arr[i];    st.pop();&#125;

类型2：计算面积&#x2F;距离模板：
// 柱状图最大矩形while (!st.empty() &amp;&amp; heights[i] &lt; heights[st.top()]) &#123;    int h = heights[st.top()];    st.pop();    int w = st.empty() ? i : i - st.top() - 1;    maxArea = max(maxArea, h * w);&#125;// 每日温度（计算距离）while (!st.empty() &amp;&amp; temps[i] &gt; temps[st.top()]) &#123;    int j = st.top();    st.pop();    result[j] = i - j;  // 距离&#125;

3. 典型例题例1：下一个更大元素vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums) &#123;    int n = nums.size();    vector&lt;int&gt; result(n, -1);    stack&lt;int&gt; st;      for (int i = 0; i &lt; n; i++) &#123;        while (!st.empty() &amp;&amp; nums[i] &gt; nums[st.top()]) &#123;            result[st.top()] = nums[i];            st.pop();        &#125;        st.push(i);    &#125;    return result;&#125;

例2：柱状图最大矩形
高度：出栈元素的高度
宽度：当前位置 - 栈顶位置 - 1

寻找当前高度对应的下一个更小的高度。那么在这个答案对应的下标到栈顶对应的下标这段距离，就是当前高度对应的最大宽度。而当前高度也即是下标取值在这个范围内矩形高度取值的最大值（短板效应），所以这里的高度乘以宽度得到的矩形面积就是在下标取值在这个范围内的最大面积。
int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;    stack&lt;int&gt; st;    heights.push_back(0);  // 哨兵，这是为了保证最后一个元素也能出栈    int maxArea = 0;      for (int i = 0; i &lt; heights.size(); i++) &#123;        while (!st.empty() &amp;&amp; heights[i] &lt; heights[st.top()]) &#123;            int h = heights[st.top()];            st.pop();            int w = st.empty() ? i : i - st.top() - 1;            maxArea = max(maxArea, h * w);        &#125;        st.push(i);    &#125;    return maxArea;&#125;

例3：接雨水int trap(vector&lt;int&gt;&amp; height) &#123;    stack&lt;int&gt; st;    int water = 0;      for (int i = 0; i &lt; height.size(); i++) &#123;        while (!st.empty() &amp;&amp; height[i] &gt; height[st.top()]) &#123;            int bottom = st.top();            st.pop();            if (st.empty()) break;                      int distance = i - st.top() - 1;            int h = min(height[i], height[st.top()]) - height[bottom];            water += distance * h;        &#125;        st.push(i);    &#125;    return water;&#125;

例4: 最大二叉树TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123;        stack&lt;TreeNode*&gt;st;        for(auto &amp;i: nums)&#123;            TreeNode* cur = new TreeNode(i);            while(!st.empty() &amp;&amp; st.top()-&gt;val&lt;i)&#123;                cur-&gt;left=st.top();                st.pop();            &#125;             if(!st.empty())&#123;                st.top()-&gt;right=cur;            &#125;            st.push(cur);        &#125;        while(st.size()&gt;1)&#123;            st.pop();        &#125;        return st.top();    &#125;

4. 常用技巧技巧1：哨兵在数组末尾加 0 或无穷大，确保所有元素都能出栈：
heights.push_back(0);

技巧2：循环数组遍历两遍模拟循环：
for (int i = 0; i &lt; 2 * n; i++) &#123;    // 使用 nums[i % n]    if (i &lt; n) st.push(i);  // 只在第一轮入栈&#125;

技巧3：存储下标 vs 存储值
需要计算距离&#x2F;面积：存储下标
只需要元素值：存储值

5. 解题细节
递增栈还是递减栈？

弹出元素的条件？

弹出时如何处理，进而得到答案？

是否需要哨兵？


]]></content>
      <categories>
        <category>data structure &amp; algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>data structure &amp; algorithm</tag>
        <tag>Monotonic Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>250728-250803 周记 缓存池项目学习</title>
    <url>/2025/08/04/250728-250803-%E5%91%A8%E8%AE%B0-%E7%BC%93%E5%AD%98%E6%B1%A0%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[本周主要跟着代码随想录学习了LRU, LFU, 以及ARC三种缓存替换算法的原理和C++实现。
1. LRULRU是Least Recently Used的缩写，即淘汰最近最少使用的元素。
缓存的实现使用了一个哈希表和一个双向链表。哈希表用于快速查找缓存中的元素，双向链表用于维护缓存中的元素顺序。
每当涉及一个元素的key时，将该元素移动到双向链表的头部。当缓存满时，将双向链表的尾部元素删除。同时将该元素从哈希表中删除。
1.1 改进以上的LRU存在着缓存污染、锁的粒度过大的问题。
缓存污染：当新加进来的一次性的数据很多，导致缓存满时，传统的LRU会直接删除尾部元素。但是，尾部元素可能是热门数据。锁的粒度大：一把大锁锁全局。多线程高并发的访问下，同步等待将是一笔极大的时间开销。
故考虑以下改进：
1.1.1 LRU-KLRU-K在普通的LRU的基础上，新增加了一个小的LRU副缓存。当数据进入时，它会先进入副缓存，并访问计数加一。只有当它的访问计数大于等于K时，才会移出副缓存，进入主缓存。
当主副缓存满时，淘汰机制与普通LRU一致。
这样就可以避免缓存污染的问题。使得大量进入的一次性数据不会挤出热门数据。
1.1.2 LRU-Hash与2024-xv6-labs-2中2.2 Buffer cache的思想一致，既然一个链表配全局大锁效率低，那就把链表分成多个小链表，每个小链表即是一个小的lru缓存，各自配置最大容量，并通过一个哈希表（vector即可）统一管理，每个哈希桶配一个锁。每个新来的元素根据key的哈希值插入对应的小链表中。若容量在这之前已满，则同理删除这个小链表的尾部元素。
2. LFULFU是Least Frequently Used的缩写，即淘汰使用次数最少的元素。
缓存的实现使用了一个记录键-值对&lt;key, value&gt;的哈希表a和一个记录频率-列表对&lt;freq, linklist&gt;的哈希表b。哈希表a用于快速查找缓存中的元素，哈希表b用于根据频率高效地维护缓存中的元素。
每当涉及一个元素的key时，将该元素的频率增加1，并将该元素移动到哈希表b中对应频率的链表头部。移动后若原链表为空则删去。当缓存满时，将哈希表b中频率最低的链表的尾部元素删除。同时将该元素从哈希表a中删除。
2.1 改进普通LFU存在着新来的元素容易被移出（即使是未来的热门数据）、而过时的热门数据很难被移出的问题，而且访问次数若一直增长，可能会导致上溢。
同时与普通LRU一样，存在锁的粒度过大的问题。
改进如下：
2.1.1 最大平均访问次数限制首先设置一个阈值。当数据访问&#x2F;插入发生时，不仅需要记录当前最小访问次数，还需要计算平均访问次数。然后当平均访问次数超过阈值时，就需要对记录的访问次数进行调整。所有的元素的访问次数减去阈值的一半，操作后小于0者设为1。然后更新记录&lt;freq-linklist&gt;的哈希表，将元素插入对应频率的链表中。
这样的方式不仅可以避免访问次数的上溢，还可以加快数据的更新，让旧的热点数据”老化”，缓解挤占未来的热点数据空间的问题。
2.1.2 LFU-Hash同LRU-Hash的思想，分成多个记录&lt;freq-linklist&gt;的小哈希表，每个表即是一个小的lfu缓存，各自配置最大容量，并通过一个哈希表（vector即可）统一管理，每个哈希桶配一个锁。每个新来的元素根据key的哈希值插入对应的小链表中。若容量在这之前已满，则同理删除频率最低的链表的尾部元素。
3. ARCARC是Adaptive Replacement Cache的缩写，即自适应替换缓存。
当访问的数据趋向于访问最近的内容，会更多地命中LRU list；当系统趋向于访问频繁访问的内容时，会更多地命中LFU list。
LRU和LFU各有优劣，而实际应用环境更为复杂，需要将两种混合，取长补短。于是就有了结合LRU和LFU的缓存替换算法，即ARC。
基本思想是，将缓存分成两个部分，一部分是LRU缓存，一部分是LFU缓存，然后每个缓存有一个自己的ghost缓存。
当新数据进入时，先进入LRU list，并访问次数设为一。当再次访问这个数据时，访问次数增加1。当访问次数达到阈值后，LFU list里也插入这个元素。于是，该数据块不仅仅只保存在LRU的缓存目录中，也将保存到LFU中。所以一个最近的热门数据若有更新应该是两个表同时进行的。
这样，那些真正被频繁访问的页面将一直呆在缓存中，不会被冷数据的加入而误淘汰，不经常访问的数据会向链表头部移动，最终被淘汰出去。
当缓存满时，需要淘汰一个元素。淘汰的逻辑与对应的普通LRU和普通LFU一致，只是淘汰出的元素要插入对应的ghost缓存中。ghost缓存的淘汰模式就是简单的FIFO即可。
这样，访问元素在哪一边ghost中找到，就说明那一边的容量小了而对面的容量大了。对面的容量如果不为0则减一，然后这边的容量加一。否则跳过。
]]></content>
      <categories>
        <category>cache</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>projects</tag>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title>250811-250817 周记 linux命令与shell编程学习(1)</title>
    <url>/2025/08/18/250811-250817-%E5%91%A8%E8%AE%B0-linux%E5%91%BD%E4%BB%A4%E4%B8%8Eshell%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-1/</url>
    <content><![CDATA[本周学习了Linux Command Line and Shell Scripting Bible这本书的第一部分到第二部分。这里对一些我自己不熟悉的、我自己觉得比较重要的内容进行记录摘要。
1. 第一部分 linux命令行1.3 bash shell基础命令1.3.5 列出文件和目录1.3.5.3 过滤输出列表
模式匹配: 问号(?)代表任意单个字符; 星号(*)代表零个或多个字符。
方括号代表单个字符位置并给出了该位置上的多个可能的选择。你可以将可能的字符逐一列出,也可以指定字符范围,比如字母范围[a–i]。
还可以使用惊叹号(!)将不需要的内容排除在外。

1.3.6 处理文件1.3.6.2 复制文件
cp 命令可以完成文件和目录从文件系统的一个位置复制到另一个位置的操作。 
cp 命令最基本的用法需要两个参数,即源对象和目标对象:cp source destination。 当参数 source 和 destination 都是文件名时,cp 命令会将源文件复制成一个新的目标文件,并以 destination 命名。新文件在形式上就像全新的文件一样,有新的修改时间。
如果目标文件已经存在,则 cp 命令 可能并不会提醒你这一点。最好加上-i 选项,强制 shell 询问是否需要覆盖已有文件。
cp 命令的-R 选项威力强大。可以用它在单个命令中递归地复制整个目录的内容。
在执行 cp –R 命令之前,目录 NewDocuments 并不存在。它是随着 cp –R 命令被创建的, 整个 Documents 目录中的内容都被复制到其中。注意,新的 NewDocuments 目录中所有的文件都 有对应的新日期。NewDocuments 目录现在已经成了 Documents 目录的完整副本。

1.3.6.3 使用命令行补全
制表键补全允许你在输入文件名 或目录名的时候,按一下制表键,让 shell 帮你将内容补充完整。
使用制表键补全的技巧在于要给 shell 提供足够的文件名信息,使其能够将所需文件名与其 他文件名区分开。

1.3.6.4 链接文件
链接是目录中指 向文件真实位置的占位符。在 Linux 中有两种类型的文件链接: 符号链接，硬链接。
符号链接(也称为软链接)是一个实实在在的文件,该文件指向存放在虚拟目录结构中某个地方的另一个文件。这两个以符号方式链接在一起的文件彼此的内容并不相同。可以类比为windows系统中的快捷方式。
要为一个文件创建符号链接,原始文件必须事先存在。使用 ln -s 命令创建符号链接。ln -s test_file slink_test_file
硬链接创建的是一个独立的虚拟文件,其中包含了原始文件的信息以及位置。但是两者就根本而言是同一个文件。可以理解为“同一文件出现在不同的目录下”。要想创建硬链接,原始文件也必须事先存在,只不过这次使用 ln 命令时不需要再加入额外的选项了:ln test_file hlink_test_file

1.3.6.5 文件重命名
重命名文件称为移动。mv 命令可以将文件和目录移动到另一个位置或是重新命名：mv old new

1.3.6.6 删除文件
rm的-i 选项会询问你是否真的要删除该文件。shell 没有回收站或者垃圾箱这样的东西, 文件一旦被删除,就再也找不回来了。所以在使用 rm 命令时,要养成总是加入-i 选项的好习惯。

1.3.7 管理目录1.3.7.1 创建目录
可以根据需要“批量”地创建目录和子目录。为此,要使用 mkdir 命令的-p 选项, mkdir 命令的-p 选项可以根据需要创建缺失的父目录。

1.3.8 查看文件内容1.3.8.1 查看文件类型
file 命令是一个方便的小工具,能够探测文件的内部并判断文件类型

3.8.2 查看整个文件
cat


cat 命令是显示文本文件中所有数据的得力工具。
-n 选项会给所有的行加上行号
如果只想给有文本的行加上行号,可以用-b 选项


more

less



less实为 more 命令的升级版本
less 命令提供了多个非常实用的特性,能 够实现在文本文件中前后翻动,还有一些高级搜索功能。
less 命令还可以在完成整个文件的读取之前显示文件的内容。

1.3.8.3 查看部分文件
tail 命令


tail 命令会显示文件最后几行的内容(文件的“尾部”)。在默认情况下,它会显示文件的 末尾 10 行。
可以向 tail 命令中加入-n 选项来修改所显示的行数，如通过加入-n 2, 使得 tail 命令只显示文件的最后两行
tail 命令有一个非常酷的特性:-f 选项,该选项允许你在其他进程使用此文件时查看文件 的内容。tail 命令会保持活动状态并持续地显示添加到文件中的内容。这是实时监测系统日志 的绝佳方式。


head 命令


head 命令会显示文件开头若干行(文件的“头部”)。在默认情况下,它会显示文件前 10 行的文本
head 命令也支持-n 选项
这两个命令也允 许简单地在连字符后面直接输入想要显示的行数

1.4 更多的 bash shell 命令1.4.1 监测程序1.4.1.1 探查进程
ps 命令默认只显示运行在当前终端中属于当前用户的那些进程。
ps 命令的基本输出显示了程序的进程 ID(process ID,PID)、进程运行在哪个终端(TTY) 及其占用的 CPU 时间。
如果需要查看系统中运行的所有进程,可以使用-ef 选项组合。-e 选项指定显示系统中运行的所有进程;-f 选项则扩充输出内容以显示一些有用的信息列：




列名
说明



UID
启动该进程的用户


PID
进程 ID


PPID
父进程的 PID(如果该进程是由另一个进程启动的)


C
进程生命期中的 CPU 利用率


STIME
进程启动时的系统时间


TTY
进程是从哪个终端设备启动的


TIME
运行进程的累计 CPU 时间


CMD
启动的程序名称



如果还想获得更多的信息, 可以使用-l 选项,产生长格式输出。多出的那几列：




列名
说明



F
内核分配给进程的系统标志


S
进程的状态:O - 正在运行S - 休眠R - 可运行,正等待运行Z - 僵化,已终止但找不到其父进程T - 停止


PRI
进程的优先级(数字越大,优先级越低)


NI
谦让度(nice),用于决定优先级


ADDR
进程的内存地址


SZ
进程被换出时所需交换空间的大致大小


WCHAN
进程休眠的内核函数地址



–forest 选项着实讨人喜欢。该选项能够使用 ASCII 字符来绘制可爱的图表以显示进程的层级信息

1.4.1.2 实时监测进程
top 命令也可以显示进程信息,但采用的是实时方式
在默认情况下,top 命令在启动时会按照%CPU 值来对进程进行排序

1.4.1.3 结束进程
在 Linux 中,进程之间通过信号来通信。




信号
名称
描述



1
HUP
挂起


2
INT
中断


3
QUIT
结束运行


9
KILL
无条件终止


11
SEGV
段错误


15
TERM
尽可能终止


17
STOP
无条件停止运行,但不终止


18
TSTP
停止或暂停,但继续在后台运行


19
CONT
在 STOP 或 TSTP 之后恢复执行



在 Linux 中有两个命令可以向运行中的进程发出进程信号:kill 和 pkill。


kill


kill 命令可以通过 PID 向进程发送信号, 遗憾的是,你只能使用进程的 PID 而不能使用其对应的程序名
不服管教的进程通常会忽略这个请求。如果要强制终止, 则-s 选项支持指定其他信号(用信号名或信号值)。kill -9 PID


pkill


pkill 命令可以使用程序名代替 PID 来终止进程,除此之外,pkill 命令 也允许使用通配符

1.4.2 监测磁盘空间1.4.2.1 挂载存储设备
Linux 文件系统会将所有的磁盘都并入单个虚拟目录。在使用新的存储设备之前,需要将其放在虚拟目录中。这项工作称为挂载(mounting)。
实际的物理存储设备通过驱动被抽象成 &#x2F;dev&#x2F;xxx 设备文件，用户不能直接用目录树访问它们。必须把它们挂载到虚拟文件系统（VFS）的某个挂载点之后，才能以统一的方式访问和管理。


mount


用于挂载存储设备的命令叫作 mount。在默认情况下,mount 命令会输出当前系统已挂载 的设备列表。
如果知道设备分区使用的文件系统类型,可以使用-t &lt;fs-type&gt;过滤输出。
mount 命令提供了 4 部分信息: 设备文件名, 设备在虚拟目录中的挂载点, 文件系统类型, 已挂载设备的访问状态
手动挂载设备的基本命令: mount -t type device directory, type 参数指定了磁盘格式化所使用的文件系统类型。示例： mount -t vfat /dev/sdb1 /media/disk
-o 选项允许在挂载文件系统时添加一系列以逗号分隔的额外选项, 如:




选项
说明



ro
以只读形式挂载


rw
以读写形式挂载


user
允许普通用户挂载该文件系统


check&#x3D;none
挂载文件系统时不执行完整性校验


loop
挂载文件



umount


移除可移动设备时,不能直接将设备拔下,应该先卸载。
umount 命令的格式非常简单:  umount [directory | device ]

1.4.2.2 使用 df 命令
有时需要知道在某台设备上还有多少磁盘空间。df 命令可以方便地查看所有已挂载磁盘的使用情况
df 命令会输出内核挂载的所有虚拟文件系统,因此可以使用-t 选项来指定文件系统类型
该命令的输出: 设备文件位置, 包含多少以 1024 字节为单位的块, 使用了多少以 1024 字节为单位的块, 还有多少以 1024 字节为单位的块可用, 已用空间所占的百分比, 设备挂载点
常用选项之一是-h,该选项会以人类易读(humanreadable)的形式显示磁盘空间,通常用 M 来替代兆字节,用 G 来替代吉字节

1.4.2.3 使用 du 命令
du 命令可以显示某个特定目录(默认情况下是当前 目录)的磁盘使用情况。
下面这些选项能让 du 命令的输出更加清晰易读。
-c:显示所有已列出文件的总大小。
-h:按人类易读格式输出大小,分别用 K 表示千字节、M 表示兆字节、G 表示吉字节。
-s:输出每个参数的汇总信息。



1.4.3 处理数据文件1.4.3.1 数据排序
处理大量数据时的一个常用命令是 sort。这是用来对数据进行排序的命令。
在默认情况下, sort 命令会依据字典序来对文本文件中的数据行进行排序。
使用-n 选项告诉 sort 命令将数字按值排序
加入-M 选项,那么 sort 命令就能识别三字符的月份名并正确排序
-r –reverse 逆序排序(升序变成降序)
-c –check 不排序,但检查输入数据是否有序,无序的话就报告
-u –unique 和-c 选项合用时,检查严格排序;不和-c 选项合用时,相同行仅输出一次
在对按字段分隔的数据进行排序时,-k 选项和-t 选项非常方便。 先使用-t 选项指定字段分隔符,然后使用-k 选项指定排序字段(从1开始)。示例：sort -t &#39;:&#39; -k 3 -n /etc/passwd

1.4.3.2 数据搜索
grep [options] pattern [file]
如果要进行反向搜索(输出不匹配指定模式的行),可以使用-v 选项
如果要显示匹配指定模式的那些行的行号,可以使用-n 选项
如果只想知道有多少行含有匹配的模式,可以使用-c 选项

1.4.3.3 数据压缩
gzip 命令会压缩命令行中指定的文件。也可以指定多个文件名或是用通配符来一次性压缩多个文件，压缩后的文件会在原文件名后面添加 .gz 扩展名。
要解压缩文件,可以使用 gunzip 命令,或者使用 gzcat 命令来查看压缩文件的内容。

1.4.3.4 数据归档
gzip 命令只能压缩文件，要压缩一个文件夹，需要先归档。

归档工具是 tar 命令tar function [options] object1 object2 ...

常用function: -c –create 创建新的 tar 归档文件 -t –list 列出 tar 归档文件的内容

常用option: -f file 将结果输出到文件(或设备) 

tar -cf test.tar test/ test2/该命令创建了一个名为 test.tar 的归档文件, 包含目录 test 和 test2 的内容。

tar -tf test.tar 该命令列出了(但不提取)tar 文件 test.tar 的内容。

tar -xvf test.tar 该命令从 tar 文件 test.tar 中提取内容。如果创建的时候 tar 文件含有目录结构,则在当前目录中重建该目录的整个结构。

在下载开源软件时经常会看到文件名以.tgz 结尾,这是经 gzip 压缩过的 tar 文件,可以用 tar -zxvf filename.tgz 来提取其中的内容。

tar 命令的操作





操作
长选项
描 述



-A
–concatenate
将一个 tar 归档文件追加到另一个 tar 归档文件末尾


-c
–create
创建新的 tar 归档文件


-d
–diff
检查归档文件和文件系统的不同之处



–delete
从 tar 归档文件中删除文件


-r
–append
将文件追加到 tar 归档文件末尾


-t
–list
列出 tar 归档文件的内容


-u
–update
将比 tar 归档文件中已有的同名文件更新的文件追加到该归档文件


-x
–extract
从 tar 归档文件中提取文件



tar 命令选项




选项
描述



-C dir
切换到指定目录


-f file
将结果输出到文件(或设备)


-j
将输出传给 bzip2 命令进行压缩


-J
将输出传给 xz 命令进行压缩


-p
保留文件的所有权限


-v
在处理文件时显示文件名


-z
将输出传给 gzip 命令进行压缩


-Z
将输出传给 compress 命令进行压缩


1.5 理解 shell1.5.3 理解外部命令和内建命令1.5.3.2 内建命令
使用命令别名


alias 命令是另一个实用的 shell 内建命令。命令别名允许为常用命令及其参数创建另一个名称,从而将输入量减少到最低。alias alias-name=origin
因为命令别名属于 内建命令,所以别名仅在其被定义的 shell 进程中才有效。

1.6 Linux 环境变量1.6.1 什么是环境变量
bash shell 中有两种环境变量: 全局变量, 局部变量。

1.6.1.1 全局环境变量
全局环境变量对于 shell 会话和所有生成的子 shell 都是可见的。局部环境变量则只对创建它 的 shell 可见。
可以使用 env 命令或 printenv 命令来查看全局变量
使用 echo 命令显示某个变量的值。在引用某个环境变量时,必须在该变量名前加上美元 符号($)

1.6.2 设置用户自定义变量1.6.2.1 设置局部用户自定义变量
使用等号为变量赋值,值可以是数值或字符串 my_variable=Hello
如果用于赋值的字符串包含空格,则必须用单引号或双引号来界定该字符串的起止
在变量名、等号和值之间没有空格。如果在赋值表达式中加上了空 格,那么 bash shell 会将值视为单独的命令

1.6.2.2 设置全局环境变量
export my_variable=value

1.6.3 删除环境变量
删除已有的环境变量。可以用 unset 命令来完成这 个操作。在 unset 命令中引用环境变量时,记住不要使用$。
如果要用到(doing anything with)变量,就使用$;如果要操作(doing anything to)变量,则不使用$。
对于 PATH 变量的修改只能持续到退出或重启系统。这种效果并不能一直奏效。

1.6.6 定位系统环境变量
当你登录 Linux 系统启动 bash shell 时,默认情况下 bash 会在几个文件中查找命令。这些文件 称作启动文件或环境文件。

1.6.6.1 登录 shell
登录 shell 通常会从 5 个不同的启 动文件中读取命令。  
&#x2F;etc&#x2F;profile  
$HOME&#x2F;.bash_profile  
$HOME&#x2F;.bashrc  
$HOME&#x2F;.bash_login  
$HOME&#x2F;.profile


&#x2F;etc&#x2F;profile 文件是系统中默认的 bash shell 的主启动文件。系统中的每个用户登录时都会执行这个启动文件。
其余的启动文件都用于同一个目的:提供用户专属的启动文件来定义该用户所用到的环境 变量。大多数 Linux 发行版只用这 4 个启动文件中的一两个。
在大多数发行版中,保存个人用户永久性 bash shell 变量的最佳地点是$HOME&#x2F;.bashrc 文件。
可以把个人的 alias 设置放在$HOME&#x2F;.bashrc 启动文件中,使其效果永久化。

1.7 理解 Linux 文件权限1.7.3 理解文件权限
1.7.3.2 默认文件权限
使用3位8进制数来表示权限。




权限
二进制值
八进制值
描述



—
000
0
没有任何权限


–x
001
1
只有执行权限


-w-
010
2
只有写入权限


-wx
011
3
有写入和执行权限


r–
100
4
只有读取权限


r-x
101
5
有读取和执行权限


rw-
110
6
有读取和写入权限


rwx
111
7
有全部权限(读取、写入和执行)



umask 命令用来设置新建文件和目录 的默认权限
umask 值只是个掩码, 把 umask 值从对象的全权限值(full permission)中减掉。对文件而言,全权限值是 666 (所有用户都有读取和写入的权限);对目录而言,全权限值则是 777(所有用户都有读取、写入 和执行权限), 结果就是新建的文件或目录的权限。
文件不能直接执行。新建文件是普通数据（文本、配置、源码等），不是程序。因此全权限为666
必须要有 x 权限才能进入目录，否则你即使有 r 也只能列出文件名，看不到内容。

1.7.4 更改安全设置1.7.4.1 修改权限
chmod 命令可以修改文件和目录的安全设置。chmod options mode file
mode 参数允许使用八进制模式（推荐）或符号模式来进行安全设置。

1.9 安装软件1.9.1 软件包管理基础
软件包存储在称为仓库(repository)的服务器上,可以利用本地 Linux 系统中的软件包管理 器通过 Internet 访问,在其中搜索新的软件包,或是更新系统中已安装的软件包。

1.9.2 基于 Debian 的系统
apt [options] command

1.9.2.1 使用 apt 管理软件包
apt list 命 令会显示仓库中所有可用的软件包,如果再加入–installed 选项,就可以限制仅输出那些已安装在系统中的软件包
如果已经知道系统中的某个软件包,希望显示其详细信息,可以使用 show 命令来操作: apt show package_name
apt show 命令并不会指明软件包是否已经安装。它只根据软件仓库显示该软件包的详细信息。

1.9.2.2 使用 apt 安装软件包
查找特定的软件包: apt search package_name 
search 命令的妙处在于不需要在 package_name 周围添加通配符,直接就有通配符的效果。
如果只想搜索软件包名称,可以加入–name-only 选项。
安装：apt install package_name 
可以使用 list 命令的–installed 选项检查安装是否正确。如果在输出中看到了软件包, 那么说明已经安装好了。

1.9.2.3 使用 apt 升级软件
upgrade 命令可以使用仓库中的任何新版本安全地升级系统中所有的软件包:  apt upgrade
upgrade 命令在升级过程中不会删除任何软件包。如果必须删除某个软件包才能完成升级, 可以使用以下命令:  apt full-upgrade

1.9.2.4 使用 apt 卸载软件包
apt 的 remove 命令可以删除软件包,同时保留数据和配置文件。如果要将软件包以及相关 的数据和配置文件全部删除,那么需要使用 purge 命令
如果确定有依赖关系的软件包不会再有他用,可以使用 autoremove 命令将其删除

1.9.4 使用容器管理软件
云计算带来了应用程序打包方式的一种新范式:应用程序容器(application container)。应用 程序容器创建了一个环境,其中包含了应用程序运行所需的全部文件,包括运行时库文件。开发 人员随后可以将应用程序容器作为单个软件包分发,保证能够在任何 Linux 系统中正常运行。

1.9.4.1 使用 snap 容器
使用 snap 命令行工具查询 snap 数据库,显示已安装的 snap 包,以及安装、升级和删除 snap 包。
snap list 命令查看当前已安装的 snap 应用程序列表
snap find 命令可以在 snap 仓库中搜索指定程序
snap info 命令可以查看 snap 应用程序(简称为 snap)的详细信息
snap install 命令可以安装新的 snap
如果需要删除某个 snap,使用 snap remove 命令即可
Snap vs APT 的区别




特性
APT (Deb 包)
Snap 包



软件形式
.deb 包
.snap 包


依赖管理
使用系统库，依赖需要由 APT 解决
自带依赖，几乎无需外部依赖


安装来源
Debian&#x2F;Ubuntu 官方仓库 或 PPA
Snap Store（集中式）


升级机制
由系统包管理器统一升级
Snapd 后台自动滚动更新


运行环境
与系统环境强耦合
运行在容器化沙盒中


体积大小
通常较小（共用系统库）
较大（自带依赖）


安全性
依赖系统级安全机制
自带沙盒隔离，更细粒度权限控制


启动速度
快，直接使用系统库
稍慢，需通过 snapd 启动环境


典型应用
系统级工具、传统软件
桌面应用、跨发行版的程序


TO BE CONTINUED
]]></content>
      <categories>
        <category>Linux Command Line and Shell Scripting Bible</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>reading note</tag>
        <tag>linux</tag>
        <tag>Linux Command Line and Shell Scripting Bible</tag>
      </tags>
  </entry>
  <entry>
    <title>250811-250817 周记 linux命令与shell编程学习(2)</title>
    <url>/2025/08/19/250811-250817-%E5%91%A8%E8%AE%B0-linux%E5%91%BD%E4%BB%A4%E4%B8%8Eshell%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-2/</url>
    <content><![CDATA[2. 第二部分 shell 脚本编程基础2.11 构建基础脚本2.11.2 创建 shell 脚本文件
其中输入命令。 在创建 shell 脚本文件时,必须在文件的第一行指定要使用的 shell,格式如下:  #!&#x2F;bin&#x2F;bash  在普通的 shell 脚本中,#用作注释行。shell 并不会处理 shell 脚本中的注释行。然而,shell 脚本文件的第一行是个例外,#后面的惊叹号会告诉 shell 用哪个 shell 来运行脚本。(是的,可以使用 bash shell,然后使用另一个 shell 来运行你的脚本。)
通过 chmod 命令(参见第 7 章)赋予文件属主执行文件的权限后，就可以直接./script.sh来运行脚本了。

2.11.3 显示消息
如果在 echo 命令后面加上字符串,那么 echo 命令就会显示出这个字符串
echo输出默认句末带一个换行符\n,可以使用-n选项取消换行符

2.11.4 使用变量2.11.4.1 环境变量
反斜线允许 shell 脚本按照字面意义解释$,而不是引用变量
通过${variable}形式引用的变量。花括号通常用于帮助界定$后的变量名。

2.11.4.2 用户自定义变量
使用等号为变量赋值。在变量、等号和值之间不能出现空格
shell 脚本会以字符串形式存储所有的变量值,脚本中的各个命令可以自行决定变量值的数据类型。
shell 脚本中定义的变量在脚本的整个生命周期里会一直保持着它们的值,在脚本结束时会被删除。
引用变量值时要加$,对变量赋值时则不用加$

2.11.4.3 命令替换
将命令输出赋给变量: var=$(command)或者: var=`command` 注意,赋值号和命令替换 符之间没有空格

2.11.5 重定向输入和输出2.11.5.1 输出重定向
最基本的重定向会将命令的输出发送至文件。bash shell 使用“&gt;”来实现该操作
将命令输出追加到已有文件中：&gt;&gt;

2.11.5.2 输入重定向
输入重定向会将文件的内容作为命令的输入。使用“&lt;”来实现该操作 command &lt; inputfile
一种简单的记忆方法是,在命令行中,命令总是在左侧,而重定向运算符“指向”数据流动的方向。小于号说明数据正在从输入文件流向命令。
还有另外一种输入重定向的方法,称为内联输入重定向。这种方法 无须使用文件进行重定向,只需在命令行中指定用于输入重定向的数据即可。
内联输入重定向的格式如下: command &lt;&lt; delimiter
其中,delimiter 是一个用户定义的字符串,用于标识输入重定向的结束。
内联输入重定向的工作原理是,shell 会将命令行中所有位于 delimiter 之前的文本作为命令的输入。例如：



$ wc &lt;&lt; EOF &gt; test string 1 &gt; test string 2 &gt; test string 3 &gt; EOF 


因此可以在脚本中像这样用：

cat &gt;&gt; $outfile &lt;&lt; EOF INSERT INTO members (lname,fname,address,city,state,zip) VALUES (&#x27;$lname&#x27;, &#x27;$fname&#x27;, &#x27;$address&#x27;, &#x27;$city&#x27;, &#x27;$state&#x27;, &#x27;$zip&#x27;); EOF


快速地根据csv文件生成sql语句

2.11.6 管道
将一个命令的输出作为另一个命令的输入 command1 | command2
实际上,Linux 系统会同时运行这两个命令, 在系统内部将二者连接起来。当第一个命令产生输出时,它会被立即传给第二个命令。数据传输 不会用到任何中间文件或缓冲区。
管道可以串联的命令数量没有限制。可以持续地将命令输出通过管道传给其他命令来细化操作。


2.11.7 执行数学运算2.11.7.2 使用括号
要将数学运算结果赋给变量,使用var=$((expression))
bash shell 的数学运算符只支持整数运算, z shell(zsh)提供了完整的浮点数操作。

2.11.8 退出脚本2.11.8.1 查看退出状态码
Linux 提供了专门的变量$?来保存最后一个已执行命令的退出状态码。
按照惯例,对于成功结束的命令,其退出状态码是 0。对于因错误而结束的命令,其退出状态码是一个正整数。

2.1.8.2 exit 命令
exit 命令允许在脚本结束时指定一个退出状态码
退出状态码必须是 0 到 255 之间的整数。如果指定了超出这个范围的值,则会自动对256取模。

2.12 结构化命令2.12.1 使用 if-then 语句if command; then    commandsfi

2.12.2 if-then-elseif command; then    commandselse    commandsfi

2.12.3 if-then-elif-elseif command; then    commandselif command; then    commands(省略可能的多个elif语句)else    commandsfi

2.12.4 test 命令
bash shell 提供了另一种条件测试方式:

if [ condition ]; then    commandsfi


第一个方括号之后和第二个方括号之前必须留有空格

2.12.4.1 数值比较


比较
描述



n1 -eq n2
检查 n1 是否等于 n2


n1 -ge n2
检查 n1 是否大于或等于 n2


n1 -gt n2
检查 n1 是否大于 n2


n1 -le n2
检查 n1 是否小于或等于 n2


n1 -lt n2
检查 n1 是否小于 n2


n1 -ne n2
检查 n1 是否不等于 n2


2.12.4.2 字符串比较


比较
描述



-z string
检查字符串是否为空


-n string
检查字符串是否不为空


string1 &#x3D; string2
检查字符串是否相等


string1 !&#x3D; string2
检查字符串是否不相等


string1 &lt; string2
检查字符串是否小于 string2


string1 &gt; string2
检查字符串是否大于 string2



测试表达式使用标准的数学比较符号来表示字符串比较,而用文本代码来表示数值比较。

2.12.4.3 文件比较


比较
描述



-e filename
检查文件是否存在


-f filename
检查文件是否存在且是一个普通文件


-d filename
检查文件是否存在且是一个目录


-r filename
检查文件是否存在且可读


-w filename
检查文件是否存在且可写


-x filename
检查文件是否存在且可执行


-s filename
检查文件是否存在且非空


filename1 -nt filename2
检查 filename1 是否比 filename2 新


filename1 -ot filename2
检查 filename1 是否比 filename2 旧


2.12.5 复合条件测试
if-then 语句允许使用布尔逻辑将测试条件组合起来。可以使用以下两种布尔运算符：
[ condition1 ] &amp;&amp; [ condition2 ] 
[ condition1 ] || [ condition2 ]



2.12.6 if-then 的高级特性2.12.6.1 使用单括号if (command); then    commandsfi


单括号中的命令会在子 shell 中执行,而不是在当前 shell 中执行。
单括号中的命令可以使用分号分隔多个命令。
单括号中的命令可以使用反引号或美元符号引用变量。

2.12.6.2 使用双括号if ((expression)); then    commandsfi


双括号中的表达式可以使用的运算符：




符号
描述



val++
后增


val–
后减


++val
先增


–val
先减


!
逻辑求反


~
位求反


**
幂运算


&lt;&lt;
左位移


&gt;&gt;
右位移


&amp;
位布尔 AND


|
位布尔 OR


&amp;&amp;
逻辑 AND


||
逻辑 OR



双括号命令既可以在 if 语句中使用,也可以在脚本中的普通命令里用来赋值
双括号中表达式的大于号和小于号不用转义。这是双括号命令又一个优越性的体现。

2.12.6.3 使用双方括号
双方括号命令提供了针对字符串比较的高级特性

if [[ expression ]]; then    commandsfi

提供了 test 命令所不具备的另一个特性——模式匹配。
双等号(&#x3D;&#x3D;)会将右侧的字符串视为一个模式并应用模式匹配规则。

2.12.7 case 命令
有了 case 命令,就无须再写大量的 elif 语句来检查同一个变量的值了。case 命令会采 用列表格式来检查变量的多个值:

case variable in    pattern1)        commands        ;;    pattern2)        commands        ;;    *)        commands        ;;esac

2.13 更多的结构化命令2.13.1 for 命令for variable in list; do    commandsdone

2.13.1.2 读取列表中的复杂值
for 循环假定各个值之间是 以空格分隔的。如果某个值含有空格, 则必须将其放入双引号内。

2.13.1.5 更改字段分隔符
IFS 环境变量定义了 bash shell 用作字段分隔符的一系列字符。在默认情况下,bash shell 会将下列字符视为字段分隔符。
空格
制表符
换行符


修改 IFS 环境变量可以改变 bash shell 用作字段分隔符的字符。修改 IFS 的值,使其只能识别换行符: IFS=$&#39;\n&#39;


在 Bash 里，$’…’ 是 ANSI-C 风格的字符串，会识别 C 语言风格的转义符$’\n’ → 真正的换行符$’\t’ → 制表符（Tab）$’\x41’ → 字符 A


在处理代码量较大的脚本时,可能在一个地方需要修改 IFS 的值,然后再将其恢复原状,而脚本的其他地方则继续沿用 IFS 的默认值。一种安全的做法是在修改 IFS 之前保存原来的 IFS 值,之后再恢复它。这种技术可以像下面这样来实现:IFS.OLD=$IFS IFS=$&#39;\n&#39;&lt;在代码中使用新的 IFS 值&gt;IFS=$IFS.OLD这就保证了在脚本的后续操作中使用的是 IFS 的默认值。

2.13.1.6 使用通配符读取目录
用 for 命令来自动遍历目录中的文件。
在文件名或路径名中使用 通配符,这会强制 shell 使用文件名通配符匹配(file globbing)。

for file in /path/*; do    commandsdone


在 Linux 中,目录名和文件名中包含空格是完全合法的。要应对这种情况,应该将$file 变 量放入双引号内。否则,遇到含有空格的目录名或文件名时会产生错误


可以在 for 命令中列出多个目录通配符

for file in /path/* /path2/*; do    commandsdone

2.13.2 C 语言风格的 for 命令
bash 中仿 C 语言的 for 循环的基本格式如下:  for (( variable assignment ; condition ; iteration process )); do    commandsdone

2.13.3 while 命令2.13.3.1 while 的基本格式while [ condition ]; do    commandsdone

2.13.7 循环控制2.13.7.1 break 命令for var in list; do    commands    if [ condition ]; then        break    fidone

2.13.7.2 continue 命令for var in list; do    commands    if [ condition ]; then        continue    fidone

2.13.8 处理循环的输出
对循环的输出使用管道或进行重定向。通过在 done 命令之后 添加一个处理命令来实现

for var in list; do    commandsdone &gt; output.txt


“|”以及”&lt;”都可以像这样用

2.14 处理用户输入2.14.1 传递参数2.14.1.1 读取参数
bash shell 会将所有的命令行参数都指派给称作位置参数(positional parameter)的特殊变量。 这也包括 shell 脚本名称。
位置变量的名称都是标准数字:$0 对应脚本名,$1 对应第一个命令行参数,$2 对应第二个命令行参数,以此类推。

2.14.1.2 读取脚本名
basename 命令可以返回不包含路径的脚本名

2.14.2 特殊参数变量2.14.2.1 参数统计
$#含有脚本运行时携带的命令行参数的个数，不包含脚本名。
$&#123;!#&#125; 代表了最后一个位置变量

2.14.2.2 获取所有的数据
$*变量和$@变量可以轻松访问所有参数,它们各自包含了所有的命令行参数
$*变量会将所有的命令行参数视为一个单词。这个单词含有命令行中出现的每一个参数。 基本上,$*变量会将这些参数视为一个整体,而不是一系列个体。
$@变量会将所有的命令行参数视为同一字符串中的多个独立的单词,以便你能遍历并处理全部参数。这通常使用 for 命令完成。

2.14.3 移动参数
shift 命令会将所有的位置参数向左移动。每个位置参数的变量名都会减 1。$1 会变成$0,$2 会变成$1,以此类推。被删除的参数会被丢弃。
shift 命令可以接受一个可选的参数,用于指定要左移几位。默认情况下,它会将所有的位置参数向左移动一个位置。

2.14.4.3 使用 getopts 命令
getopts optstring variable
getopts 命令要用到两个环境变量。如果选项需要加带参数值,那么 OPTARG 环境变量保存的就是这个值。OPTIND 环境变量保存着参数列表中 getopts 正在处理的参数位置。这样在处理完当前选项之后就能继续处理其他命令行参数了。使用举例：

while getopts :ab: opt; do    case $opt in        a)            echo &quot;Option a&quot; ;;        b)            echo &quot;Option b with value $OPTARG&quot; ;;        \?)            echo &quot;Invalid option: -$opt&quot; ;;    esacdone


在解析命令行选项时,getopts 命令会移 除起始的连字符,所以在 case 语句中不用连字符。
选项字符串中的冒号(:)表示该选项需要一个参数值。

2.14.6 获取用户输入2.14.6.1 基本的读取
read 命令从标准输入(键盘)或另一个文件描述符中接受输入。获取输入后,read 命令会 将数据存入变量。read variable
read 命令也提供了-p 选项,允许直接指定提示符:read -p &quot;Enter your name: &quot; name

2.14.6.2 超时
用-t 选项来指定一个计时器。-t 选项会指定 read 命令等待输入的 秒数。如果计时器超时,则 read 命令会返回非 0 退出状态码
用-n 选项来指定 read 命令读取的字符数，read会在接收到设定个数的字符后自动退出。

2.14.6.3 无显示读取
-s 选项可以避免在 read 命令中输入的数据出现在屏幕上(其实数据还是会被显示,只不 过 read 命令将文本颜色设成了跟背景色一样)

2.14.6.4 从文件中读取
每次调用 read 命令都会从指定文件中读取一行文本。 当文件中没有内容可读时,read 命令会退出并返回非 0 退出状态码。

while read line; do    echo $linedone &lt; input.txt

2.15 呈现数据2.15.1 理解输入和输出


文件描述符
缩写
描述



0
STDIN
标准输入


1
STDOUT
标准输出


2
STDERR
标准错误



shell 对于错误消息的处理是跟普通输出分开的。只使用“&gt;”重定向只能重定向标准输出,而不能重定向标准错误。
在默认情况下,STDERR 和 STDOUT 指向同一个地方————显示器。

2.15.1.2 重定向错误
只重定向错误


command 2&gt; &amp;1 2与“&gt;”必须紧挨着,否则无法正常工作


重定向错误消息和正常输出


如果想重定向错误消息和正常输出,则必须使用两个重定向符号。你需要在重定向符号之前 放上需要重定向的文件描述符,然后让它们指向用于保存数据的输出文件
将 STDERR 和 STDOUT 的输出重定向到同一个文件：&amp;&gt;

2.15.2 在脚本中重定向输出
有意在脚本中生成错误消息,可以将单独的一行输出重定向到 STDERR: &gt;&amp;2 
在重定向到文件描述符时,必须在文件 描述符索引值之前加一个&amp;
可以理解为：0、1、2为文件描述符，而&amp;1、&amp;2、&amp;3为文件描述符所指代的具体的文件&#x2F;设备名。

2.15.2.2 永久重定向
exec 命令会告诉 shell 在脚本执行期间重定向某个特定文件描述符: exec 1&gt; output.txt。还可以用来创建新的文件描述符。exec 3&gt; testfile

2.15.3 在脚本中重定向输入
exec 命令允许将 STDIN 重定向为文件: exec 0&lt; input.txt
只要脚本需要输入, 这个重定向就会起作用：

exec 0&lt; testfile count=1  while read line; do     echo &quot;Line #$count: $line&quot;     count=$[ $count + 1 ] done

2.15.4 创建自己的重定向2.15.4.2 重定向文件描述符
恢复已重定向的文件描述符：

exec 3&gt;&amp;1 exec 1&gt;test14out...exec 1&gt;&amp;3# 1恢复


2.15.4.5 关闭文件描述符
要关闭文件描述符,只需将其重定向到特殊符号&amp;-即可: exec 3&gt;&amp;-

2.15.5 列出打开的文件描述符
lsof 命令可以列出当前系统中打开的所有文件描述符。
最常用的选项包括-p 和-d,前者允许指定进程 ID(PID),后者允许指定要显示的文件描述符编号(多个编号之间以逗号分隔)。
$$: 当前进程的 PID
lsof的默认输出：




列
描述



COMMAND
进程对应的命令名的前 9 个字符


PID
进程的 PID


USER
进程属主的登录名


FD
文件描述符编号以及访问类型(r 代表读,w 代表写,u 代表读&#x2F;写)


TYPE
文件的类型(CHR 代表字符型,BLK 代表块型,DIR 代表目录,REG 代表常规文件)


DEVICE
设备号(主设备号和从设备号)


SIZE
如果有的话,表示文件的大小


NODE
本地文件的节点号


NAME
文件名


2.15.6 抑制命令输出
重定向到 &#x2F;dev&#x2F;null 可以抑制命令的输出
也可以在输入重定向中将&#x2F;dev&#x2F;null 作为输入文件，快速清除现有文件中的数据：cat /dev/null &gt; testfile

2.15.7 使用临时文件2.15.7.1 创建本地临时文件
mktemp 会在本地目录中创建一个文件。在使用 mktemp 命令时,只需指定 一个文件名模板即可。模板可以包含任意文本字符,同时在文件名末尾要加上 6 个 X。
mktemp 命令会任意地将 6 个 X 替换为同等数量的字符,以保证文件名在目录中是唯一的。 你可以创建多个临时文件,并确保每个文件名都不重复
mktemp 命令的输出正是它所创建的文件名。

2.15.7.2 在&#x2F;tmp 目录中创建临时文件
-t 选项会强制 mktemp 命令在系统的临时目录中创建文件。在使用这个特性时,mktemp 命令会返回所创建的临时文件的完整路径名,而不只是文件名

2.15.7.3 创建临时目录
-d 选项会告诉 mktemp 命令创建一个临时目录。你可以根据需要使用该目录,比如在其中 创建其他的临时文件

2.15.8 记录消息
tee 命令就像是连接管道的 T 型接头,它能将来自 STDIN 的数据同时送往两处。一处是 STDOUT,另一处是 tee 命令行所指定的文件名（这个文件不需要先前存在）
配合管道命令来重定向命令输出: command | tee testfile
tee 命令的 -a 选项会将输出追加到文件中,而不是覆盖文件内容

2.16 脚本控制2.16.1 处理信号2.16.1.1 重温 Linux 信号


信号值
信号名
描述



1
SIGHUP
挂起(hang up)进程


2
SIGINT
中断(interrupt)进程


3
SIGQUIT
停止(stop)进程


9
SIGKILL
无条件终止(terminate)进程


15
SIGTERM
尽可能终止进程


18
SIGCONT
继续运行停止的进程


19
SIGSTOP
无条件停止,但不终止进程


20
SIGTSTP
停止或暂停(pause),但不终止进程


2.16.2 以后台模式运行脚本2.16.2.1 后台运行脚本
以后台模式运行 shell 脚本非常简单,只需在脚本名后面加上&amp;即可

2.16.3 在非控制台下运行脚本
有时候,即便退出了终端会话,你也想在终端会话中启动 shell 脚本,让脚本一直以后台模 式运行到结束。这可以用 nohup 命令来实现
nohup 命令能阻断发给特定进程的 SIGHUP 信号。当退出终端会话时,这可以避免进程退出
nohup command

2.16.4 作业控制2.16.4.1 查看作业
jobs 是作业控制中的关键命令,该命令允许用户查看 shell 当前正在处理的作业
可以使用 jobs 命令的-l 选项(小写字母 l)查看作业的 PID

2.16.4.2 重启已停止的作业
暂停： ^Z
要以后台模式重启作业,可以使用 bg 命令
如果存在多个作业,则需要在 bg 命令后加上作业号

2.16.6 定时运行作业2.16.6.1 使用 at 命令调度作业
at [-f filename] time。适用于计划运行少数几次。

2.16.6.2 调度需要定期运行的脚本
Linux 系统使用 cron 程序调度需要定期执行的作业。cron 在后台运行,并会检查一个特殊的 表(cron 时间表),从中获知已安排执行的作业
cron 时间表通过一种特别的格式指定作业何时运行,其格式如下:minutepasthour hourofday dayofmonth month dayofweek command
cron 时间表允许使用特定值、取值范围(比如 1-5)或者通配符(*)来指定各个字段。
如果想在每天的 10:15 运行一个命令,可以使用如下 cron 时间表字段: 15 10 * * * command
列出已有的 cron 时间表：crontab -l
向cron 时间表添加字段： crontab -e, 然后添加15 10 * * * command
保存并退出编辑器后, cron 会在指定的时间运行命令

]]></content>
      <categories>
        <category>Linux Command Line and Shell Scripting Bible</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>reading note</tag>
        <tag>linux</tag>
        <tag>Linux Command Line and Shell Scripting Bible</tag>
      </tags>
  </entry>
  <entry>
    <title>250824 thinking Trie</title>
    <url>/2025/08/24/250824-thinking-Trie/</url>
    <content><![CDATA[字典树（Trie）是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。每个节点有26个子节点，子节点的序号分别代表26个字母。因此，从根节点到某个节点的路径表示一个字符串。有时候，每个节点会有一个标记，用于表示是否为一个字符串的结束。如果一个节点的标记为true，那么从根节点到该节点的路径表示的字符串就是一个单词。
C++示例以下是一个简单的C++实现，支持插入、搜索和前缀搜索。
class Node &#123;public:    int end;    vector&lt;unique_ptr&lt;Node&gt;&gt; son;    Node():end(0),son(26)&#123;&#125;;&#125;;class Trie &#123;public:    unique_ptr&lt;Node&gt; root;    Trie() &#123;        root=make_unique&lt;Node&gt;();    &#125;        void insert(string word) &#123;        Node* cur=root.get();        for(auto chr: word)&#123;            if(cur-&gt;son[chr-&#x27;a&#x27;]==nullptr)                cur-&gt;son[chr-&#x27;a&#x27;]=make_unique&lt;Node&gt;();            cur=cur-&gt;son[chr-&#x27;a&#x27;].get();        &#125;        cur-&gt;end=1;    &#125;        bool search(string word) &#123;        Node* cur = root.get();        for (char c : word) &#123;            c -= &#x27;a&#x27;;            if (cur-&gt;son[c] == nullptr) &#123;                 return false;            &#125;            cur = cur-&gt;son[c].get();        &#125;        return cur-&gt;end==1;    &#125;        bool startsWith(string prefix) &#123;        Node* cur = root.get();        for (char c : prefix) &#123;            c -= &#x27;a&#x27;;            if (cur-&gt;son[c] == nullptr) &#123;                 return false;            &#125;            cur = cur-&gt;son[c].get();        &#125;        return true;    &#125;&#125;;
]]></content>
      <categories>
        <category>data structure &amp; algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>data structure &amp; algorithm</tag>
        <tag>string</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>250824 thinking 二叉树遍历的迭代法</title>
    <url>/2025/08/24/250824-thinking-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84%E8%BF%AD%E4%BB%A3%E6%B3%95/</url>
    <content><![CDATA[关于二叉树的遍历，有递归法和迭代法两种。递归法简单易懂，但是迭代法较为复杂，需要使用栈来模拟递归的过程。
这里以“将二叉树按某种顺序遍历输出”为例，介绍迭代法的实现。
关键在于理解某个节点输出的时机。
1. 前序遍历
先输出，再将左子节点入栈。没有左子节点了，才考虑右子节点的入栈。

vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; ans;        stack&lt;TreeNode*&gt; stk;        while(!stk.empty() || root!=nullptr)&#123;            while(root!=nullptr)&#123;                ans.push_back(root-&gt;val);                stk.emplace(root);                root=root-&gt;left;            &#125;            root=stk.top()-&gt;right;            stk.pop();        &#125;        return ans;    &#125;

2. 中序遍历
先将左子节点入栈，没有左子节点了，才输出当前节点，然后考虑右子节点的入栈。

vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; ans;        stack&lt;TreeNode*&gt; stk;        while(!stk.empty() || root!=nullptr)&#123;            while(root!=nullptr)&#123;                stk.emplace(root);                root=root-&gt;left;            &#125;            root=stk.top();            stk.pop();            ans.push_back(root-&gt;val);            root=root-&gt;right;        &#125;        return ans;    &#125;

3. 后序遍历
先将左子节点入栈，没有左子节点了，才考虑右子节点的入栈。如果右子节点也没有了，才输出当前节点。


难点：如何判断当前节点的右子节点是否已经遍历过了？


使用一个指针prev来记录上一个遍历的节点。
如果当前节点的右子节点为空，或者右子节点已经遍历过了，才输出当前节点。
否则，将右子节点入栈，然后考虑左子节点的入栈。

vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; ans;        stack&lt;TreeNode*&gt;stk;        TreeNode* prev=nullptr;        while(!stk.empty()||root!=nullptr)&#123;            while(root!=nullptr)&#123;                stk.emplace(root);                root=root-&gt;left;            &#125;            root=stk.top();            if(root-&gt;right==nullptr || root-&gt;right==prev)&#123;                ans.push_back(root-&gt;val);                prev=root;                stk.pop();                root=nullptr; // 这里很重要！否则会因为root不为空而“入栈-出栈”无限循环            &#125;            else&#123;                root=root-&gt;right;            &#125;        &#125;        return ans;    &#125;

]]></content>
      <categories>
        <category>data structure &amp; algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>data structure &amp; algorithm</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>250824 thinking 单例模式</title>
    <url>/2025/08/24/250824-thinking-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[1. 什么是单例模式？单例模式（Singleton Pattern）是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点来访问该实例。
2. 为什么需要单例模式？在多线程环境下，我们需要多个线程使用同一份资源。
2.1 为什么不使用全局变量？在一些较为简单的环境中，直接使用一些全局变量供所有线程使用是很好的。
但是，如果这个对象是资源密集型的，使用全局变量会导致资源的浪费。而且，简单的全局变量没有提供访问控制（封装），线程可以任意地访问和修改。
而单例模式就可以实现按需创建实例，避免了资源的浪费。而且提供了类封装，确保不会有意外的修改。
3. 单例模式的实现（C++）这其实体现了一种static关键字的妙用。
class Singleton &#123;public:    static Singleton* getInstance() &#123;        static Singleton instance;        return &amp;instance;    &#125;    //...other public interface ...private:    Singleton() &#123;&#125;    //...other members&#125;;//...existing code ...auto instance = Singleton::getInstance();// ... call public interface ...

3.1 线程安全C++11 §6.7 (stmt.dcl) 规定：

If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.

函数作用域内的局部静态变量的初始化是线程安全的。
3.2 懒加载由于static关键字的特性，实例是在第一次调用getInstance()时才创建, 之后的调用都只是返回已有的实例。
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>reading note</tag>
        <tag>Object Oriented Programming</tag>
        <tag>Design Pattern</tag>
        <tag>Singleton Pattern</tag>
        <tag>Head First Design Patterns</tag>
      </tags>
  </entry>
  <entry>
    <title>250824 thinking 埃氏筛</title>
    <url>/2025/08/24/250824-thinking-%E5%9F%83%E6%B0%8F%E7%AD%9B/</url>
    <content><![CDATA[埃氏筛是一种简单的筛法，用于求小于等于n的所有质数。
流程Prime(n):    mark i from 2 to n as prime (initial)    for i from 2 to n:            if i is marked as prime:                for j from i^2 to n with step i:                    mark j as not prime    return all marked primes

解释：
为什么是从$i^2$开始标记非质数？
因为如果一个数不是质数，那么它一定有一个小于等于$\sqrt{n}$的质因子。
所以，我们只需要从$i^2$开始标记，因为小于$i^2$的数，一定已经被小于$i$的数标记过了。



]]></content>
      <categories>
        <category>data structure &amp; algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>data structure &amp; algorithm</tag>
        <tag>mathematics</tag>
        <tag>sieve of Eratosthenes</tag>
      </tags>
  </entry>
  <entry>
    <title>250824 thinking 快速排序</title>
    <url>/2025/08/25/250824-thinking-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[快速排序的Hoare分区法的基本思想与流程是简单明晰的，但是有很多细节需要注意，例如是左指针先动还是右指针先动、指针移动条件等。稍有不慎，就可能甚至导致死循环。
1. 伪代码示例这里是从小到大的顺序排序。
// input: arr, lo, hi// arr: array to be sorted// lo, hi: the area to be sorted is [lo, hi)// output: sorted arrQuickSort(arr, lo, hi):    if lo &gt;= hi:         return // in this case, no element left in the area, no need to sort    pivot := arr[lo]    left := lo    right := hi    while left &lt; right; do        do            right--        while arr[right] &gt; pivot // right pointer moves to the left until it points to an element smaller than pivot or points to pivot, so right pointer is always safe        do            left++        while left &lt; right and arr[left] &lt; pivot // but left pointer could overflow if there is no control, so it should always be checked with left &lt; right        if left &lt; right; then            swap(arr[left], arr[right])        else             break        end if    end while    swap(arr[lo], arr[right])     QuickSort(arr, lo, right)    QuickSort(arr, right + 1, hi)

2. 解释2.1 左右指针移动的顺序为什么是先右后左？考虑一个例子：[1, 3, 4, 5, 7], 以1为基准进行分区。如果先左后右，则左指针在3处就会停下。然后右指针移动，由于左指针挡着，它便只能移动到3这里，而不是正确的位置1。这时候如果交换3和1，则3的位置就被错误地交换了。
2.2 为什么循环退出后交换时将pivot和right进行交换而不是left？因为right指针移动的条件是arr[right] &gt; pivot，也就是说当它不移动时候，一定是arr[right]&lt;=pivot。而left指针移动的条件是left &lt; right &amp;&amp; arr[left] &lt; pivot，当循环退出时，我们不能保证一定有arr[left]&gt;=pivot，因为有可能是left &lt; right条件不满足导致的退出。而pivot所指代的元素在最左边，与右边的一个不大于它的元素交换是安全的。 
2.3 指针移动条件为什么不带”&#x3D;”?这是由left和right的语义所决定的。left是“在pivot的左边”，而right是“在pivot的右边”。
]]></content>
      <categories>
        <category>data structure &amp; algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>data structure &amp; algorithm</tag>
        <tag>quick sort</tag>
        <tag>Hoare partition</tag>
      </tags>
  </entry>
  <entry>
    <title>250824 thinking 状压dp</title>
    <url>/2025/08/24/250824-thinking-%E7%8A%B6%E5%8E%8Bdp/</url>
    <content><![CDATA[状压dp使用二进制数来表示状态，将当前已选元素的集合表示为一个二进制数。适用于需要枚举每一种排列进行判断、且最大的$n$有$10&lt;n&lt;20$的题目。状压dp能使得时间复杂度从暴力搜索的$O(n!)$降到$O(n*2^n)$(相邻无关)或者$O(n^2 * 2^n)$(相邻相关)。
若当前表示已选元素的集合的二进制掩码为mask，则；

mask &amp;(1&lt;&lt;i) : 表示第i个元素是否被选择
mask|(1&lt;&lt;i) : 表示将第i个元素加入集合
popcount(mask) : 表示集合中元素的个数

1. 相邻无关当前位置的选择不依赖于前一个位置的选择，只依赖于当前已选元素的集合。
$dp[mask]$表示状态为mask的情况(即已经选择的集合的二进制掩码为mask)下的最优解。
1.1 例题假设有从 1 到 n 的 n 个整数。用这些整数构造一个数组 perm（下标从 1 开始），只要满足下述条件 之一 ，该数组就是一个 优美的排列 ：

perm[i] 能够被 i 整除
i 能够被 perm[i] 整除
1 &lt;&#x3D; n &lt;&#x3D; 15

给你一个整数 n ，返回可以构造的 优美排列 的 数量 。
int countArrangement(int n) &#123;        vector&lt;int&gt; dp(1 &lt;&lt; n, 0);        dp[0] = 1;        for(int m = 0; m &lt; 1 &lt;&lt; n; ++m) &#123;            int l = popcount((unsigned) m);            ++l;            for(int j = 0; j &lt; n; ++j) &#123;                int p = j + 1;                if(!(m &amp; (1&lt;&lt;j)))&#123;                    if((l % p == 0)||(p % l == 0))&#123;                        dp[m | (1&lt;&lt;j)] += dp[m];                     &#125;                &#125;            &#125;        &#125;        return dp.back();    &#125;

2. 相邻相关当前位置的选择不仅依赖于当前已选元素的集合，还依赖于前一个位置的选择。
$dp[mask][i]$表示状态为mask、前一个位置的选择为i的情况下的最优解。
2.1 例题给你一个下标从 0 开始的整数数组 nums ，它包含 n 个 互不相同 的正整数。如果 nums 的一个排列满足以下条件，我们称它是一个特别的排列：

对于 0 &lt;&#x3D; i &lt; n - 1 的下标 i ，要么 nums[i] % nums[i+1] &#x3D;&#x3D; 0 ，要么 nums[i+1] % nums[i] &#x3D;&#x3D; 0 。
2 &lt;&#x3D; nums.length &lt;&#x3D; 14
1 &lt;&#x3D; nums[i] &lt;&#x3D; 1e9

请你返回特别排列的总数目。由于答案可能很大，请将它对 $10^9 + 7$ 取余后返回。
int specialPerm(vector&lt;int&gt;&amp; nums) &#123;        const int mod = 1e9+7;        int n=nums.size();        vector&lt;vector&lt;int&gt;&gt;dp(1&lt;&lt;n,vector&lt;int&gt;(n,0));        for(int i=0;i&lt;n;++i)&#123;            dp[1&lt;&lt;i][i]=1;        &#125;        for(int m=0;m&lt;1&lt;&lt;n;++m)&#123;            for(int i=0;i&lt;n;++i)&#123;                if(m &amp; (1&lt;&lt;i))&#123;                    for(int j=0;j&lt;n;++j)&#123;                        if(!(m&amp;(1&lt;&lt;j)))&#123;                            if((nums[i]%nums[j]==0)||(nums[j]%nums[i]==0))&#123;                                dp[m|(1&lt;&lt;j)][j]=(dp[m|(1&lt;&lt;j)][j] + dp[m][i])%mod;                            &#125;                        &#125;                    &#125;                &#125;            &#125;        &#125;        int ans=0;        for(int i=0;i&lt;n;++i)&#123;            ans=(ans+dp[(1&lt;&lt;n)-1][i])%mod;        &#125;        return ans;    &#125;]]></content>
      <categories>
        <category>data structure &amp; algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>data structure &amp; algorithm</tag>
        <tag>dynamic programming</tag>
        <tag>state compression</tag>
      </tags>
  </entry>
</search>
