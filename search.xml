<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>250707-250714 周记 2024-xv6-labs(1)</title>
    <url>/2025/07/14/250707-250714-%E5%91%A8%E8%AE%B0-2024-xv6-labs-1/</url>
    <content><![CDATA[本周主要完成了2024-xv6-labs的util到cow的五个实验。
1. util lab1.1 sleep这个算是最简单的实验了。按照hints一步步写即可。没有任何额外需要注意的地方。
1.2 pingpong这个实验的主要难点是理解pipe函数的使用。先查看 sys_pipe函数：
voidsys_pipe(void)&#123;   uint64 fdarray; // user pointer to array of two integers   struct file *rf, *wf;   int fd0, fd1;   struct proc *p = myproc();      argaddr(0, &amp;fdarray);   if(pipealloc(&amp;rf, &amp;wf) &lt; 0)&#123;    ...   &#125;     ...   if((fd0 = fdalloc(rf)) &lt; 0 || (fd1 = fdalloc(wf)) &lt; 0)&#123;    ...   &#125;   if(copyout(p-&gt;pagetable, fdarray, (char*)&amp;fd0, sizeof(fd0)) &lt; 0 ||    copyout(p-&gt;pagetable, fdarray+sizeof(fd0), (char *)&amp;fd1, sizeof(fd1)) &lt; 0)&#123;    ...    &#125;    ...&#125;

再继续查看 pipealloc fdalloc copyout等相关函数的定义。可见，pipe是把两个文件描述符分别传给了fdarray[0]和fdarray[1]，且fdarray[0]只读，fdarray[1]只写。
而本题中，需要父-&gt;子 子-&gt;父两个管道。且对于父进程和子进程都需要读和写，最后代码如下：
int p1[2]; // 父进程-&gt;子进程int p2[2]; // 子进程-&gt;父进程pipe(p1);pipe(p2);char buf;if(pid&gt;0)&#123;    close(p1[0]); // 关闭p1读端    close(p2[1]); // 关闭p2写端    write(p1[1], &quot;a&quot;, 1);    close(p1[1]);    read(p2[0],&amp;buf,1);    close(p2[0]);    wait(0);    fprintf(2, &quot;%d: received pong\n&quot;, getpid());&#125;else&#123;    close(p1[1]);    close(p2[0]);    read(p1[0],&amp;buf,1);    close(p1[0]);    fprintf(2, &quot;%d: received ping\n&quot;, getpid());    write(p2[1],&quot;a&quot;,1);    close(p2[1]);&#125;

1.3 primes这题更为考验 pipe的使用，而且要特别小心，需留意哪些文件描述符不会使用了并把他们都关闭。否则会导致资源耗尽，在大约37的地方输出乱码。
该题提取质数的流程如下：
//Input: file descriptor//Output: void//print the &quot;first&quot; prime in the sequence filtered by last process, and past the  //left sequence to next process recursively.primes(fd) :     if the sequence is empty do:        close(fd);        exit;    print the first number of the sequence;    fork;    pipe;    if is parent proc do:        pass the first number&#x27;s multiples;        write the left numnbers to son proc via pipe;        close(fd);        close(pipe&#x27;s write);        wait;    if is son proc do:        close(fd);        close(pipe&#x27;s write);        primes(pipe&#x27;s read);    exit;

1.4 find实际上，find的写法跟 ls写法几乎相同，对于目录文件而言 ls是打印下面的所有文件，而 find只打印下面名字与第二个参数相同的文件。只是要注意到 find是递归查看目录文件，所以要额外处理”.”和”..”。
1.5 xargs这题的关键是，如何处理 xargs前 |之前的部分的输出。
首先要查明，这些输出是被管道重定向到了 stdin里，而 stdin对应的 fd为0.
然后就是使用read将 stdin里的拼接在原argv后面。注意 &#39; &#39;和 &#39;\n&#39;的情况，前者代表一个参数输入结束，后者不仅代表结束，还需要立即执行一次。
注意在 exec()中，argv末尾需以 0标志。
2. syscall lab2.1 trace这题其实理清流程即可，并不复杂：
将 trace的第一个参数（掩码）给 myproc()保存 ———— 所以 proc结构体需要新添加一个属性 mask来存。然后每当 myproc()执行系统调用时候，检查掩码中对于该系统调用对应的位是否为1（p-&gt;mask&amp;(1&lt;&lt;num)），以此来决定是否打印该系统调用。
2.2 attack这道题。。。。emmmm。。。说实话我现在都没有想通。
这道题思路很明显：既然新分配的内存保留了其先前使用的內容，那么attack也申请内存，在其中的某一页中的32个偏移开始8字节就一定是 secrest。
关键在于：哪一页？
说实话，我真是万策尽矣，无论是打印申请的每一页开头40字节，还是用前缀字符来比较（这个甚至诡异得一塌糊涂：attack申请后那一存着secret的页开头2字节是乱码），都一一失败了😭。
最后是在不得已，去github上找到了参考：申请32页的第16页。
以下是作者的原话：不能理解！这个16是怎么来的？？
（我也不能理解。。。）
3. pgtbl lab第3章是我目前为止xv6中做过的最痛苦的实验了😭,我真花了两三天时间做这个。尤其是最后一个超级块的部分，我搞了约14个小时，才过测试。。。
3.1 ugetpid这个题目的难点。。。在于看不懂题目，找不到该在哪里写什么（bushi）。
但其实也很简单：在用户空间里拿一页空间 USYSCALL存 usyscall，usyscall来存一些东西（这里是 getpid()）proc定义里添加它的地址，allocproc freeproc proc_pagetable proc_freepagetable这些与进程内存分配释放的函数里面也类似地加上处理 USYSCALL的部分即可。
但是有一点要注意：关于 USYSCALL页”user can access but read only”.
3.2 vmprint这个的关键点在于，搞清楚虚拟页和对应的三级页表。

如果PTE叶在0级页表上，则对应的虚拟页相对于初始虚拟页的偏移是在30~38位上；
如果PTE叶在1级页表上，则对应的虚拟页相对于初始虚拟页的偏移是在21~29位上；
如果PTE叶在2级页表上，则对应的虚拟页相对于初始虚拟页的偏移是在12~20位上。

（PTE叶指的是有效的，且不表示下一级页表的pte项）
3.3 super block太困难了！太困难了！😭
我最后甚至也是钻了空子（我留了10个超级块，而测试最多用8个超级块）才过的。
题目的思路很清晰：留几个”super block”使得申请大内存空间时不是给他很多个小页而是给他几个超级块。那么，只要在管理分配页的数据结构中添加超级页并给它们标志，并在处理页的申请释放的函数中类似地加上相应处理逻辑即可。
但是！！！有一些坑！

当地址未对齐时，普通页可以直接 PGROUNDUP对齐。但超级页不能类比！如果直接SUPERPGROUNDUP再分配超级块的话，会导致内存地址空间出现“空隙”，panic(“uvmcopy: page not present”)。所以为了防止这个问题，要先通过分配普通块的方式进行对齐。
超级页必须是在第1级页表上的pte表示，而不是普通页的第0级。因为超级页2MB，普通页4KB，一个第1级页表上的pte表示512个第0级pte————第1级的pte表示2MB。

4. trap lab4.1 backtrace这题也比较简单，照着这个笔记上关于栈帧布局的示意图写代码并打印即可。
4.2 alarm虽是 红 题，但我觉得比 pgtbl那道 蓝 题超级块简单得多。。。
事实上，跟着hints一步步做就好，只是要注意：在进入handler函数时，时钟计数并不会自然停止，我们该在 proc额外设置一个属性来判断当前是否处于handler中。
而且，为了恢复上下文，我们还应该设一个结构体属性作为备份，来存进入handler之前的trapframe的所有内容。
5. cow lab这个实验也挺。。。先是filetest死活过不了，花了我几个小时找bug，然后把bug一改，嘿！您猜怎么着？threetest也过不了了🤣。最后找了两个多小时才找到原来是 kfree这边的问题。
做法其实也是跟着hints一步步来，（注意trap要处理的是  r_scause()==15的情景）只是还是有坑：
由于我把减引用计数的逻辑与kfree写一起的，所以我天真的以为只需要开始减引用计数时和末尾更新 freelist才需要加锁，而中间是不用锁的。然后 kerneltrap给我狠狠上了一课。😂
最后还得别忘了在 usetrap添加处理虚拟地址超出最大值时杀死进程的逻辑，否则 usertests -q过不了。🤣
6. 感谢
MIT的cs6.828以及xv6-labs的设计者们，感谢他们提供如此优质的项目。虽然写的时候很痛苦😂但确实我感到自己对于C语言和操作系统的理解与认识有所深入。
siriusyaoz，在做实验的时候，你的关于这个实验的代码给予了我很多启发🥹。

]]></content>
      <categories>
        <category>2024-xv6-labs</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Projects</tag>
        <tag>Operating System</tag>
        <tag>2024-xv6-labs</tag>
      </tags>
  </entry>
  <entry>
    <title>250714-250720 周记 2024-xv6-labs(2)</title>
    <url>/2025/07/21/250714-250720-%E5%91%A8%E8%AE%B0-2024-xv6-labs-2/</url>
    <content><![CDATA[本周完成了剩下的实验。上一篇见2024-xv6-labs-1
1. net lab1.1 NIC第一个实验是补全e1000_transmit() 和 e1000_recv()
重点在于先要理解e1000初始化的代码，以及e1000_dev.h里给出的各寄存器的定义。
然后理清一下工作流程：transmit所做的，其实就是将发送区和发送环的尾部更新为带发送的数据对应的元数据。注意此时status应为0而不是E1000_TXD_STAT_DD，因为这只是代表将数据填入发送区，并没有真正发送。然后更新E100_TDT的值。但为了防止竞态条件，所以还要注意用e1000_lock加锁。
而receive所做的就是以帧为单位，不断地将缓冲区里的数据交给net_rx()，并更新缓冲区和E1000_RDT，直到遇见E1000_RXD_STAT_DD。这里不用加锁，但值得注意的是E1000_RDT必须在最后更新？想不通。
1.2 UDP Receive说来惭愧，这个部分我实在没有思路，是让ai写的。。。
2. lock2.1 Memory allocator这里需要做的，就是kinit初始化内存管理的数据结构时，是初始化kmem[NCPU]而不是单个kmem，即通过格式化字符串的方式为每个kmem分配一把锁。然后其他跟单个kmem几乎一致。但是在kalloc里，如果某个kmem没有空闲页了，应找一个还有空闲页的kmem，拿一页进行分配。
注意在调用cpuid取当前cpu的id的时候要push_off()关中断，调用完毕要pop_off()重新开启。
但这个实验部分我个人觉得很有意思的就是格式化字符串。
2.2 Buffer cache这个题虽然是红题。但实际上本质并不复杂，它实际上说的是：
原有一个链表和一把大锁，可是这样太低效了，因为需要进行修改的可能是两个不同的节点，没有必要一把大锁把全局锁死。于是使用哈希表，将大链表拆成多个小链表分别存入每个哈希桶里，然后对每个哈希桶给予锁。这样需要进行修改的若是两个不同的节点，则可以实现并发了。
将原bcache的定义改为：
  struct bucket&#123;  struct spinlock lock;  // Linked list of all buffers, through prev/next.  // Sorted by how recently the buffer was used.  // head.next is most recent, head.prev is least.  struct buf head;&#125;;struct &#123;  struct bucket table[NHASH];  struct buf buf[NBUF];&#125; bcache;

然后修改下面的代码，使其符合这个新数据结构即可。。。
才怪！！！🤣🤣🤣
还得有一步，否则panic: bget: no buffers：
因为初始化时候，所有的缓存区都在同一个桶里，其他桶全为空！
此时就应该像上一题一样，从key对应的桶处“偷”一块缓存：
b-&gt;next-&gt;prev = b-&gt;prev;b-&gt;prev-&gt;next = b-&gt;next;release(&amp;bcache.table[key].lock);acquire(&amp;bcache.table[gethash(blockno)].lock);b-&gt;next = bcache.table[gethash(blockno)].head.next;b-&gt;prev = &amp;bcache.table[gethash(blockno)].head;bcache.table[gethash(blockno)].head.next-&gt;prev = b;bcache.table[gethash(blockno)].head.next = b;release(&amp;bcache.table[gethash(blockno)].lock);

3. fs这个实验很奇怪，make grade时会因为qemu-system-riscv64: terminating on signal 15 from pid xxxx(make)导致fail，但是单独地在qemu环境中运行bigfile symlinktest usertests -q却没有问题。难道是我wsl2 ubuntu系统的版本问题吗？
3.1 Large files这里就是将fs.h里面NDIRECT再减少一块作为双重间接块。然后添加定义
#define NDOUBLE (NINDIRECT*NINDIRECT)#define MAXFILE (NDIRECT + NINDIRECT + NDOUBLE)
在bmap里仿照分配间接块的写法，分配双重间接块。
在itrunc里仿照释放间接块的写法，释放双重间接块。
（不过，这个是真绕啊）
这里一定要理清楚：对于双重间接块，256个块为一组，第0层的data就表示每一组。第一层的data则表示每一组的每一块的地址，而第二层的data才表示真正的数据。
所以，对于分配，bn / NINDIRECT计算得组号；对于每个块在该组的序号则由bn % NINDIRECT给出。
对于释放，ip-&gt;addrs[NDIRECT+1]!=0意味着存在未释放的组。因此要对每一个未释放的组，读取它对应的第一层间接块的data，因为一个data[i]!=0就表示一个这一组未释放掉的块的地址。就这样从第2层一直到第0层逐层释放。
3.2 Symbolic links首先是sys_symlink，要在目标路径处创建一个T_SYMLINK类型的文件。并在对应的inode里分配一个缓冲块，写入target，即源文件的路径。
后一步看起来复杂，实际上就是writei函数的调用。
然后是改写sys_open。这里主要是添加一个T_SYMLINK且不是O_NOFOLLOW的处理。
为了方便处理链接的文件也是符号链接的情况，用了一个递归的函数follow
  struct inode*follow(char *path, int cnt)&#123;  if(cnt&gt;=10)&#123;    return 0;  &#125;  struct inode *ip = namei(path);  if(ip==0)&#123;    return 0;  &#125;  ilock(ip);  if(ip-&gt;type != T_SYMLINK)&#123;    return ip;  &#125;  char target[MAXPATH];  if(readi(ip, 0, (uint64)target, 0, MAXPATH) != MAXPATH)&#123;    iunlockput(ip);    return 0;  &#125;  iunlockput(ip);  struct inode *ans = follow(target,cnt+1);  return ans;&#125;


ps:sys_open是在干什么？它是创建一个文件描述符（fd），将它绑定到一个 struct file*，供后续 read(fd) &#x2F;write(fd) 使用。示意如下：

// 1. 从用户拿参数：路径 和 打开方式argstr(0, path);argint(1, &amp;omode);// 2. 找到这个文件的 inode（如果没有而且带 O_CREATE，则创建）ip = namei(path) / create(path);// 3. 分配一个 file 结构f = filealloc();// 4. 分配一个 fd 并将其与 file* 绑定fd = fdalloc(f);      // 进程的 proc-&gt;ofile[fd] = f;// 5. 初始化 file 结构：指向 inode，设置读写权限f-&gt;ip = ip;f-&gt;readable = ...f-&gt;writable = ...

4. mmap呃呃，这个也不是我自己写的。。。😭
这个实验我打算后面再“补票”。（虽然这个flag大概率会倒）
]]></content>
      <categories>
        <category>2024-xv6-labs</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Projects</tag>
        <tag>Operating System</tag>
        <tag>2024-xv6-labs</tag>
      </tags>
  </entry>
  <entry>
    <title>250721 thinking 二分查找</title>
    <url>/2025/07/21/250721-thinking-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[1. 总结二分查找的原理非常简单，但是一些细节例如是 l&lt;r还是 l&lt;=r、更新 r时是 r=mid还是 r=mid-1（l同理）等地方却有些让人头疼，实际写来如果不注意就可能会造成死循环。
于是总结一种模板：
定义域为[lo, hi)的单增的f(x), 找出最小的ans, 使得f(ans)&gt;0成立。
单减同理，甚至可以进行预处理先转化为单增的情况。
伪代码如下：
algorithm binary-search(lo,hi)	while the search area has elments do:		mid &lt;- lo + (hi-lo)/2;		if f(mid) satisfied: // the answer may occur here            		ans := mid;			hi &lt;- mid;             // the search area could have no elments when in the next loop, so return ans;             // but mid&gt;ans if next loop continues,              // for this is a right-open area, hi &lt;- mid;		else :			lo &lt;- mid + 1;             // mid is not the answer, and mid &lt; answer;            // for this is a left-close area, lo &lt;- mid + 1;	end while	return ans;

2. 例
已知一个有序数组，查找一个元素的位置并返回。若该元素不存在，则返回元素应插入的位置。

定义域为[0, nums.size())，找出最小的ans, nums[ans] &gt;&#x3D; target成立
int searchInsert(vector&lt;int&gt;&amp; nums, int target)&#123;        int left=0,right=nums.size(),ans; // f(ans)= nums[ans] 的定义域： ans \in [left, right)        while(left&lt;right)&#123;            int mid=(right-left)/2 + left;//防止直接right+left造成溢出            if(nums[mid]&gt;=target)&#123;//因为我们要找的就是nums[ans]&gt;=target                ans=mid; //所以mid可能为答案。                right=mid; //也可能mid不是答案，更新开的上界为mid            &#125;            else&#123;                left=mid+1; // 否则mid绝对不是答案。更新闭的下界为mid+1。            &#125;        &#125;        return ans; &#125;


给你一个非负整数 x ，计算并返回 x 的 算术平方根 。由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。

定义域为$[0, +\infty)$, 找出最大的$\text{ans}$, $\text{ans}^2 \leqslant x$
int mySqrt(int x) &#123;       long long l = 0, r = x+1, ans; // ans \in [0, +\infty), 但这里对r这样赋值只是为了让ans快速收敛。为什么x+1: x=0,1时 ans = x &lt; x+1。          while (l &lt; r) &#123;            long long  mid = (l+r)&gt;&gt;1;            if (mid * mid &lt;= x) &#123;//因为要找的就是ans*ans&lt;=x                ans = mid; //所以mid可能为答案。                l = mid + 1; //也可能mid不是答案，更新闭的下界为mid+1            &#125; else &#123;                r = mid; // 否则mid绝对不是答案。更新开的上界为mid。            &#125;        &#125;        return ans;     &#125;

也有一些更抽象的二分查找：
3350.检测相邻递增子数组II
令f(x)：k=x时数组是否存在两个相邻且长度为 k 的严格递增子数组,存在则f(x)=1否则f(x)=0。
则f(x)单减。满足二分查找的使用
于是原问题即为
定义域为$[2, \lceil nums.length&#x2F;2 \rceil)$, 找出最大的$\text{ans}$, $f(\text{ans})&gt;&#x3D;1$
解法示例：
func f(x int, lengths []int) bool &#123;    count := 0    for _, l := range lengths &#123;        if l &gt;= 2*x &#123;             return true        &#125;        if l &gt;= x &#123;            count++            if count &gt;= 2 &#123;                return true            &#125;        &#125;else&#123;            count = 0        &#125;    &#125;    return false&#125;func maxIncreasingSubarrays(nums []int) int &#123;    n := len(nums)    lengths := []int&#123;&#125;    cur := 1    for i := 1; i &lt; n; i++ &#123;        if nums[i] &gt; nums[i-1] &#123;            cur++        &#125; else &#123;            lengths = append(lengths, cur)            cur = 1        &#125;    &#125;    lengths = append(lengths, cur)    lo := 1; hi := len(nums)/2+1    var ans int    for lo&lt;hi&#123;        mi := lo + (hi-lo)/2        if f(mi,lengths)&#123;            ans = mi            lo = mi + 1        &#125;else&#123;            hi=mi        &#125;    &#125;    return ans&#125;
]]></content>
      <categories>
        <category>data structure &amp; algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>data structure &amp; algorithm</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title>250728-250803 周记 缓存池项目学习</title>
    <url>/2025/08/04/250728-250803-%E5%91%A8%E8%AE%B0-%E7%BC%93%E5%AD%98%E6%B1%A0%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[本周主要跟着代码随想录学习了LRU, LFU, 以及ARC三种缓存替换算法的原理和C++实现。
1. LRULRU是Least Recently Used的缩写，即淘汰最近最少使用的元素。
缓存的实现使用了一个哈希表和一个双向链表。哈希表用于快速查找缓存中的元素，双向链表用于维护缓存中的元素顺序。
每当涉及一个元素的key时，将该元素移动到双向链表的头部。当缓存满时，将双向链表的尾部元素删除。同时将该元素从哈希表中删除。
1.1 改进以上的LRU存在着缓存污染、锁的粒度过大的问题。
缓存污染：当新加进来的一次性的数据很多，导致缓存满时，传统的LRU会直接删除尾部元素。但是，尾部元素可能是热门数据。锁的粒度大：一把大锁锁全局。多线程高并发的访问下，同步等待将是一笔极大的时间开销。
故考虑以下改进：
1.1.1 LRU-KLRU-K在普通的LRU的基础上，新增加了一个小的LRU副缓存。当数据进入时，它会先进入副缓存，并访问计数加一。只有当它的访问计数大于等于K时，才会移出副缓存，进入主缓存。
当主副缓存满时，淘汰机制与普通LRU一致。
这样就可以避免缓存污染的问题。使得大量进入的一次性数据不会挤出热门数据。
1.1.2 LRU-Hash与2024-xv6-labs-2中2.2 Buffer cache的思想一致，既然一个链表配全局大锁效率低，那就把链表分成多个小链表，每个小链表即是一个小的lru缓存，各自配置最大容量，并通过一个哈希表（vector即可）统一管理，每个哈希桶配一个锁。每个新来的元素根据key的哈希值插入对应的小链表中。若容量在这之前已满，则同理删除这个小链表的尾部元素。
2. LFULFU是Least Frequently Used的缩写，即淘汰使用次数最少的元素。
缓存的实现使用了一个记录键-值对&lt;key, value&gt;的哈希表a和一个记录频率-列表对&lt;freq, linklist&gt;的哈希表b。哈希表a用于快速查找缓存中的元素，哈希表b用于根据频率高效地维护缓存中的元素。
每当涉及一个元素的key时，将该元素的频率增加1，并将该元素移动到哈希表b中对应频率的链表头部。移动后若原链表为空则删去。当缓存满时，将哈希表b中频率最低的链表的尾部元素删除。同时将该元素从哈希表a中删除。
2.1 改进普通LFU存在着新来的元素容易被移出（即使是未来的热门数据）、而过时的热门数据很难被移出的问题，而且访问次数若一直增长，可能会导致上溢。
同时与普通LRU一样，存在锁的粒度过大的问题。
改进如下：
2.1.1 最大平均访问次数限制首先设置一个阈值。当数据访问&#x2F;插入发生时，不仅需要记录当前最小访问次数，还需要计算平均访问次数。然后当平均访问次数超过阈值时，就需要对记录的访问次数进行调整。所有的元素的访问次数减去阈值的一半，操作后小于0者设为1。然后更新记录&lt;freq-linklist&gt;的哈希表，将元素插入对应频率的链表中。
这样的方式不仅可以避免访问次数的上溢，还可以加快数据的更新，让旧的热点数据”老化”，缓解挤占未来的热点数据空间的问题。
2.1.2 LFU-Hash同LRU-Hash的思想，分成多个记录&lt;freq-linklist&gt;的小哈希表，每个表即是一个小的lfu缓存，各自配置最大容量，并通过一个哈希表（vector即可）统一管理，每个哈希桶配一个锁。每个新来的元素根据key的哈希值插入对应的小链表中。若容量在这之前已满，则同理删除频率最低的链表的尾部元素。
3. ARCARC是Adaptive Replacement Cache的缩写，即自适应替换缓存。
当访问的数据趋向于访问最近的内容，会更多地命中LRU list；当系统趋向于访问频繁访问的内容时，会更多地命中LFU list。
LRU和LFU各有优劣，而实际应用环境更为复杂，需要将两种混合，取长补短。于是就有了结合LRU和LFU的缓存替换算法，即ARC。
基本思想是，将缓存分成两个部分，一部分是LRU缓存，一部分是LFU缓存，然后每个缓存有一个自己的ghost缓存。
当新数据进入时，先进入LRU list，并访问次数设为一。当再次访问这个数据时，访问次数增加1。当访问次数达到阈值后，LFU list里也插入这个元素。于是，该数据块不仅仅只保存在LRU的缓存目录中，也将保存到LFU中。所以一个最近的热门数据若有更新应该是两个表同时进行的。
这样，那些真正被频繁访问的页面将一直呆在缓存中，不会被冷数据的加入而误淘汰，不经常访问的数据会向链表头部移动，最终被淘汰出去。
当缓存满时，需要淘汰一个元素。淘汰的逻辑与对应的普通LRU和普通LFU一致，只是淘汰出的元素要插入对应的ghost缓存中。ghost缓存的淘汰模式就是简单的FIFO即可。
这样，访问元素在哪一边ghost中找到，就说明那一边的容量小了而对面的容量大了。对面的容量如果不为0则减一，然后这边的容量加一。否则跳过。
]]></content>
      <categories>
        <category>cache</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>projects</tag>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title>250721 thinking 单调栈</title>
    <url>/2025/07/21/250721-thinking-%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    <content><![CDATA[
他向远方望去，无法看到高山背后的矮山，只看到一座座更高的山峰。————by 灵神

1. 总结单调栈就是保持栈内元素单调的栈。当新元素破坏单调性时，弹出栈顶元素，弹出的瞬间就找到栈顶元素对应的答案。
栈里存放着暂时还没有找到对应答案的元素。新元素入栈时，如果栈顶元素使得栈单调性被破环，那么栈顶元素的答案产生，栈顶元素找到答案，出栈。因此需要建立的栈的单调性与题目的答案需求往往是“反过来”。要下一个更大就要单减；要下一个更小就要单增。
algorithm generalized-monotonic-stack(A, cmp, process)    stack S ← ∅    for i ← 0 to n-1 do:        while S ≠ ∅ and condition(A[i], A[S.top()]) do: // 栈的单调性被破坏，while是为了让栈里满足条件的元素都可以出栈            j ← S.pop() // 栈顶出栈            recordAnswer(j, i)  // 计算并记录栈顶对应的答案        end while        S.push(i) // 栈为空或者栈的单调性没有被破坏，则新元素一定不是某个元素的答案，入栈    end forend algorithm

时间复杂度为什么是 O(n)？每个元素最多入栈一次，出栈一次，总操作数 ≤ 2n。
2. 问题分类类型1：找下一个更大&#x2F;更小元素模板：
// 下一个更大元素while (!st.empty() &amp;&amp; arr[i] &gt; arr[st.top()]) &#123;    result[st.top()] = arr[i];    st.pop();&#125;// 下一个更小元素  while (!st.empty() &amp;&amp; arr[i] &lt; arr[st.top()]) &#123;    result[st.top()] = arr[i];    st.pop();&#125;

类型2：计算面积&#x2F;距离模板：
// 柱状图最大矩形while (!st.empty() &amp;&amp; heights[i] &lt; heights[st.top()]) &#123;    int h = heights[st.top()];    st.pop();    int w = st.empty() ? i : i - st.top() - 1;    maxArea = max(maxArea, h * w);&#125;// 每日温度（计算距离）while (!st.empty() &amp;&amp; temps[i] &gt; temps[st.top()]) &#123;    int j = st.top();    st.pop();    result[j] = i - j;  // 距离&#125;

3. 典型例题例1：下一个更大元素vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums) &#123;    int n = nums.size();    vector&lt;int&gt; result(n, -1);    stack&lt;int&gt; st;      for (int i = 0; i &lt; n; i++) &#123;        while (!st.empty() &amp;&amp; nums[i] &gt; nums[st.top()]) &#123;            result[st.top()] = nums[i];            st.pop();        &#125;        st.push(i);    &#125;    return result;&#125;

例2：柱状图最大矩形
高度：出栈元素的高度
宽度：当前位置 - 栈顶位置 - 1

寻找当前高度对应的下一个更小的高度。那么在这个答案对应的下标到栈顶对应的下标这段距离，就是当前高度对应的最大宽度。而当前高度也即是下标取值在这个范围内矩形高度取值的最大值（短板效应），所以这里的高度乘以宽度得到的矩形面积就是在下标取值在这个范围内的最大面积。
int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;    stack&lt;int&gt; st;    heights.push_back(0);  // 哨兵，这是为了保证最后一个元素也能出栈    int maxArea = 0;      for (int i = 0; i &lt; heights.size(); i++) &#123;        while (!st.empty() &amp;&amp; heights[i] &lt; heights[st.top()]) &#123;            int h = heights[st.top()];            st.pop();            int w = st.empty() ? i : i - st.top() - 1;            maxArea = max(maxArea, h * w);        &#125;        st.push(i);    &#125;    return maxArea;&#125;

例3：接雨水int trap(vector&lt;int&gt;&amp; height) &#123;    stack&lt;int&gt; st;    int water = 0;      for (int i = 0; i &lt; height.size(); i++) &#123;        while (!st.empty() &amp;&amp; height[i] &gt; height[st.top()]) &#123;            int bottom = st.top();            st.pop();            if (st.empty()) break;                      int distance = i - st.top() - 1;            int h = min(height[i], height[st.top()]) - height[bottom];            water += distance * h;        &#125;        st.push(i);    &#125;    return water;&#125;

例4: 最大二叉树TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123;        stack&lt;TreeNode*&gt;st;        for(auto &amp;i: nums)&#123;            TreeNode* cur = new TreeNode(i);            while(!st.empty() &amp;&amp; st.top()-&gt;val&lt;i)&#123;                cur-&gt;left=st.top();                st.pop();            &#125;             if(!st.empty())&#123;                st.top()-&gt;right=cur;            &#125;            st.push(cur);        &#125;        while(st.size()&gt;1)&#123;            st.pop();        &#125;        return st.top();    &#125;

4. 常用技巧技巧1：哨兵在数组末尾加 0 或无穷大，确保所有元素都能出栈：
heights.push_back(0);

技巧2：循环数组遍历两遍模拟循环：
for (int i = 0; i &lt; 2 * n; i++) &#123;    // 使用 nums[i % n]    if (i &lt; n) st.push(i);  // 只在第一轮入栈&#125;

技巧3：存储下标 vs 存储值
需要计算距离&#x2F;面积：存储下标
只需要元素值：存储值

5. 解题细节
递增栈还是递减栈？

弹出元素的条件？

弹出时如何处理，进而得到答案？

是否需要哨兵？


]]></content>
      <categories>
        <category>data structure &amp; algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>data structure &amp; algorithm</tag>
        <tag>Monotonic Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>250811-250817 周记 linux命令与shell编程学习(1)</title>
    <url>/2025/08/18/250811-250817-%E5%91%A8%E8%AE%B0-linux%E5%91%BD%E4%BB%A4%E4%B8%8Eshell%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-1/</url>
    <content><![CDATA[本周学习了Linux Command Line and Shell Scripting Bible这本书的第一部分到第二部分。这里对一些我自己不熟悉的、我自己觉得比较重要的内容进行记录摘要。
1. 第一部分 linux命令行1.3 bash shell基础命令1.3.5 列出文件和目录1.3.5.3 过滤输出列表
模式匹配: 问号(?)代表任意单个字符; 星号(*)代表零个或多个字符。
方括号代表单个字符位置并给出了该位置上的多个可能的选择。你可以将可能的字符逐一列出,也可以指定字符范围,比如字母范围[a–i]。
还可以使用惊叹号(!)将不需要的内容排除在外。

1.3.6 处理文件1.3.6.2 复制文件
cp 命令可以完成文件和目录从文件系统的一个位置复制到另一个位置的操作。 
cp 命令最基本的用法需要两个参数,即源对象和目标对象:cp source destination。 当参数 source 和 destination 都是文件名时,cp 命令会将源文件复制成一个新的目标文件,并以 destination 命名。新文件在形式上就像全新的文件一样,有新的修改时间。
如果目标文件已经存在,则 cp 命令 可能并不会提醒你这一点。最好加上-i 选项,强制 shell 询问是否需要覆盖已有文件。
cp 命令的-R 选项威力强大。可以用它在单个命令中递归地复制整个目录的内容。
在执行 cp –R 命令之前,目录 NewDocuments 并不存在。它是随着 cp –R 命令被创建的, 整个 Documents 目录中的内容都被复制到其中。注意,新的 NewDocuments 目录中所有的文件都 有对应的新日期。NewDocuments 目录现在已经成了 Documents 目录的完整副本。

1.3.6.3 使用命令行补全
制表键补全允许你在输入文件名 或目录名的时候,按一下制表键,让 shell 帮你将内容补充完整。
使用制表键补全的技巧在于要给 shell 提供足够的文件名信息,使其能够将所需文件名与其 他文件名区分开。

1.3.6.4 链接文件
链接是目录中指 向文件真实位置的占位符。在 Linux 中有两种类型的文件链接: 符号链接，硬链接。
符号链接(也称为软链接)是一个实实在在的文件,该文件指向存放在虚拟目录结构中某个地方的另一个文件。这两个以符号方式链接在一起的文件彼此的内容并不相同。可以类比为windows系统中的快捷方式。
要为一个文件创建符号链接,原始文件必须事先存在。使用 ln -s 命令创建符号链接。ln -s test_file slink_test_file
硬链接创建的是一个独立的虚拟文件,其中包含了原始文件的信息以及位置。但是两者就根本而言是同一个文件。可以理解为“同一文件出现在不同的目录下”。要想创建硬链接,原始文件也必须事先存在,只不过这次使用 ln 命令时不需要再加入额外的选项了:ln test_file hlink_test_file

1.3.6.5 文件重命名
重命名文件称为移动。mv 命令可以将文件和目录移动到另一个位置或是重新命名：mv old new

1.3.6.6 删除文件
rm的-i 选项会询问你是否真的要删除该文件。shell 没有回收站或者垃圾箱这样的东西, 文件一旦被删除,就再也找不回来了。所以在使用 rm 命令时,要养成总是加入-i 选项的好习惯。

1.3.7 管理目录1.3.7.1 创建目录
可以根据需要“批量”地创建目录和子目录。为此,要使用 mkdir 命令的-p 选项, mkdir 命令的-p 选项可以根据需要创建缺失的父目录。

1.3.8 查看文件内容1.3.8.1 查看文件类型
file 命令是一个方便的小工具,能够探测文件的内部并判断文件类型

3.8.2 查看整个文件
cat


cat 命令是显示文本文件中所有数据的得力工具。
-n 选项会给所有的行加上行号
如果只想给有文本的行加上行号,可以用-b 选项


more

less



less实为 more 命令的升级版本
less 命令提供了多个非常实用的特性,能 够实现在文本文件中前后翻动,还有一些高级搜索功能。
less 命令还可以在完成整个文件的读取之前显示文件的内容。

1.3.8.3 查看部分文件
tail 命令


tail 命令会显示文件最后几行的内容(文件的“尾部”)。在默认情况下,它会显示文件的 末尾 10 行。
可以向 tail 命令中加入-n 选项来修改所显示的行数，如通过加入-n 2, 使得 tail 命令只显示文件的最后两行
tail 命令有一个非常酷的特性:-f 选项,该选项允许你在其他进程使用此文件时查看文件 的内容。tail 命令会保持活动状态并持续地显示添加到文件中的内容。这是实时监测系统日志 的绝佳方式。


head 命令


head 命令会显示文件开头若干行(文件的“头部”)。在默认情况下,它会显示文件前 10 行的文本
head 命令也支持-n 选项
这两个命令也允 许简单地在连字符后面直接输入想要显示的行数

1.4 更多的 bash shell 命令1.4.1 监测程序1.4.1.1 探查进程
ps 命令默认只显示运行在当前终端中属于当前用户的那些进程。
ps 命令的基本输出显示了程序的进程 ID(process ID,PID)、进程运行在哪个终端(TTY) 及其占用的 CPU 时间。
如果需要查看系统中运行的所有进程,可以使用-ef 选项组合。-e 选项指定显示系统中运行的所有进程;-f 选项则扩充输出内容以显示一些有用的信息列：




列名
说明



UID
启动该进程的用户


PID
进程 ID


PPID
父进程的 PID(如果该进程是由另一个进程启动的)


C
进程生命期中的 CPU 利用率


STIME
进程启动时的系统时间


TTY
进程是从哪个终端设备启动的


TIME
运行进程的累计 CPU 时间


CMD
启动的程序名称



如果还想获得更多的信息, 可以使用-l 选项,产生长格式输出。多出的那几列：




列名
说明



F
内核分配给进程的系统标志


S
进程的状态:O - 正在运行S - 休眠R - 可运行,正等待运行Z - 僵化,已终止但找不到其父进程T - 停止


PRI
进程的优先级(数字越大,优先级越低)


NI
谦让度(nice),用于决定优先级


ADDR
进程的内存地址


SZ
进程被换出时所需交换空间的大致大小


WCHAN
进程休眠的内核函数地址



–forest 选项着实讨人喜欢。该选项能够使用 ASCII 字符来绘制可爱的图表以显示进程的层级信息

1.4.1.2 实时监测进程
top 命令也可以显示进程信息,但采用的是实时方式
在默认情况下,top 命令在启动时会按照%CPU 值来对进程进行排序

1.4.1.3 结束进程
在 Linux 中,进程之间通过信号来通信。




信号
名称
描述



1
HUP
挂起


2
INT
中断


3
QUIT
结束运行


9
KILL
无条件终止


11
SEGV
段错误


15
TERM
尽可能终止


17
STOP
无条件停止运行,但不终止


18
TSTP
停止或暂停,但继续在后台运行


19
CONT
在 STOP 或 TSTP 之后恢复执行



在 Linux 中有两个命令可以向运行中的进程发出进程信号:kill 和 pkill。


kill


kill 命令可以通过 PID 向进程发送信号, 遗憾的是,你只能使用进程的 PID 而不能使用其对应的程序名
不服管教的进程通常会忽略这个请求。如果要强制终止, 则-s 选项支持指定其他信号(用信号名或信号值)。kill -9 PID


pkill


pkill 命令可以使用程序名代替 PID 来终止进程,除此之外,pkill 命令 也允许使用通配符

1.4.2 监测磁盘空间1.4.2.1 挂载存储设备
Linux 文件系统会将所有的磁盘都并入单个虚拟目录。在使用新的存储设备之前,需要将其放在虚拟目录中。这项工作称为挂载(mounting)。
实际的物理存储设备通过驱动被抽象成 &#x2F;dev&#x2F;xxx 设备文件，用户不能直接用目录树访问它们。必须把它们挂载到虚拟文件系统（VFS）的某个挂载点之后，才能以统一的方式访问和管理。


mount


用于挂载存储设备的命令叫作 mount。在默认情况下,mount 命令会输出当前系统已挂载 的设备列表。
如果知道设备分区使用的文件系统类型,可以使用-t &lt;fs-type&gt;过滤输出。
mount 命令提供了 4 部分信息: 设备文件名, 设备在虚拟目录中的挂载点, 文件系统类型, 已挂载设备的访问状态
手动挂载设备的基本命令: mount -t type device directory, type 参数指定了磁盘格式化所使用的文件系统类型。示例： mount -t vfat /dev/sdb1 /media/disk
-o 选项允许在挂载文件系统时添加一系列以逗号分隔的额外选项, 如:




选项
说明



ro
以只读形式挂载


rw
以读写形式挂载


user
允许普通用户挂载该文件系统


check&#x3D;none
挂载文件系统时不执行完整性校验


loop
挂载文件



umount


移除可移动设备时,不能直接将设备拔下,应该先卸载。
umount 命令的格式非常简单:  umount [directory | device ]

1.4.2.2 使用 df 命令
有时需要知道在某台设备上还有多少磁盘空间。df 命令可以方便地查看所有已挂载磁盘的使用情况
df 命令会输出内核挂载的所有虚拟文件系统,因此可以使用-t 选项来指定文件系统类型
该命令的输出: 设备文件位置, 包含多少以 1024 字节为单位的块, 使用了多少以 1024 字节为单位的块, 还有多少以 1024 字节为单位的块可用, 已用空间所占的百分比, 设备挂载点
常用选项之一是-h,该选项会以人类易读(humanreadable)的形式显示磁盘空间,通常用 M 来替代兆字节,用 G 来替代吉字节

1.4.2.3 使用 du 命令
du 命令可以显示某个特定目录(默认情况下是当前 目录)的磁盘使用情况。
下面这些选项能让 du 命令的输出更加清晰易读。
-c:显示所有已列出文件的总大小。
-h:按人类易读格式输出大小,分别用 K 表示千字节、M 表示兆字节、G 表示吉字节。
-s:输出每个参数的汇总信息。



1.4.3 处理数据文件1.4.3.1 数据排序
处理大量数据时的一个常用命令是 sort。这是用来对数据进行排序的命令。
在默认情况下, sort 命令会依据字典序来对文本文件中的数据行进行排序。
使用-n 选项告诉 sort 命令将数字按值排序
加入-M 选项,那么 sort 命令就能识别三字符的月份名并正确排序
-r –reverse 逆序排序(升序变成降序)
-c –check 不排序,但检查输入数据是否有序,无序的话就报告
-u –unique 和-c 选项合用时,检查严格排序;不和-c 选项合用时,相同行仅输出一次
在对按字段分隔的数据进行排序时,-k 选项和-t 选项非常方便。 先使用-t 选项指定字段分隔符,然后使用-k 选项指定排序字段(从1开始)。示例：sort -t &#39;:&#39; -k 3 -n /etc/passwd

1.4.3.2 数据搜索
grep [options] pattern [file]
如果要进行反向搜索(输出不匹配指定模式的行),可以使用-v 选项
如果要显示匹配指定模式的那些行的行号,可以使用-n 选项
如果只想知道有多少行含有匹配的模式,可以使用-c 选项

1.4.3.3 数据压缩
gzip 命令会压缩命令行中指定的文件。也可以指定多个文件名或是用通配符来一次性压缩多个文件，压缩后的文件会在原文件名后面添加 .gz 扩展名。
要解压缩文件,可以使用 gunzip 命令,或者使用 gzcat 命令来查看压缩文件的内容。

1.4.3.4 数据归档
gzip 命令只能压缩文件，要压缩一个文件夹，需要先归档。

归档工具是 tar 命令tar function [options] object1 object2 ...

常用function: -c –create 创建新的 tar 归档文件 -t –list 列出 tar 归档文件的内容

常用option: -f file 将结果输出到文件(或设备) 

tar -cf test.tar test/ test2/该命令创建了一个名为 test.tar 的归档文件, 包含目录 test 和 test2 的内容。

tar -tf test.tar 该命令列出了(但不提取)tar 文件 test.tar 的内容。

tar -xvf test.tar 该命令从 tar 文件 test.tar 中提取内容。如果创建的时候 tar 文件含有目录结构,则在当前目录中重建该目录的整个结构。

在下载开源软件时经常会看到文件名以.tgz 结尾,这是经 gzip 压缩过的 tar 文件,可以用 tar -zxvf filename.tgz 来提取其中的内容。

tar 命令的操作





操作
长选项
描 述



-A
–concatenate
将一个 tar 归档文件追加到另一个 tar 归档文件末尾


-c
–create
创建新的 tar 归档文件


-d
–diff
检查归档文件和文件系统的不同之处



–delete
从 tar 归档文件中删除文件


-r
–append
将文件追加到 tar 归档文件末尾


-t
–list
列出 tar 归档文件的内容


-u
–update
将比 tar 归档文件中已有的同名文件更新的文件追加到该归档文件


-x
–extract
从 tar 归档文件中提取文件



tar 命令选项




选项
描述



-C dir
切换到指定目录


-f file
将结果输出到文件(或设备)


-j
将输出传给 bzip2 命令进行压缩


-J
将输出传给 xz 命令进行压缩


-p
保留文件的所有权限


-v
在处理文件时显示文件名


-z
将输出传给 gzip 命令进行压缩


-Z
将输出传给 compress 命令进行压缩


1.5 理解 shell1.5.3 理解外部命令和内建命令1.5.3.2 内建命令
使用命令别名


alias 命令是另一个实用的 shell 内建命令。命令别名允许为常用命令及其参数创建另一个名称,从而将输入量减少到最低。alias alias-name=origin
因为命令别名属于 内建命令,所以别名仅在其被定义的 shell 进程中才有效。

1.6 Linux 环境变量1.6.1 什么是环境变量
bash shell 中有两种环境变量: 全局变量, 局部变量。

1.6.1.1 全局环境变量
全局环境变量对于 shell 会话和所有生成的子 shell 都是可见的。局部环境变量则只对创建它 的 shell 可见。
可以使用 env 命令或 printenv 命令来查看全局变量
使用 echo 命令显示某个变量的值。在引用某个环境变量时,必须在该变量名前加上美元 符号($)

1.6.2 设置用户自定义变量1.6.2.1 设置局部用户自定义变量
使用等号为变量赋值,值可以是数值或字符串 my_variable=Hello
如果用于赋值的字符串包含空格,则必须用单引号或双引号来界定该字符串的起止
在变量名、等号和值之间没有空格。如果在赋值表达式中加上了空 格,那么 bash shell 会将值视为单独的命令

1.6.2.2 设置全局环境变量
export my_variable=value

1.6.3 删除环境变量
删除已有的环境变量。可以用 unset 命令来完成这 个操作。在 unset 命令中引用环境变量时,记住不要使用$。
如果要用到(doing anything with)变量,就使用$;如果要操作(doing anything to)变量,则不使用$。
对于 PATH 变量的修改只能持续到退出或重启系统。这种效果并不能一直奏效。

1.6.6 定位系统环境变量
当你登录 Linux 系统启动 bash shell 时,默认情况下 bash 会在几个文件中查找命令。这些文件 称作启动文件或环境文件。

1.6.6.1 登录 shell
登录 shell 通常会从 5 个不同的启 动文件中读取命令。  
&#x2F;etc&#x2F;profile  
$HOME&#x2F;.bash_profile  
$HOME&#x2F;.bashrc  
$HOME&#x2F;.bash_login  
$HOME&#x2F;.profile


&#x2F;etc&#x2F;profile 文件是系统中默认的 bash shell 的主启动文件。系统中的每个用户登录时都会执行这个启动文件。
其余的启动文件都用于同一个目的:提供用户专属的启动文件来定义该用户所用到的环境 变量。大多数 Linux 发行版只用这 4 个启动文件中的一两个。
在大多数发行版中,保存个人用户永久性 bash shell 变量的最佳地点是$HOME&#x2F;.bashrc 文件。
可以把个人的 alias 设置放在$HOME&#x2F;.bashrc 启动文件中,使其效果永久化。

1.7 理解 Linux 文件权限1.7.3 理解文件权限
1.7.3.2 默认文件权限
使用3位8进制数来表示权限。




权限
二进制值
八进制值
描述



—
000
0
没有任何权限


–x
001
1
只有执行权限


-w-
010
2
只有写入权限


-wx
011
3
有写入和执行权限


r–
100
4
只有读取权限


r-x
101
5
有读取和执行权限


rw-
110
6
有读取和写入权限


rwx
111
7
有全部权限(读取、写入和执行)



umask 命令用来设置新建文件和目录 的默认权限
umask 值只是个掩码, 把 umask 值从对象的全权限值(full permission)中减掉。对文件而言,全权限值是 666 (所有用户都有读取和写入的权限);对目录而言,全权限值则是 777(所有用户都有读取、写入 和执行权限), 结果就是新建的文件或目录的权限。
文件不能直接执行。新建文件是普通数据（文本、配置、源码等），不是程序。因此全权限为666
必须要有 x 权限才能进入目录，否则你即使有 r 也只能列出文件名，看不到内容。

1.7.4 更改安全设置1.7.4.1 修改权限
chmod 命令可以修改文件和目录的安全设置。chmod options mode file
mode 参数允许使用八进制模式（推荐）或符号模式来进行安全设置。

1.9 安装软件1.9.1 软件包管理基础
软件包存储在称为仓库(repository)的服务器上,可以利用本地 Linux 系统中的软件包管理 器通过 Internet 访问,在其中搜索新的软件包,或是更新系统中已安装的软件包。

1.9.2 基于 Debian 的系统
apt [options] command

1.9.2.1 使用 apt 管理软件包
apt list 命 令会显示仓库中所有可用的软件包,如果再加入–installed 选项,就可以限制仅输出那些已安装在系统中的软件包
如果已经知道系统中的某个软件包,希望显示其详细信息,可以使用 show 命令来操作: apt show package_name
apt show 命令并不会指明软件包是否已经安装。它只根据软件仓库显示该软件包的详细信息。

1.9.2.2 使用 apt 安装软件包
查找特定的软件包: apt search package_name 
search 命令的妙处在于不需要在 package_name 周围添加通配符,直接就有通配符的效果。
如果只想搜索软件包名称,可以加入–name-only 选项。
安装：apt install package_name 
可以使用 list 命令的–installed 选项检查安装是否正确。如果在输出中看到了软件包, 那么说明已经安装好了。

1.9.2.3 使用 apt 升级软件
upgrade 命令可以使用仓库中的任何新版本安全地升级系统中所有的软件包:  apt upgrade
upgrade 命令在升级过程中不会删除任何软件包。如果必须删除某个软件包才能完成升级, 可以使用以下命令:  apt full-upgrade

1.9.2.4 使用 apt 卸载软件包
apt 的 remove 命令可以删除软件包,同时保留数据和配置文件。如果要将软件包以及相关 的数据和配置文件全部删除,那么需要使用 purge 命令
如果确定有依赖关系的软件包不会再有他用,可以使用 autoremove 命令将其删除

1.9.4 使用容器管理软件
云计算带来了应用程序打包方式的一种新范式:应用程序容器(application container)。应用 程序容器创建了一个环境,其中包含了应用程序运行所需的全部文件,包括运行时库文件。开发 人员随后可以将应用程序容器作为单个软件包分发,保证能够在任何 Linux 系统中正常运行。

1.9.4.1 使用 snap 容器
使用 snap 命令行工具查询 snap 数据库,显示已安装的 snap 包,以及安装、升级和删除 snap 包。
snap list 命令查看当前已安装的 snap 应用程序列表
snap find 命令可以在 snap 仓库中搜索指定程序
snap info 命令可以查看 snap 应用程序(简称为 snap)的详细信息
snap install 命令可以安装新的 snap
如果需要删除某个 snap,使用 snap remove 命令即可
Snap vs APT 的区别




特性
APT (Deb 包)
Snap 包



软件形式
.deb 包
.snap 包


依赖管理
使用系统库，依赖需要由 APT 解决
自带依赖，几乎无需外部依赖


安装来源
Debian&#x2F;Ubuntu 官方仓库 或 PPA
Snap Store（集中式）


升级机制
由系统包管理器统一升级
Snapd 后台自动滚动更新


运行环境
与系统环境强耦合
运行在容器化沙盒中


体积大小
通常较小（共用系统库）
较大（自带依赖）


安全性
依赖系统级安全机制
自带沙盒隔离，更细粒度权限控制


启动速度
快，直接使用系统库
稍慢，需通过 snapd 启动环境


典型应用
系统级工具、传统软件
桌面应用、跨发行版的程序


TO BE CONTINUED
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>reading note</tag>
        <tag>linux</tag>
        <tag>Linux Command Line and Shell Scripting Bible</tag>
      </tags>
  </entry>
  <entry>
    <title>250811-250817 周记 linux命令与shell编程学习(2)</title>
    <url>/2025/08/19/250811-250817-%E5%91%A8%E8%AE%B0-linux%E5%91%BD%E4%BB%A4%E4%B8%8Eshell%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-2/</url>
    <content><![CDATA[2. 第二部分 shell 脚本编程基础2.11 构建基础脚本2.11.2 创建 shell 脚本文件
其中输入命令。 在创建 shell 脚本文件时,必须在文件的第一行指定要使用的 shell,格式如下:  #!&#x2F;bin&#x2F;bash  在普通的 shell 脚本中,#用作注释行。shell 并不会处理 shell 脚本中的注释行。然而,shell 脚本文件的第一行是个例外,#后面的惊叹号会告诉 shell 用哪个 shell 来运行脚本。(是的,可以使用 bash shell,然后使用另一个 shell 来运行你的脚本。)
通过 chmod 命令(参见第 7 章)赋予文件属主执行文件的权限后，就可以直接./script.sh来运行脚本了。

2.11.3 显示消息
如果在 echo 命令后面加上字符串,那么 echo 命令就会显示出这个字符串
echo输出默认句末带一个换行符\n,可以使用-n选项取消换行符

2.11.4 使用变量2.11.4.1 环境变量
反斜线允许 shell 脚本按照字面意义解释$,而不是引用变量
通过${variable}形式引用的变量。花括号通常用于帮助界定$后的变量名。

2.11.4.2 用户自定义变量
使用等号为变量赋值。在变量、等号和值之间不能出现空格
shell 脚本会以字符串形式存储所有的变量值,脚本中的各个命令可以自行决定变量值的数据类型。
shell 脚本中定义的变量在脚本的整个生命周期里会一直保持着它们的值,在脚本结束时会被删除。
引用变量值时要加$,对变量赋值时则不用加$

2.11.4.3 命令替换
将命令输出赋给变量: var=$(command)或者: var=`command` 注意,赋值号和命令替换 符之间没有空格

2.11.5 重定向输入和输出2.11.5.1 输出重定向
最基本的重定向会将命令的输出发送至文件。bash shell 使用“&gt;”来实现该操作
将命令输出追加到已有文件中：&gt;&gt;

2.11.5.2 输入重定向
输入重定向会将文件的内容作为命令的输入。使用“&lt;”来实现该操作 command &lt; inputfile
一种简单的记忆方法是,在命令行中,命令总是在左侧,而重定向运算符“指向”数据流动的方向。小于号说明数据正在从输入文件流向命令。
还有另外一种输入重定向的方法,称为内联输入重定向。这种方法 无须使用文件进行重定向,只需在命令行中指定用于输入重定向的数据即可。
内联输入重定向的格式如下: command &lt;&lt; delimiter
其中,delimiter 是一个用户定义的字符串,用于标识输入重定向的结束。
内联输入重定向的工作原理是,shell 会将命令行中所有位于 delimiter 之前的文本作为命令的输入。例如：



$ wc &lt;&lt; EOF &gt; test string 1 &gt; test string 2 &gt; test string 3 &gt; EOF 


因此可以在脚本中像这样用：

cat &gt;&gt; $outfile &lt;&lt; EOF INSERT INTO members (lname,fname,address,city,state,zip) VALUES (&#x27;$lname&#x27;, &#x27;$fname&#x27;, &#x27;$address&#x27;, &#x27;$city&#x27;, &#x27;$state&#x27;, &#x27;$zip&#x27;); EOF


快速地根据csv文件生成sql语句

2.11.6 管道
将一个命令的输出作为另一个命令的输入 command1 | command2
实际上,Linux 系统会同时运行这两个命令, 在系统内部将二者连接起来。当第一个命令产生输出时,它会被立即传给第二个命令。数据传输 不会用到任何中间文件或缓冲区。
管道可以串联的命令数量没有限制。可以持续地将命令输出通过管道传给其他命令来细化操作。


2.11.7 执行数学运算2.11.7.2 使用括号
要将数学运算结果赋给变量,使用var=$((expression))
bash shell 的数学运算符只支持整数运算, z shell(zsh)提供了完整的浮点数操作。

2.11.8 退出脚本2.11.8.1 查看退出状态码
Linux 提供了专门的变量$?来保存最后一个已执行命令的退出状态码。
按照惯例,对于成功结束的命令,其退出状态码是 0。对于因错误而结束的命令,其退出状态码是一个正整数。

2.1.8.2 exit 命令
exit 命令允许在脚本结束时指定一个退出状态码
退出状态码必须是 0 到 255 之间的整数。如果指定了超出这个范围的值,则会自动对256取模。

2.12 结构化命令2.12.1 使用 if-then 语句if command; then    commandsfi

2.12.2 if-then-elseif command; then    commandselse    commandsfi

2.12.3 if-then-elif-elseif command; then    commandselif command; then    commands(省略可能的多个elif语句)else    commandsfi

2.12.4 test 命令
bash shell 提供了另一种条件测试方式:

if [ condition ]; then    commandsfi


第一个方括号之后和第二个方括号之前必须留有空格

2.12.4.1 数值比较


比较
描述



n1 -eq n2
检查 n1 是否等于 n2


n1 -ge n2
检查 n1 是否大于或等于 n2


n1 -gt n2
检查 n1 是否大于 n2


n1 -le n2
检查 n1 是否小于或等于 n2


n1 -lt n2
检查 n1 是否小于 n2


n1 -ne n2
检查 n1 是否不等于 n2


2.12.4.2 字符串比较


比较
描述



-z string
检查字符串是否为空


-n string
检查字符串是否不为空


string1 &#x3D; string2
检查字符串是否相等


string1 !&#x3D; string2
检查字符串是否不相等


string1 &lt; string2
检查字符串是否小于 string2


string1 &gt; string2
检查字符串是否大于 string2



测试表达式使用标准的数学比较符号来表示字符串比较,而用文本代码来表示数值比较。

2.12.4.3 文件比较


比较
描述



-e filename
检查文件是否存在


-f filename
检查文件是否存在且是一个普通文件


-d filename
检查文件是否存在且是一个目录


-r filename
检查文件是否存在且可读


-w filename
检查文件是否存在且可写


-x filename
检查文件是否存在且可执行


-s filename
检查文件是否存在且非空


filename1 -nt filename2
检查 filename1 是否比 filename2 新


filename1 -ot filename2
检查 filename1 是否比 filename2 旧


2.12.5 复合条件测试
if-then 语句允许使用布尔逻辑将测试条件组合起来。可以使用以下两种布尔运算符：
[ condition1 ] &amp;&amp; [ condition2 ] 
[ condition1 ] || [ condition2 ]



2.12.6 if-then 的高级特性2.12.6.1 使用单括号if (command); then    commandsfi


单括号中的命令会在子 shell 中执行,而不是在当前 shell 中执行。
单括号中的命令可以使用分号分隔多个命令。
单括号中的命令可以使用反引号或美元符号引用变量。

2.12.6.2 使用双括号if ((expression)); then    commandsfi


双括号中的表达式可以使用的运算符：




符号
描述



val++
后增


val–
后减


++val
先增


–val
先减


!
逻辑求反


~
位求反


**
幂运算


&lt;&lt;
左位移


&gt;&gt;
右位移


&amp;
位布尔 AND


|
位布尔 OR


&amp;&amp;
逻辑 AND


||
逻辑 OR



双括号命令既可以在 if 语句中使用,也可以在脚本中的普通命令里用来赋值
双括号中表达式的大于号和小于号不用转义。这是双括号命令又一个优越性的体现。

2.12.6.3 使用双方括号
双方括号命令提供了针对字符串比较的高级特性

if [[ expression ]]; then    commandsfi

提供了 test 命令所不具备的另一个特性——模式匹配。
双等号(&#x3D;&#x3D;)会将右侧的字符串视为一个模式并应用模式匹配规则。

2.12.7 case 命令
有了 case 命令,就无须再写大量的 elif 语句来检查同一个变量的值了。case 命令会采 用列表格式来检查变量的多个值:

case variable in    pattern1)        commands        ;;    pattern2)        commands        ;;    *)        commands        ;;esac

2.13 更多的结构化命令2.13.1 for 命令for variable in list; do    commandsdone

2.13.1.2 读取列表中的复杂值
for 循环假定各个值之间是 以空格分隔的。如果某个值含有空格, 则必须将其放入双引号内。

2.13.1.5 更改字段分隔符
IFS 环境变量定义了 bash shell 用作字段分隔符的一系列字符。在默认情况下,bash shell 会将下列字符视为字段分隔符。
空格
制表符
换行符


修改 IFS 环境变量可以改变 bash shell 用作字段分隔符的字符。修改 IFS 的值,使其只能识别换行符: IFS=$&#39;\n&#39;


在 Bash 里，$’…’ 是 ANSI-C 风格的字符串，会识别 C 语言风格的转义符$’\n’ → 真正的换行符$’\t’ → 制表符（Tab）$’\x41’ → 字符 A


在处理代码量较大的脚本时,可能在一个地方需要修改 IFS 的值,然后再将其恢复原状,而脚本的其他地方则继续沿用 IFS 的默认值。一种安全的做法是在修改 IFS 之前保存原来的 IFS 值,之后再恢复它。这种技术可以像下面这样来实现:IFS.OLD=$IFS IFS=$&#39;\n&#39;&lt;在代码中使用新的 IFS 值&gt;IFS=$IFS.OLD这就保证了在脚本的后续操作中使用的是 IFS 的默认值。

2.13.1.6 使用通配符读取目录
用 for 命令来自动遍历目录中的文件。
在文件名或路径名中使用 通配符,这会强制 shell 使用文件名通配符匹配(file globbing)。

for file in /path/*; do    commandsdone


在 Linux 中,目录名和文件名中包含空格是完全合法的。要应对这种情况,应该将$file 变 量放入双引号内。否则,遇到含有空格的目录名或文件名时会产生错误


可以在 for 命令中列出多个目录通配符

for file in /path/* /path2/*; do    commandsdone

2.13.2 C 语言风格的 for 命令
bash 中仿 C 语言的 for 循环的基本格式如下:  for (( variable assignment ; condition ; iteration process )); do    commandsdone

2.13.3 while 命令2.13.3.1 while 的基本格式while [ condition ]; do    commandsdone

2.13.7 循环控制2.13.7.1 break 命令for var in list; do    commands    if [ condition ]; then        break    fidone

2.13.7.2 continue 命令for var in list; do    commands    if [ condition ]; then        continue    fidone

2.13.8 处理循环的输出
对循环的输出使用管道或进行重定向。通过在 done 命令之后 添加一个处理命令来实现

for var in list; do    commandsdone &gt; output.txt


“|”以及”&lt;”都可以像这样用

2.14 处理用户输入2.14.1 传递参数2.14.1.1 读取参数
bash shell 会将所有的命令行参数都指派给称作位置参数(positional parameter)的特殊变量。 这也包括 shell 脚本名称。
位置变量的名称都是标准数字:$0 对应脚本名,$1 对应第一个命令行参数,$2 对应第二个命令行参数,以此类推。

2.14.1.2 读取脚本名
basename 命令可以返回不包含路径的脚本名

2.14.2 特殊参数变量2.14.2.1 参数统计
$#含有脚本运行时携带的命令行参数的个数，不包含脚本名。
$&#123;!#&#125; 代表了最后一个位置变量

2.14.2.2 获取所有的数据
$*变量和$@变量可以轻松访问所有参数,它们各自包含了所有的命令行参数
$*变量会将所有的命令行参数视为一个单词。这个单词含有命令行中出现的每一个参数。 基本上,$*变量会将这些参数视为一个整体,而不是一系列个体。
$@变量会将所有的命令行参数视为同一字符串中的多个独立的单词,以便你能遍历并处理全部参数。这通常使用 for 命令完成。

2.14.3 移动参数
shift 命令会将所有的位置参数向左移动。每个位置参数的变量名都会减 1。$1 会变成$0,$2 会变成$1,以此类推。被删除的参数会被丢弃。
shift 命令可以接受一个可选的参数,用于指定要左移几位。默认情况下,它会将所有的位置参数向左移动一个位置。

2.14.4.3 使用 getopts 命令
getopts optstring variable
getopts 命令要用到两个环境变量。如果选项需要加带参数值,那么 OPTARG 环境变量保存的就是这个值。OPTIND 环境变量保存着参数列表中 getopts 正在处理的参数位置。这样在处理完当前选项之后就能继续处理其他命令行参数了。使用举例：

while getopts :ab: opt; do    case $opt in        a)            echo &quot;Option a&quot; ;;        b)            echo &quot;Option b with value $OPTARG&quot; ;;        \?)            echo &quot;Invalid option: -$opt&quot; ;;    esacdone


在解析命令行选项时,getopts 命令会移 除起始的连字符,所以在 case 语句中不用连字符。
选项字符串中的冒号(:)表示该选项需要一个参数值。

2.14.6 获取用户输入2.14.6.1 基本的读取
read 命令从标准输入(键盘)或另一个文件描述符中接受输入。获取输入后,read 命令会 将数据存入变量。read variable
read 命令也提供了-p 选项,允许直接指定提示符:read -p &quot;Enter your name: &quot; name

2.14.6.2 超时
用-t 选项来指定一个计时器。-t 选项会指定 read 命令等待输入的 秒数。如果计时器超时,则 read 命令会返回非 0 退出状态码
用-n 选项来指定 read 命令读取的字符数，read会在接收到设定个数的字符后自动退出。

2.14.6.3 无显示读取
-s 选项可以避免在 read 命令中输入的数据出现在屏幕上(其实数据还是会被显示,只不 过 read 命令将文本颜色设成了跟背景色一样)

2.14.6.4 从文件中读取
每次调用 read 命令都会从指定文件中读取一行文本。 当文件中没有内容可读时,read 命令会退出并返回非 0 退出状态码。

while read line; do    echo $linedone &lt; input.txt

2.15 呈现数据2.15.1 理解输入和输出


文件描述符
缩写
描述



0
STDIN
标准输入


1
STDOUT
标准输出


2
STDERR
标准错误



shell 对于错误消息的处理是跟普通输出分开的。只使用“&gt;”重定向只能重定向标准输出,而不能重定向标准错误。
在默认情况下,STDERR 和 STDOUT 指向同一个地方————显示器。

2.15.1.2 重定向错误
只重定向错误


command 2&gt; &amp;1 2与“&gt;”必须紧挨着,否则无法正常工作


重定向错误消息和正常输出


如果想重定向错误消息和正常输出,则必须使用两个重定向符号。你需要在重定向符号之前 放上需要重定向的文件描述符,然后让它们指向用于保存数据的输出文件
将 STDERR 和 STDOUT 的输出重定向到同一个文件：&amp;&gt;

2.15.2 在脚本中重定向输出
有意在脚本中生成错误消息,可以将单独的一行输出重定向到 STDERR: &gt;&amp;2 
在重定向到文件描述符时,必须在文件 描述符索引值之前加一个&amp;
可以理解为：0、1、2为文件描述符，而&amp;1、&amp;2、&amp;3为文件描述符所指代的具体的文件&#x2F;设备名。

2.15.2.2 永久重定向
exec 命令会告诉 shell 在脚本执行期间重定向某个特定文件描述符: exec 1&gt; output.txt。还可以用来创建新的文件描述符。exec 3&gt; testfile

2.15.3 在脚本中重定向输入
exec 命令允许将 STDIN 重定向为文件: exec 0&lt; input.txt
只要脚本需要输入, 这个重定向就会起作用：

exec 0&lt; testfile count=1  while read line; do     echo &quot;Line #$count: $line&quot;     count=$[ $count + 1 ] done

2.15.4 创建自己的重定向2.15.4.2 重定向文件描述符
恢复已重定向的文件描述符：

exec 3&gt;&amp;1 exec 1&gt;test14out...exec 1&gt;&amp;3# 1恢复


2.15.4.5 关闭文件描述符
要关闭文件描述符,只需将其重定向到特殊符号&amp;-即可: exec 3&gt;&amp;-

2.15.5 列出打开的文件描述符
lsof 命令可以列出当前系统中打开的所有文件描述符。
最常用的选项包括-p 和-d,前者允许指定进程 ID(PID),后者允许指定要显示的文件描述符编号(多个编号之间以逗号分隔)。
$$: 当前进程的 PID
lsof的默认输出：




列
描述



COMMAND
进程对应的命令名的前 9 个字符


PID
进程的 PID


USER
进程属主的登录名


FD
文件描述符编号以及访问类型(r 代表读,w 代表写,u 代表读&#x2F;写)


TYPE
文件的类型(CHR 代表字符型,BLK 代表块型,DIR 代表目录,REG 代表常规文件)


DEVICE
设备号(主设备号和从设备号)


SIZE
如果有的话,表示文件的大小


NODE
本地文件的节点号


NAME
文件名


2.15.6 抑制命令输出
重定向到 &#x2F;dev&#x2F;null 可以抑制命令的输出
也可以在输入重定向中将&#x2F;dev&#x2F;null 作为输入文件，快速清除现有文件中的数据：cat /dev/null &gt; testfile

2.15.7 使用临时文件2.15.7.1 创建本地临时文件
mktemp 会在本地目录中创建一个文件。在使用 mktemp 命令时,只需指定 一个文件名模板即可。模板可以包含任意文本字符,同时在文件名末尾要加上 6 个 X。
mktemp 命令会任意地将 6 个 X 替换为同等数量的字符,以保证文件名在目录中是唯一的。 你可以创建多个临时文件,并确保每个文件名都不重复
mktemp 命令的输出正是它所创建的文件名。

2.15.7.2 在&#x2F;tmp 目录中创建临时文件
-t 选项会强制 mktemp 命令在系统的临时目录中创建文件。在使用这个特性时,mktemp 命令会返回所创建的临时文件的完整路径名,而不只是文件名

2.15.7.3 创建临时目录
-d 选项会告诉 mktemp 命令创建一个临时目录。你可以根据需要使用该目录,比如在其中 创建其他的临时文件

2.15.8 记录消息
tee 命令就像是连接管道的 T 型接头,它能将来自 STDIN 的数据同时送往两处。一处是 STDOUT,另一处是 tee 命令行所指定的文件名（这个文件不需要先前存在）
配合管道命令来重定向命令输出: command | tee testfile
tee 命令的 -a 选项会将输出追加到文件中,而不是覆盖文件内容

2.16 脚本控制2.16.1 处理信号2.16.1.1 重温 Linux 信号


信号值
信号名
描述



1
SIGHUP
挂起(hang up)进程


2
SIGINT
中断(interrupt)进程


3
SIGQUIT
停止(stop)进程


9
SIGKILL
无条件终止(terminate)进程


15
SIGTERM
尽可能终止进程


18
SIGCONT
继续运行停止的进程


19
SIGSTOP
无条件停止,但不终止进程


20
SIGTSTP
停止或暂停(pause),但不终止进程


2.16.2 以后台模式运行脚本2.16.2.1 后台运行脚本
以后台模式运行 shell 脚本非常简单,只需在脚本名后面加上&amp;即可

2.16.3 在非控制台下运行脚本
有时候,即便退出了终端会话,你也想在终端会话中启动 shell 脚本,让脚本一直以后台模 式运行到结束。这可以用 nohup 命令来实现
nohup 命令能阻断发给特定进程的 SIGHUP 信号。当退出终端会话时,这可以避免进程退出
nohup command

2.16.4 作业控制2.16.4.1 查看作业
jobs 是作业控制中的关键命令,该命令允许用户查看 shell 当前正在处理的作业
可以使用 jobs 命令的-l 选项(小写字母 l)查看作业的 PID

2.16.4.2 重启已停止的作业
暂停： ^Z
要以后台模式重启作业,可以使用 bg 命令
如果存在多个作业,则需要在 bg 命令后加上作业号

2.16.6 定时运行作业2.16.6.1 使用 at 命令调度作业
at [-f filename] time。适用于计划运行少数几次。

2.16.6.2 调度需要定期运行的脚本
Linux 系统使用 cron 程序调度需要定期执行的作业。cron 在后台运行,并会检查一个特殊的 表(cron 时间表),从中获知已安排执行的作业
cron 时间表通过一种特别的格式指定作业何时运行,其格式如下:minutepasthour hourofday dayofmonth month dayofweek command
cron 时间表允许使用特定值、取值范围(比如 1-5)或者通配符(*)来指定各个字段。
如果想在每天的 10:15 运行一个命令,可以使用如下 cron 时间表字段: 15 10 * * * command
列出已有的 cron 时间表：crontab -l
向cron 时间表添加字段： crontab -e, 然后添加15 10 * * * command
保存并退出编辑器后, cron 会在指定的时间运行命令

]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>reading note</tag>
        <tag>linux</tag>
        <tag>Linux Command Line and Shell Scripting Bible</tag>
      </tags>
  </entry>
  <entry>
    <title>250824 thinking singleton</title>
    <url>/2025/08/24/250824-thinking-singleton/</url>
    <content><![CDATA[1. 什么是单例模式？单例模式（Singleton Pattern）是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点来访问该实例。
2. 为什么需要单例模式？在多线程环境下，我们需要多个线程使用同一份资源。
2.1 为什么不使用全局变量？在一些较为简单的环境中，直接使用一些全局变量供所有线程使用是很好的。
但是，如果这个对象是资源密集型的，使用全局变量会导致资源的浪费。而且，简单的全局变量没有提供访问控制（封装），线程可以任意地访问和修改。
而单例模式就可以实现按需创建实例，避免了资源的浪费。而且提供了类封装，确保不会有意外的修改。
3. 单例模式的实现（go）单例模式尤其要注意线程安全。 sync.Once 确保了实例只被创建一次，避免了多线程环境下的竞态条件。
以下是一个懒加载的版本。
中间件代码：
var once sync.Oncetype singleton struct &#123;&#125;var singleInstance *singletonfunc GetInstance() *singleton &#123;    if singleInstance == nil &#123;        once.Do(            func() &#123;                singleInstance = &amp;singleton&#123;&#125;            &#125;)    &#125;     return singleInstance&#125;

客户端代码：
func main() &#123;    for i := 0; i &lt; 10; i++ &#123;       go func() &#123;           instance := GetInstance() // 每个goroutine都获取到相同的实例       &#125;()    &#125;&#125;



类图：

    classDiagram
    class singleton {
        +GetInstance() singleton
    }
  ]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Interface Oriented Programming</tag>
        <tag>Design Pattern</tag>
        <tag>Singleton Pattern</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>250824 thinking 埃氏筛</title>
    <url>/2025/08/24/250824-thinking-%E5%9F%83%E6%B0%8F%E7%AD%9B/</url>
    <content><![CDATA[埃氏筛是一种简单的筛法，用于求小于等于n的所有质数。
流程Prime(n):    mark i from 2 to n as prime (initial)    for i from 2 to n:            if i is marked as prime:                for j from i^2 to n with step i:                    mark j as not prime    return all marked primes

解释：
为什么是从$i^2$开始标记非质数？
因为如果一个数不是质数，那么它一定有一个小于等于$\sqrt{n}$的质因子。
所以，我们只需要从$i^2$开始标记，因为小于$i^2$的数，一定已经被小于$i$的数标记过了。



]]></content>
      <categories>
        <category>data structure &amp; algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>data structure &amp; algorithm</tag>
        <tag>mathematics</tag>
        <tag>sieve of Eratosthenes</tag>
      </tags>
  </entry>
  <entry>
    <title>250824 thinking 二叉树遍历的迭代法</title>
    <url>/2025/08/24/250824-thinking-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84%E8%BF%AD%E4%BB%A3%E6%B3%95/</url>
    <content><![CDATA[关于二叉树的遍历，有递归法和迭代法两种。递归法简单易懂，但是迭代法较为复杂，需要使用栈来模拟递归的过程。
这里以“将二叉树按某种顺序遍历输出”为例，介绍迭代法的实现。
关键在于理解某个节点输出的时机。
1. 前序遍历
先输出，再将左子节点入栈。没有左子节点了，才考虑右子节点的入栈。

vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; ans;        stack&lt;TreeNode*&gt; stk;        while(!stk.empty() || root!=nullptr)&#123;            while(root!=nullptr)&#123;                ans.push_back(root-&gt;val);                stk.emplace(root);                root=root-&gt;left;            &#125;            root=stk.top()-&gt;right;            stk.pop();        &#125;        return ans;    &#125;

2. 中序遍历
先将左子节点入栈，没有左子节点了，才输出当前节点，然后考虑右子节点的入栈。

vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; ans;        stack&lt;TreeNode*&gt; stk;        while(!stk.empty() || root!=nullptr)&#123;            while(root!=nullptr)&#123;                stk.emplace(root);                root=root-&gt;left;            &#125;            root=stk.top();            stk.pop();            ans.push_back(root-&gt;val);            root=root-&gt;right;        &#125;        return ans;    &#125;

3. 后序遍历
先将左子节点入栈，没有左子节点了，才考虑右子节点的入栈。如果右子节点也没有了，才输出当前节点。


难点：如何判断当前节点的右子节点是否已经遍历过了？


使用一个指针prev来记录上一个遍历的节点。
如果当前节点的右子节点为空，或者右子节点已经遍历过了，才输出当前节点。
否则，将右子节点入栈，然后考虑左子节点的入栈。

vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; ans;        stack&lt;TreeNode*&gt;stk;        TreeNode* prev=nullptr;        while(!stk.empty()||root!=nullptr)&#123;            while(root!=nullptr)&#123;                stk.emplace(root);                root=root-&gt;left;            &#125;            root=stk.top();            if(root-&gt;right==nullptr || root-&gt;right==prev)&#123;                ans.push_back(root-&gt;val);                prev=root;                stk.pop();                root=nullptr; // 这里很重要！否则会因为root不为空而“入栈-出栈”无限循环            &#125;            else&#123;                root=root-&gt;right;            &#125;        &#125;        return ans;    &#125;

]]></content>
      <categories>
        <category>data structure &amp; algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>data structure &amp; algorithm</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>250824 thinking 状压dp</title>
    <url>/2025/08/24/250824-thinking-%E7%8A%B6%E5%8E%8Bdp/</url>
    <content><![CDATA[状压dp使用二进制数来表示状态，将当前已选元素的集合表示为一个二进制数。适用于需要枚举每一种排列进行判断、且最大的$n$有$10&lt;n&lt;20$的题目。状压dp能使得时间复杂度从暴力搜索的$O(n!)$降到$O(n*2^n)$(相邻无关)或者$O(n^2 * 2^n)$(相邻相关)。
若当前表示已选元素的集合的二进制掩码为mask，则；

mask &amp;(1&lt;&lt;i) : 表示第i个元素是否被选择
mask|(1&lt;&lt;i) : 表示将第i个元素加入集合
popcount(mask) : 表示集合中元素的个数

1. 相邻无关当前位置的选择不依赖于前一个位置的选择，只依赖于当前已选元素的集合。
$dp[mask]$表示状态为mask的情况(即已经选择的集合的二进制掩码为mask)下的最优解。
1.1 例题假设有从 1 到 n 的 n 个整数。用这些整数构造一个数组 perm（下标从 1 开始），只要满足下述条件 之一 ，该数组就是一个 优美的排列 ：

perm[i] 能够被 i 整除
i 能够被 perm[i] 整除
1 &lt;&#x3D; n &lt;&#x3D; 15

给你一个整数 n ，返回可以构造的 优美排列 的 数量 。
int countArrangement(int n) &#123;        vector&lt;int&gt; dp(1 &lt;&lt; n, 0);        dp[0] = 1;        for(int m = 0; m &lt; 1 &lt;&lt; n; ++m) &#123;            int l = popcount((unsigned) m);            ++l;            for(int j = 0; j &lt; n; ++j) &#123;                int p = j + 1;                if(!(m &amp; (1&lt;&lt;j)))&#123;                    if((l % p == 0)||(p % l == 0))&#123;                        dp[m | (1&lt;&lt;j)] += dp[m];                     &#125;                &#125;            &#125;        &#125;        return dp.back();    &#125;

2. 相邻相关当前位置的选择不仅依赖于当前已选元素的集合，还依赖于前一个位置的选择。
$dp[mask][i]$表示状态为mask、前一个位置的选择为i的情况下的最优解。
2.1 例题给你一个下标从 0 开始的整数数组 nums ，它包含 n 个 互不相同 的正整数。如果 nums 的一个排列满足以下条件，我们称它是一个特别的排列：

对于 0 &lt;&#x3D; i &lt; n - 1 的下标 i ，要么 nums[i] % nums[i+1] &#x3D;&#x3D; 0 ，要么 nums[i+1] % nums[i] &#x3D;&#x3D; 0 。
2 &lt;&#x3D; nums.length &lt;&#x3D; 14
1 &lt;&#x3D; nums[i] &lt;&#x3D; 1e9

请你返回特别排列的总数目。由于答案可能很大，请将它对 $10^9 + 7$ 取余后返回。
int specialPerm(vector&lt;int&gt;&amp; nums) &#123;        const int mod = 1e9+7;        int n=nums.size();        vector&lt;vector&lt;int&gt;&gt;dp(1&lt;&lt;n,vector&lt;int&gt;(n,0));        for(int i=0;i&lt;n;++i)&#123;            dp[1&lt;&lt;i][i]=1;        &#125;        for(int m=0;m&lt;1&lt;&lt;n;++m)&#123;            for(int i=0;i&lt;n;++i)&#123;                if(m &amp; (1&lt;&lt;i))&#123;                    for(int j=0;j&lt;n;++j)&#123;                        if(!(m&amp;(1&lt;&lt;j)))&#123;                            if((nums[i]%nums[j]==0)||(nums[j]%nums[i]==0))&#123;                                dp[m|(1&lt;&lt;j)][j]=(dp[m|(1&lt;&lt;j)][j] + dp[m][i])%mod;                            &#125;                        &#125;                    &#125;                &#125;            &#125;        &#125;        int ans=0;        for(int i=0;i&lt;n;++i)&#123;            ans=(ans+dp[(1&lt;&lt;n)-1][i])%mod;        &#125;        return ans;    &#125;]]></content>
      <categories>
        <category>data structure &amp; algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>data structure &amp; algorithm</tag>
        <tag>dynamic programming</tag>
        <tag>state compression</tag>
      </tags>
  </entry>
  <entry>
    <title>250824 thinking 快速排序</title>
    <url>/2025/08/25/250824-thinking-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[快速排序的Hoare分区法的基本思想与流程是简单明晰的，但是有很多细节需要注意，例如是左指针先动还是右指针先动、指针移动条件等。稍有不慎，就可能甚至导致死循环。
1. 伪代码示例这里是从小到大的顺序排序。
// input: arr, lo, hi// arr: array to be sorted// lo, hi: the area to be sorted is [lo, hi)// output: sorted arrQuickSort(arr, lo, hi):    if lo &gt;= hi:         return // in this case, no element left in the area, no need to sort    pivot := arr[lo]    left := lo    right := hi    while left &lt; right; do        do            right--        while arr[right] &gt; pivot // right pointer moves to the left until it points to an element smaller than pivot or points to pivot, so right pointer is always safe        do            left++        while left &lt; right and arr[left] &lt; pivot // but left pointer could overflow if there is no control, so it should always be checked with left &lt; right        if left &lt; right; then            swap(arr[left], arr[right])        else             break        end if    end while    swap(arr[lo], arr[right])     QuickSort(arr, lo, right)    QuickSort(arr, right + 1, hi)

2. 解释2.1 左右指针移动的顺序为什么是先右后左？考虑一个例子：[1, 3, 4, 5, 7], 以1为基准进行分区。如果先左后右，则左指针在3处就会停下。然后右指针移动，由于左指针挡着，它便只能移动到3这里，而不是正确的位置1。这时候如果交换3和1，则3的位置就被错误地交换了。
2.2 为什么循环退出后交换时将pivot和right进行交换而不是left？因为right指针移动的条件是arr[right] &gt; pivot，也就是说当它不移动时候，一定是arr[right]&lt;=pivot。而left指针移动的条件是left &lt; right &amp;&amp; arr[left] &lt; pivot，当循环退出时，我们不能保证一定有arr[left]&gt;=pivot，因为有可能是left &lt; right条件不满足导致的退出。而pivot所指代的元素在最左边，与右边的一个不大于它的元素交换是安全的。 
2.3 指针移动条件为什么不带”&#x3D;”?这是由left和right的语义所决定的。left是“在pivot的左边”，而right是“在pivot的右边”。
]]></content>
      <categories>
        <category>data structure &amp; algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>data structure &amp; algorithm</tag>
        <tag>quick sort</tag>
        <tag>Hoare partition</tag>
      </tags>
  </entry>
  <entry>
    <title>250926 thinking 反悔堆</title>
    <url>/2025/09/26/250926-thinking-%E5%8F%8D%E6%82%94%E5%A0%86/</url>
    <content><![CDATA[反悔是贪心的一种策略，用于在当前可能不是全局最优解时，“反思”已做过的选择。
而对于这样的策略，常使用堆来辅助实现。具体来说就是将已做的选择按照某种规则放入最大堆中。“反悔”就是“撤销”堆顶的选择，即代价最大的选择。
用最大堆在约束触发时“撤销&#x2F;替换”当前集合里最差的那个已选项。
1. 示例LCP30. 魔塔游戏
magicTower(nums[0..n-1], hp)&#123;    declare a empty max heap, named heap.    ans := 0    for num in nums; do        if num &lt; 0; then            heap.push(num) // push the negative number into the heap, so that we can recover the choice later if needed        fi        hp += num        if hp &lt;= 0; then            if heap.isEmpty(); then //cannot recover                return -1            fi            ans++            hp -= heap.pop() // recover the smallest negative number, namely the most costly choice        fi    end    return ans&#125;]]></content>
      <categories>
        <category>data structure &amp; algorithm</category>
      </categories>
      <tags>
        <tag>data structure &amp; algorithm</tag>
        <tag>greedy</tag>
        <tag>heap</tag>
        <tag>rollback</tag>
      </tags>
  </entry>
  <entry>
    <title>250926 thinking 差分</title>
    <url>/2025/09/26/250926-thinking-%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[1. 简介对于一个数组a，构造的这样的一个数组d称为a的差分数组：

d[i] =
\begin{cases}
0, & \text{if } i = 0 \\
a[i] - a[i-1], & \text{otherwise}
\end{cases}


2. 性质
对d构造前缀和数组得到a
对于a的一个下标区间[i,j)对应的元素统一加上一个数c后，则对应的d的变化为：d[i](now)=&gt;d[i](prev)+c d[j](now)=&gt;d[j](prev)-c。

也就是说，差分数组的构造可以将一个区间的变化映射为两个元素的变化。

在实际操作时，还要注意j&#x3D;&#x3D;a.length，此时超出d索引范围（因为在前面的构造中d.length&#x3D;&#x3D;a.length）。因此为了方便，通常让d.length&#x3D;a.length+1，即设置一个dummy。

3. 例题3355.零数组变换I
go参考解法：（by 灵神）
func isZeroArray(nums []int, queries [][]int) bool &#123;	diff := make([]int, len(nums)+1)	for _, q := range queries &#123;		diff[q[0]]++		diff[q[1]+1]--	&#125;	sumD := 0	for i, x := range nums &#123;		sumD += diff[i]		// 此时 sumD 表示 x=nums[i] 要减掉多少		if x &gt; sumD &#123; // x 无法变成 0			return false		&#125;	&#125;	return true&#125;]]></content>
      <categories>
        <category>data structure &amp; algorithm</category>
      </categories>
      <tags>
        <tag>data structure &amp; algorithm</tag>
        <tag>go</tag>
        <tag>difference</tag>
      </tags>
  </entry>
  <entry>
    <title>250926 thinking 翻转链表</title>
    <url>/2025/09/26/250926-thinking-%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[1. 操作以这道题为实例。
对链表的某一部分进行翻转时，需要记录以下这几个节点：

p0: 发生翻转区域的前置节点，这个是为了区域翻转后的连接（循环结束，p0.next为翻转后区间的最后一个元素）。为了统一处理（因为原链表有的翻转区域没有前置节点），先构造dummy=ListNode&#123;next: head&#125;。这样的话，翻转后的链表的头节点即为dummy.next。p0可能为dummy。
cur: 当前遍历到的节点，循环结束，cur为区域后的第一个元素
pre: 当前遍历到的节点的原链表中的上一个节点，在翻转后就是next。在最初翻转前为nullptr,循环结束，pre为翻转后的区域的第一个元素
nxt: 当前遍历到的节点的原链表中的下一个节点，下一个cur，在翻转后它的next就是pre。

操作如下：
cur := p0.nextpre := nullptrfor cur in area; do    nxt := cur.next    cur.next = pre    pre = cur    cur = nxtend loop// one loop only change one &quot;next&quot;// end loop, cur is next node for this area at the timep0.next.next=cur // set next pointer of the reversed area&#x27;s last node  p0.next=pre // previous node&#x27;s next pointer points to the first node 

2. 例题25.k个一组翻转链表
这个题的有一个关键：找到每一个翻转区间的p0。它实际就是上一个区间未翻转时的第一个节点。
go示例解法
/** * Definition for singly-linked list. * type ListNode struct &#123; *     Val int *     Next *ListNode * &#125; */func reverseKGroup(head *ListNode, k int) *ListNode &#123;    cnt := 0    for p:=head;p!=nil;p=p.Next&#123;        cnt++    &#125;    dummy := &amp;ListNode&#123;0,head&#125;    p0 := dummy    for ; cnt&gt;=k ; cnt-=k &#123;        cur := p0.Next        var pre *ListNode        nextp := p0.Next        for i:=0;i&lt;k;i++&#123;            nxt := cur.Next            cur.Next = pre            pre = cur            cur = nxt        &#125;        p0.Next.Next=cur        p0.Next = pre        p0=nextp    &#125;     return dummy.Next&#125;
]]></content>
      <categories>
        <category>data structure &amp; algorithm</category>
      </categories>
      <tags>
        <tag>data structure &amp; algorithm</tag>
        <tag>go</tag>
        <tag>linkList</tag>
      </tags>
  </entry>
  <entry>
    <title>251012 record best-time-to-buy-and-sell-stock</title>
    <url>/2025/10/12/251012-record-best-time-to-buy-and-sell-stock/</url>
    <content><![CDATA[题目
int maxProfit(vector&lt;int&gt;&amp; prices) &#123;    int lo = prices[0]    int ans = 0    for(int i=1;i&lt;prices.size();i++)&#123;        ans = max(ans,prices[i]-lo)        lo = min(lo,prices[i])    &#125;    return ans&#125;

这个模板可以用于：寻找不单增数组的元素与该元素前面的所有元素之差的最大值。
]]></content>
      <categories>
        <category>record</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Record</tag>
      </tags>
  </entry>
  <entry>
    <title>250926 thinking 0-1背包dp</title>
    <url>/2025/09/26/250926-thinking-0-1%E8%83%8C%E5%8C%85dp/</url>
    <content><![CDATA[本文的内容是0-1背包的空间优化、倒序遍历，以及至多&#x2F;恰好&#x2F;至少变体。一些基本概念不再赘述。
1. 空间优化由于它的递推表达式：
$$dp[i][c] &#x3D; \max{, dp[i-1][c],; dp[i-1][c-w[i]] + v[i] ,}$$
dp[i][c]: 遍历到第 i 个物品时，若总容量为 c 时能获得的最大价值
可以发现每次更新值时，都是 i-1 更新 i 的，所以完全可以写为：
$$dp[c] &#x3D; \max{, dp[c],; dp[c-w[i]] + v[i] ,}$$
2. 倒序遍历在使用一维数组进行空间优化时，容量 c 必须“倒序遍历”（从最大容量 C 递减到 w[i]）。
Why?

若正序遍历（c 从小到大），在同一轮 i 的更新中，dp[c-w[i]] 已经被本轮 i 更新过，会导致同一物品 i 被复用多次，等价成“完全背包”的效果；
倒序遍历能保证本轮计算依赖的是“上一轮 i-1 的结果”，从而保持 0-1 约束。

更形式化的解释：维护不变式“在处理物品 i 时，所有用于计算的 dp[*] 均来自 i-1 的状态”。倒序使得 dp[c-w[i]] 在本轮尚未更新，仍是 i-1 的值。
一个反例（正序导致复用）：容量 c = w[i] 更新了 dp[w[i]]，随后 c = 2*w[i] 又读到刚更新过的 dp[w[i]]，把 i 用了两次。
3. 初始化与变体根据目标约束不同，dp 的初始化与转移边界需要调整：

0-1 背包（至多容量 C）：

初始化：dp[0..C] = 0；
转移：倒序 for c = C..w[i]，dp[c] = max(dp[c], dp[c - w[i]] + v[i])；
结果：max(dp[0..C])，常规题通常取 dp[C]。


恰好容量的方案数（计数问题）：

目标：选择若干件物品使总容量恰好为 C 的子集数（不计顺序）。
初始化：dp[0] = 1，其余 dp[1..C] = 0；
转移（倒序）：dp[c] += dp[c - w[i]]；
注意：倒序是 0-1 语义（每件物品至多用一次）；若写成正序会变成“序列计数&#x2F;可重复使用”，语义错误。


至少容量（at least C）：

两种做法：
把答案定义为达到“任意 c &gt;&#x3D; C”的最大价值，遍历所有 c&gt;&#x3D;C 的 dp；
通过容量截断&#x2F;偏移构造辅助数组（如果题目有额外结构，有时更高效）。


常见实现：仍按至多容量的转移，最终取 max(dp[C..C_max])。



4. 例题3685. 含上限元素的子序列和

对 nums 升序排序，分层处理“值为 x 的元素”。这样当我们处理到 x 时，dp 中包含了“所有小于等于 x 的原始元素”的子集和可达性。 维护一个布尔 bitset dp，dp[s]&#x3D;1 表示和 s 可达；插入一个值 v 时做 dp |&#x3D; (dp &lt;&lt; v)。大于 x 的元素都被 cap 成 x，剩余数量 remain &#x3D; n - cur。检查是否存在 0 ≤ i ≤ min(remain, ⌊k&#x2F;x⌋) 使得 dp[k - i*x] 为真。

func subsequenceSumAfterCapping(nums []int, k int) []bool &#123;	slices.Sort(nums)	n := len(nums)	ans := make([]bool, n)	// f[s]==1 表示和 s 可达	f := big.NewInt(1)	// 掩码 u = (1&lt;&lt;(k+1)) - 1，确保位长 &lt;= k+1	u := new(big.Int).Lsh(big.NewInt(1), uint(k+1))	u.Sub(u, big.NewInt(1))	// 复用一个临时 big.Int，避免每次 new（微优化）	var t big.Int	i := 0	for x := 1; x &lt;= n; x++ &#123;		// 插入所有值等于 x 的原始元素：f |= f &lt;&lt; x		for i &lt; n &amp;&amp; nums[i] == x &#123;			t.Lsh(f, uint(nums[i])) // t = f &lt;&lt; v			f.Or(f, &amp;t)             // f |= t			f.And(f, u)             // 截断到 k+1 位			i++		&#125;		// 大于 x 的部分都被 cap 成 x，最多还能取 j = min(n-i, k/x) 个		limit := n - i		if k/x &lt; limit &#123;			limit = k / x		&#125;		ok := false		for j := 0; j &lt;= limit; j++ &#123;			// target &gt;= 0 恒成立，因为 j &lt;= k/x			if f.Bit(k-j*x) == 1 &#123;				ok = true				break			&#125;		&#125;		ans[x-1] = ok	&#125;	return ans&#125;






]]></content>
      <categories>
        <category>data structure &amp; algorithm</category>
      </categories>
      <tags>
        <tag>data structure &amp; algorithm</tag>
        <tag>go</tag>
        <tag>dynamic programming</tag>
        <tag>0-1 bag dp</tag>
      </tags>
  </entry>
  <entry>
    <title>250928-251005 weekly electron</title>
    <url>/2025/10/05/250928-251005-weekly-electron/</url>
    <content><![CDATA[尝试使用electron将React生成的静态网页打包成桌面应用。
0. 项目结构静态网页资源dist应先移动到application项目中。
.├── application│   ├── package.json│   └── main.js├── dist|    └── index.html└── web    ├── package.json    ├── vite.config.js    ├── src       ├── App.jsx       └── components           └── Navigation.jsx   

1. 项目初始化与安装参考：教程
但是在安装时出现问题，是网络的原因。运行以下命令后安装，解决：
npm config set registry https://registry.npmmirror.com; $env:ELECTRON_MIRROR = &quot;https://npmmirror.com/mirrors/electron/&quot;

后面运行命令出现网络问题也如此。
2. 打包对web项目使用npm run build后生成的静态网页进行打包。
但需要注意：

Vite 的构建产物默认使用以 “&#x2F;” 开头的资源路径（如 &#x2F;assets&#x2F;…），在 Electron 以 file:&#x2F;&#x2F; 加载本地文件时，这种绝对路径会解析到磁盘根目录。因此应该改为：

// vite.config.jsimport &#123; defineConfig &#125; from &#x27;vite&#x27;import react from &#x27;@vitejs/plugin-react&#x27;// https://vite.dev/config/export default defineConfig(&#123;  plugins: [react()],  base: &#x27;./&#x27;,&#125;)


在application项目中，文件加载路径的写法。

const &#123; app, BrowserWindow &#125; = require(&#x27;electron/main&#x27;)const path = require(&#x27;path&#x27;)const createWindow = () =&gt; &#123;  const win = new BrowserWindow(&#123;    width: 800,    height: 600  &#125;)    win.loadFile(path.join(__dirname, &#x27;..&#x27;, &#x27;dist&#x27;, &#x27;index.html&#x27;));&#125;app.whenReady().then(() =&gt; &#123;  createWindow()  app.on(&#x27;activate&#x27;, () =&gt; &#123;    if (BrowserWindow.getAllWindows().length === 0) &#123;      createWindow()    &#125;  &#125;)&#125;)app.on(&#x27;window-all-closed&#x27;, () =&gt; &#123;  if (process.platform !== &#x27;darwin&#x27;) &#123;    app.quit()  &#125;&#125;)

但即使是这样，路由也会出现问题。发现是由于src源文件中React Router没有配置好。
更新后的src&#x2F;App.jsx:
import &#123; BrowserRouter, HashRouter, Routes, Route &#125; from &#x27;react-router-dom&#x27;import &#123; Container &#125; from &#x27;react-bootstrap&#x27;import Navigation from &#x27;./components/Navigation&#x27;import Home from &#x27;./pages/Home&#x27;import Books from &#x27;./pages/Books&#x27;import Borrowings from &#x27;./pages/Borrowings&#x27;import &#x27;bootstrap/dist/css/bootstrap.min.css&#x27;import &#x27;./App.css&#x27;const RouterComponent = window.location.protocol === &#x27;file:&#x27; ? HashRouter : BrowserRouterfunction App() &#123;  return (    &lt;RouterComponent&gt;      &lt;Navigation /&gt;      &lt;Container className=&quot;mt-3&quot;&gt;        &lt;Routes&gt;          &lt;Route path=&quot;/&quot; element=&#123;&lt;Home /&gt;&#125; /&gt;          &lt;Route path=&quot;/books&quot; element=&#123;&lt;Books /&gt;&#125; /&gt;          &lt;Route path=&quot;/borrowings&quot; element=&#123;&lt;Borrowings /&gt;&#125; /&gt;        &lt;/Routes&gt;      &lt;/Container&gt;    &lt;/RouterComponent&gt;  )&#125;export default App

同时在Navigation组件中，注意LinkContainer 包裹品牌区，避免 file:&#x2F;&#x2F; 下 href&#x3D;”&#x2F;“ 的问题。
import &#123; Navbar, Nav, Container &#125; from &#x27;react-bootstrap&#x27;import &#123; LinkContainer &#125; from &#x27;react-router-bootstrap&#x27;function Navigation() &#123;  return (    &lt;Navbar bg=&quot;dark&quot; variant=&quot;dark&quot; expand=&quot;lg&quot;&gt;      &lt;Container&gt;        &lt;LinkContainer to=&quot;/&quot;&gt;          &lt;Navbar.Brand&gt;图书管理系统&lt;/Navbar.Brand&gt;        &lt;/LinkContainer&gt;        &lt;Navbar.Toggle aria-controls=&quot;basic-navbar-nav&quot; /&gt;        &lt;Navbar.Collapse id=&quot;basic-navbar-nav&quot;&gt;          &lt;Nav className=&quot;me-auto&quot;&gt;            &lt;LinkContainer to=&quot;/&quot;&gt;              &lt;Nav.Link&gt;首页&lt;/Nav.Link&gt;            &lt;/LinkContainer&gt;            &lt;LinkContainer to=&quot;/books&quot;&gt;              &lt;Nav.Link&gt;图书管理&lt;/Nav.Link&gt;            &lt;/LinkContainer&gt;            &lt;LinkContainer to=&quot;/borrowings&quot;&gt;              &lt;Nav.Link&gt;借阅管理&lt;/Nav.Link&gt;            &lt;/LinkContainer&gt;          &lt;/Nav&gt;        &lt;/Navbar.Collapse&gt;      &lt;/Container&gt;    &lt;/Navbar&gt;  )&#125;export default Navigation

再重新npm run build生成静态网页, 并将dist目录移动到application项目中。
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>electron</tag>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>250926 thinking 子序列判断</title>
    <url>/2025/09/26/250926-thinking-%E5%AD%90%E5%BA%8F%E5%88%97%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[1. 介绍引例：有一个字符串t。现有若干字符集合$s_i$，需要判断对于每一个$s_i$，它的每一个元素是否在t中出现。
一种方式是，对于t中的所有字符建立一个map。然后对于一个$s_i$中的每一个元素c，若map[c]都判断为存在，则$s_i$的每一个元素都在t中出现，否则不是。
现在将问题换为“有一个字符串t。现有一个字符串集合$s$，需要判断对于每一个元素$e_i$，它是否是t的子序列。”
这个时候，不仅仅要考虑字符的存在与否了，还要考虑字符之间的相对位置关系。
比方说，t=aaabbb，e=ba。判断e是否是t的子序列时，我们还要判断在t的b后面的元素中是否还有a。
我们使用的map得能够“屏蔽”在t的某个元素前面的所有元素的存在性。
于是使用nxt，nxt[i][c]: t中下标不小于i的元素中出现c的最小下标。
2. 解释将nxt[t.length][c]初始化一个很大的值BIG，作为判断存在依据。
其他nxt[i][c]构建：
for i in t.length-1 to 0; do    copy nxt[i+1] to nxt[i]    nxt[i][t[i]] = iend loop

对于一个字符串$e_i$判断:
idx := 0for c in e_i; do    idx = nxt[idx][c]    if idx == BIG; then        c does not exist in t[idx:]=&gt; e_i is not a substring of t.    else         idx++ # for next search should begin at idx+1    fiend loop

3. 例题匹配子序列的单词数
给出go的解法示例
func numMatchingSubseq(s string, words []string) int &#123;    nxt := make([][26]int,len(s)+1)    for i := range nxt[len(s)]&#123;        nxt[len(s)][i] = 2147483647    &#125;    for i:=len(s)-1;i&gt;=0;i--&#123;        nxt[i] = nxt[i+1] //nxt是数组的slice,nxt[i]是数组类型。数组是值类型，可以直接这样赋值        nxt[i][s[i]-&#x27;a&#x27;]=i    &#125;    ans := 0    for _,str := range words&#123;        idx := 0        for _,c := range str&#123;            idx = nxt[idx][c-&#x27;a&#x27;]            if(idx==2147483647)&#123;                ans--                break            &#125;            idx++        &#125;        ans++    &#125;    return ans&#125;
]]></content>
      <categories>
        <category>data structure &amp; algorithm</category>
      </categories>
      <tags>
        <tag>data structure &amp; algorithm</tag>
        <tag>go</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>251003 thinking factory method&amp; abstract factory</title>
    <url>/2025/10/03/251003-thinking-factory-method-abstract-factory/</url>
    <content><![CDATA[1. 工厂方法以点菜为例。
type dish interface&#123; Cook() &#125;type pizza struct&#123;&#125;type burger struct&#123;&#125;func (*pizza) Cook() &#123;  &#125;func (*burger) Cook() &#123;  &#125;

若不用工厂方法，则客户端直连产品，新增产品要改分支，不符合开闭原则。
func orderDish(typeName string) dish &#123;    switch typeName &#123;    case &quot;pizza&quot;:        d := &amp;pizza&#123;&#125;        d.Cook() // &quot;cook pizza&quot;        return d    case &quot;burger&quot;:        d := &amp;burger&#123;&#125;        d.Cook() // &quot;cook burger&quot;        return d    default:        return nil    &#125;&#125;
而使用工厂方法后，客户端只依赖抽象工厂，新增产品时只需要新增具体工厂即可，符合开闭原则。
即，把“怎么做菜”的细节从用户（软件开发程序员）手里拿走，交给各自的工厂（中间件）。
type Factory interface &#123;    Create() dish&#125;type PizzaFactory struct&#123;&#125;func (PizzaFactory) Create() dish &#123; return &amp;pizza&#123;&#125; &#125;type BurgerFactory struct&#123;&#125;func (BurgerFactory) Create() dish &#123; return &amp;burger&#123;&#125; &#125;func order(factory Factory) dish &#123;    d := factory.Create()    d.Cook()     return d&#125;

这样的话，新增产品时只需要新增产品 + 工厂即可，无需修改用户程序。符合开闭原则。
type sushi struct&#123;&#125;func (s *sushi) Cook() &#123;  &#125;type SushiFactory struct&#123;&#125;func (SushiFactory) Create() dish &#123; return &amp;sushi&#123;&#125; &#125;

客户端只依赖抽象工厂，只需调用工厂方法即可，不用修改。
类图：

    classDiagram
  class Dish {
    +Cook() 
  }
  class Pizza {
    +Cook() 
  }
  class Burger {
    +Cook() 
  }
  Dish &lt;|.. Pizza
  Dish &lt;|.. Burger

  class Factory {
    +Create() Dish
  }
  class PizzaFactory
  class BurgerFactory
  Factory &lt;|.. PizzaFactory
  Factory &lt;|.. BurgerFactory

  Factory ..&gt; Dish : Create()
  

2. 抽象工厂场景：套餐由两个相关组件组成（菜 Dish + 饮料 Drink），同一风格的组件应该一起创建并保持搭配一致（意式：Pizza+Coffee，美式：Burger+Cola）。
// 产品族接口type dish interface&#123; Cook() &#125;type drink interface&#123; Serve() &#125;// 具体产品type pizza struct&#123;&#125;func (*pizza) Cook() &#123;  &#125;type burger struct&#123;&#125;func (*burger) Cook() &#123;  &#125;type coffee struct&#123;&#125;func (coffee) Serve() &#123;  &#125;type cola struct&#123;&#125;func (cola) Serve() &#123;  &#125;    

抽象工厂提供“同时创建多个相关产品”的统一接口，客户端只选择工厂（风格），不再传字符串。
中间件：工厂方法的“实现”，负责创建具体产品。
// 抽象工厂：一次创建同一风格的多个相关产品type kitchenFactory interface &#123;    CreateDish() dish    CreateDrink() drink&#125;// 具体工厂：意式（Pizza + Coffee）type italianFactory struct&#123;&#125;func (italianFactory) CreateDish() dish   &#123; return &amp;pizza&#123;&#125; &#125;func (italianFactory) CreateDrink() drink &#123; return &amp;coffee&#123;&#125; &#125;// 具体工厂：美式（Burger + Cola）type americanFactory struct&#123;&#125;func (americanFactory) CreateDish() dish   &#123; return &amp;burger&#123;&#125; &#125;func (americanFactory) CreateDrink() drink &#123; return &amp;cola&#123;&#125; &#125;

用户只需要依赖抽象工厂，无需知道具体产品。
func orderSet(f kitchenFactory) (dish, drink) &#123;    d := f.CreateDish()    d.Cook()    r := f.CreateDrink()    r.Serve()    return d, r&#125;

类图：

    classDiagram
class dish {
+Cook()
}
class drink {
+Serve()
}

class pizza {
+Cook()
}
class burger {
+Cook()
}
class coffee {
+Serve()
}
class cola {
+Serve()
}

dish &lt;|.. pizza
dish &lt;|.. burger
drink &lt;|.. coffee
drink &lt;|.. cola

class kitchenFactory {
+CreateDish() dish
+CreateDrink() drink
}
class italianFactory
class americanFactory

kitchenFactory &lt;|.. italianFactory
kitchenFactory &lt;|.. americanFactory

italianFactory ..&gt; dish : CreateDish()
italianFactory ..&gt; drink : CreateDrink()
americanFactory ..&gt; dish : CreateDish()
americanFactory ..&gt; drink : CreateDrink()
  




客户端不写 switch、不传 “pizza&#x2F;burger” 字符串；只选风格工厂（Italian&#x2F;American）。
搭配关系由工厂保证，防止“风格混搭”造成业务不一致。
扩展新风格时，仅新增“具体工厂 + 其产品”，保持开闭原则。

]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Interface Oriented Programming</tag>
        <tag>Design Pattern</tag>
        <tag>go</tag>
        <tag>Factory Method</tag>
        <tag>Abstract Factory</tag>
      </tags>
  </entry>
  <entry>
    <title>250824 thinking Trie</title>
    <url>/2025/08/24/250824-thinking-Trie/</url>
    <content><![CDATA[字典树（Trie）是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。每个节点有26个子节点，子节点的序号分别代表26个字母。因此，从根节点到某个节点的路径表示一个字符串。有时候，每个节点会有一个标记，用于表示是否为一个字符串的结束。如果一个节点的标记为true，那么从根节点到该节点的路径表示的字符串就是一个单词。
C++示例以下是一个简单的C++实现，支持插入、搜索和前缀搜索。
class Node &#123;public:    int end;    vector&lt;unique_ptr&lt;Node&gt;&gt; son;    Node():end(0),son(26)&#123;&#125;;&#125;;class Trie &#123;public:    unique_ptr&lt;Node&gt; root;    Trie() &#123;        root=make_unique&lt;Node&gt;();    &#125;        void insert(string word) &#123;        Node* cur=root.get();        for(auto chr: word)&#123;            if(cur-&gt;son[chr-&#x27;a&#x27;]==nullptr)                cur-&gt;son[chr-&#x27;a&#x27;]=make_unique&lt;Node&gt;();            cur=cur-&gt;son[chr-&#x27;a&#x27;].get();        &#125;        cur-&gt;end=1;    &#125;        bool search(string word) &#123;        Node* cur = root.get();        for (char c : word) &#123;            c -= &#x27;a&#x27;;            if (cur-&gt;son[c] == nullptr) &#123;                 return false;            &#125;            cur = cur-&gt;son[c].get();        &#125;        return cur-&gt;end==1;    &#125;        bool startsWith(string prefix) &#123;        Node* cur = root.get();        for (char c : prefix) &#123;            c -= &#x27;a&#x27;;            if (cur-&gt;son[c] == nullptr) &#123;                 return false;            &#125;            cur = cur-&gt;son[c].get();        &#125;        return true;    &#125;&#125;;
]]></content>
      <categories>
        <category>data structure &amp; algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>data structure &amp; algorithm</tag>
        <tag>string</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>251006-251012 weekly Qt</title>
    <url>/2025/10/12/251006-251012-weekly-Qt/</url>
    <content><![CDATA[最近在做一个简单的桌宠，以下记录我对C++ Qt的一些理解。
我认为，一个Qt应用主要围绕两大块：同步的UI初始化与异步的事件循环。
1. 同步的UI初始化Qt 窗口（或任何 QWidget）的生命周期始于其构造函数。在这里，我们以常规的、同步的方式完成所有UI布局和初始属性设置。这部分代码会一次性执行完毕，构建出窗口的静态初始外观。用时可以忽略不计。
需要延时触发&#x2F;用户事件驱动的部分就需要Qt特别的事件处理机制————信号与槽来实现。
2. 异步的事件循环静态的UI只有在响应外部变化（如用户点击、网络数据到达、定时器触发）时才具有生命力。Qt 通过一个持续运行的事件循环 (Event Loop) 来管理这一切。
程序在完成同步初始化后，会交出控制权给事件循环。事件循环负责监听各种事件源，并将它们派发给相应的对象。而信号与槽 (Signals &amp; Slots) 机制，正是 Qt 对这种异步模型优雅、类型安全的封装。

信号Signal：当某个对象的状态发生改变（如 QPushButton 被点击），它会 emit 一个信号。信号本身不关心谁会接收它。
槽Slot：一个普通的成员函数，用于响应信号。当它与一个信号 connect 后，一旦信号发出，这个槽函数就会被事件循环调度执行。
默认情况下：信号与槽是“同步的”。

整个流程是：事件发生 → 对象发射信号 → 事件循环 → 调度已连接的槽函数执行。
2.1. 定时触发QTimer是Qt提供的一个定时器类，在其线程的事件循环中定期投递 timeout 事件，随后触发信号。
它是体现事件驱动的绝佳例子。
它不在当前代码流里“等待”，而是向事件循环注册一个未来的任务。
可以利用QTimer以及timeout信号来实现定时触发事件。
以下代码并不会阻塞，start() 只是告诉事件循环“请每隔1000毫秒，帮我把 timer 的 timeout 信号发出来”。
QTimer *timer = new QTimer(this);connect(timer, &amp;QTimer::timeout, this, &amp;MyClass::onTimeout);timer-&gt;start(1000); // 非阻塞，立即返回


2.2. 单次延时触发QTimer::singleShot 是一个更便捷的静态函数，它请求事件循环“在1000毫秒后，帮我执行一次这个 Lambda 函数”。这对于实现“稍后执行”的逻辑非常有用。
QTimer::singleShot(1000, this, [this]()&#123;    // 这部分代码将在 1 秒后由事件循环调用&#125;);

通过这种方式，复杂的异步逻辑被分解为一系列由事件驱动的、简短的槽函数调用，避免了回调地狱，也让代码结构保持清晰。
之后遇到了需要QThread的时候再介绍Qt的线程~
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Projects</tag>
        <tag>C++</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>251012 thinking reflect</title>
    <url>/2025/10/12/251012-thinking-reflect/</url>
    <content><![CDATA[最近在用 Gin&#x2F;GORM 尝试写一个后端。受 PostgREST 的启发，我想实现一个更通用的后端：它能运行时自动查询数据库的表结构，并动态生成对应的模型 (Model) 和控制器 (Controller)，从而免去为每张表手动编写重复代码的麻烦。
Go 的反射 (Reflection) 机制是实现这一目标的关键。它允许程序在运行时检查自身的结构、类型和值。
本篇将介绍 Go 反射的核心思想，并演示如何利用它在运行时动态构建新的结构体类型。
1. 反射的核心：Type 与 ValueGo 的反射机制建立在两个核心概念之上：reflect.Type 和 reflect.Value。
可以把任意变量看作一个“箱子”，箱子里装着实际的数据。

**reflect.Type**：是箱子的“标签”，告诉你里面装的是什么类型的东西（比如 int, string, struct）。
**reflect.Value**：是箱子里的“东西本身”，你可以读取它的值，甚至在满足特定条件时修改它。

我们通过 reflect.TypeOf() 和 reflect.ValueOf() 这两个函数进入反射的世界：
var x float64 = 3.4t := reflect.TypeOf(x)   // 获取 Typev := reflect.ValueOf(x)  // 获取 Valuefmt.Println(&quot;type:&quot;, t)                  // 输出: type: float64fmt.Println(&quot;value:&quot;, v.Float())         // 输出: value: 3.4fmt.Println(&quot;kind is float64:&quot;, t.Kind() == reflect.Float64) // 输出: kind is float64: true

2. 修改值：地址与 Elem()反射不仅能看，还能改。但有一个前提：**值必须是“可设置的” (settable)**。
一个 reflect.Value 是可设置的，当且仅当它代表的是一个可寻址的内存空间。简单来说，如果你对一个指针进行反射，那么指针指向的那块内存就是可设置的。
我们通过 Elem() 方法来获取指针指向的值。
var x float64 = 3.4p := &amp;x // p 是指向 x 的指针v := reflect.ValueOf(p) // 对指针进行反射// v 现在代表指针 p，它是不可设置的。但它指向的 x 是可设置的。// 使用 Elem() 获取指针指向的值e := v.Elem()e.SetFloat(7.1) // 修改 x 的值fmt.Println(x) // 输出: 7.1

小结：要通过反射修改一个变量，通常需要对该变量的指针进行反射，然后调用 Elem() 获取其指向的值，再进行修改。
3. 终极目标：运行时创建结构体现在回到最初的目标：根据数据库表结构动态创建模型。这需要我们在运行时动态地“拼凑”出一个新的结构体类型。
Go 的 reflect 包提供了 reflect.StructOf 函数来实现这一功能。步骤如下：

定义字段：为新结构体的每个字段创建一个 reflect.StructField。每个字段需要名字、类型 (reflect.Type) 和可选的标签 (Tag)，标签对于 JSON 或 GORM 序列化至关重要。
创建结构体类型：将定义好的字段切片传入 reflect.StructOf()，得到一个全新的结构体 reflect.Type。
创建实例：使用 reflect.New() 并传入新的类型，来创建一个指向该结构体新实例的指针 (reflect.Value)。
设置字段值：通过 Elem() 和 Field() 方法，为新实例的字段赋值。

示例：动态创建一个 User 结构体假设我们要动态创建一个等价于下面代码的类型：
type User struct &#123;    Name string `json:&quot;name&quot;`    Age  int    `json:&quot;age&quot;`&#125;

使用反射的代码如下：
package mainimport (	&quot;encoding/json&quot;	&quot;fmt&quot;	&quot;reflect&quot;)func main() &#123;	// 1. 定义字段	fields := []reflect.StructField&#123;		&#123;			Name: &quot;Name&quot;,			Type: reflect.TypeOf(&quot;&quot;), // string 类型			Tag:  `json:&quot;name&quot;`,		&#125;,		&#123;			Name: &quot;Age&quot;,			Type: reflect.TypeOf(0), // int 类型			Tag:  `json:&quot;age&quot;`,		&#125;,	&#125;	// 2. 创建结构体类型	structType := reflect.StructOf(fields)	// 3. 创建实例 (返回一个指向新结构体的指针)	structPtr := reflect.New(structType)	// 4. 获取指针指向的结构体并设置字段值	s := structPtr.Elem()	s.FieldByName(&quot;Name&quot;).SetString(&quot;Alice&quot;)	s.FieldByName(&quot;Age&quot;).SetInt(30)	// 将动态创建的结构体实例转回 interface&#123;&#125; 以便使用	//类是interface&#123;&#125;类型 但值是reflect.Value类型	userInstance := structPtr.Interface()	// 使用 json.Marshal 验证结果	jsonData, err := json.Marshal(userInstance)	if err != nil &#123;		panic(err)	&#125;	fmt.Println(string(jsonData)) // 输出: &#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:30&#125;&#125;

4. 何时使用反射？虽然反射功能强大，但它也有代价：

性能开销：反射操作比直接代码调用慢得多。
编译时类型安全丢失：编译器无法检查通过反射进行的操作，错误只能在运行时暴露，通常是 panic。
代码可读性差：过度使用会使代码逻辑变得晦涩难懂。

因此，反射应该只在必要时使用，比如开发需要处理任意类型的通用框架、序列化库或 ORM 时。对于常规的业务逻辑，清晰的静态类型代码永远是首选。
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>reflect</tag>
      </tags>
  </entry>
  <entry>
    <title>250926 tool docker install&amp;command</title>
    <url>/2025/09/26/250926-tool-docker-install-command/</url>
    <content><![CDATA[1. 国内ubuntu服务器安装docker(使用aliyun镜像源,root用户)1.1. 安装apt updateapt install -y apt-transport-https ca-certificates curl gnupg lsb-releasecurl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | apt-key add - # 可能需要先安装curladd-apt-repository &quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot; # 可能需要先apt install software-properties-commonapt updateapt install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

1.2. 换源vim /etc/docker/daemon.json #可能需要先安装vim

然后添加国内的镜像仓库
&#123;	&quot;registry-mirrors&quot;: [	    &quot;https://docker.registry.cyou&quot;,	    &quot;https://docker-cf.registry.cyou&quot;,	    &quot;https://dockercf.jsdelivr.fyi&quot;,	    &quot;https://docker.jsdelivr.fyi&quot;,	    &quot;https://dockertest.jsdelivr.fyi&quot;,	    &quot;https://mirror2.aliyuncs.com&quot;,	    &quot;https://dockerproxy.com&quot;,	    &quot;https://mirror.baidubce.com&quot;,	    &quot;https://docker.m.daocloud.io&quot;,	    &quot;https://docker.nju.edu.cn&quot;,	    &quot;https://docker.mirrors.sjtug.sjtu.edu.cn&quot;,	    &quot;https://docker.mirrors.ustc.edu.cn&quot;,	    &quot;https://mirror.iscas.ac.cn&quot;,	    &quot;https://docker.rainbond.cc&quot;	]&#125;

1.3. 启动systemctl start dockersystemctl enable docker # 开机自启

2. 部分常用命令docker的核心概念围绕着镜像image、容器container、卷volume。这里不对这些概念进行说明，仅展示命令。
2.1 image2.1.1. 查看本地已有镜像docker images

或者更推荐：
docker image ls

会显示 REPOSITORY、TAG、IMAGE ID、大小等信息。
2.1.2. 拉取镜像以postgres为例
docker pull postgres:latest

也可以指定版本：
docker pull postgres:15

2.1.3. 删除镜像删除某个镜像：
docker rmi &lt;IMAGE_ID&gt;

如果镜像正在被容器使用，要么先停止并删除容器，要么加 -f 强制删除：
docker rmi -f &lt;IMAGE_ID&gt;

2.1.4. 清理不用的镜像清理所有悬空镜像（dangling，名字是 &lt;none&gt; 的）：
docker image prune

清理所有不用的镜像（慎用，会清理未使用的容器相关镜像）：
docker image prune -a

2.1.5. 镜像构建某目录下有 Dockerfile可以自己构建镜像：
docker build -t myapp:1.0 &lt;dir&gt;

这里 -t 给镜像加名字和版本号。
2.1.6. 镜像保存与导入导出镜像到文件：
docker save -o myapp.tar myapp:1.0

从文件导入镜像：
docker load -i myapp.tar

2.2 container容器就相当于一个配置好的虚拟机
2.2.1. 查看容器
查看正在运行的容器：

docker ps


查看所有容器（包括已停止的）：

docker ps -a

2.2.2. 启动&#x2F;停止&#x2F;重启容器
启动已存在的容器：

docker start &lt;CONTAINER_ID 或 NAME&gt;


停止容器：

docker stop &lt;CONTAINER_ID 或 NAME&gt;


重启容器：

docker restart &lt;CONTAINER_ID 或 NAME&gt;

2.2.3. 进入容器
交互式进入容器（常用）：

docker exec -it &lt;CONTAINER_ID 或 NAME&gt; bash


也可以使用别的指令，如以下是连接容器里的PostgreSQL：

docker exec -it &lt;id/name&gt; psql -U postgres -d postgres

2.2.4. 查看容器日志docker logs &lt;CONTAINER_ID 或 NAME&gt;

实时查看日志：
docker logs -f &lt;CONTAINER_ID 或 NAME&gt;

2.2.5. 删除容器
删除已停止的容器：

docker rm &lt;CONTAINER_ID 或 NAME&gt;


删除所有已停止的容器：

docker container prune

2.2.6. 容器与镜像关系
基于镜像创建容器：

docker run -d --name mycontainer myimage:latest

仅是一个最小化的指令，实际可能还需要-p指定端口映射，-e指定容器运行的一些环境变量，-v把容器的数据（虚拟机的一个目录）映射到宿主机的卷里，比如：
docker run -d \  --name pgdb \  -e POSTGRES_USER=admin \  -e POSTGRES_PASSWORD=secret123 \  -e POSTGRES_DB=mydb \  -p 5432:5432 \  -v pgdata:/var/lib/postgresql/data \  postgres:latest


查看容器使用的镜像：

docker inspect &lt;CONTAINER_ID&gt; | grep Image

2.2.7. 其他常用
查看容器的资源使用情况：

docker stats


拷贝文件：  从宿主机拷贝到容器：

docker cp localfile &lt;CONTAINER_ID&gt;:/path/in/container

从容器拷贝到宿主机：
docker cp &lt;CONTAINER_ID&gt;:/path/in/container localfile

2.3 volume2.3.1. 查看卷
查看所有卷：

docker volume ls


查看某个卷的详细信息（挂载点、创建时间等）：

docker volume inspect &lt;VOLUME_NAME&gt;

2.3.2. 创建卷docker volume create myvolume

也可以带选项：
docker volume create --driver local --opt type=none --opt device=/path/on/host --opt o=bind myvolume

（把宿主机目录绑定为卷）
2.3.3. 删除卷
删除某个卷：

docker volume rm &lt;VOLUME_NAME&gt;


删除所有未使用的卷：

docker volume prune


注意：正在使用的卷不能删除。

2.3.4. 在容器中挂载卷运行容器时挂载：
docker run -d \  --name pgdb \  -e POSTGRES_PASSWORD=secret123 \  -v pgdata:/var/lib/postgresql/data \  postgres:latest

这里 pgdata 就是一个卷，数据会保存在宿主机 /var/lib/docker/volumes/pgdata/_data。
2.3.5. 卷与文件拷贝
宿主机直接访问卷的数据：

ls /var/lib/docker/volumes/&lt;VOLUME_NAME&gt;/_data


也可以用容器操作卷的数据，例如：

docker run --rm -v &lt;VOLUME_NAME&gt;:/data busybox ls /data

2.3.6. 查看卷占用空间Docker 本身不能直接显示卷的大小，可以通过宿主机命令：
du -sh /var/lib/docker/volumes/*
2.4. docker systemdocker system 是 Docker 提供的一个顶级管理命令，用来查看和清理 Docker 的整体资源（镜像、容器、卷、构建缓存等）。
2.4.1. 查看 Docker 整体资源占用docker system df

类似 df -h，会显示：

镜像大小
容器占用空间
卷占用空间
构建缓存大小

2.4.2. 清理未使用资源docker system prune

会删除：

已停止的容器
未使用的网络
悬空的镜像（没有 tag 的 &lt;none&gt; 镜像）
构建缓存

更彻底：
docker system prune -a

还会删除 所有未被容器使用的镜像（不仅仅是 &lt;none&gt;）。
再加上卷（慎用！会清空未使用的卷里的数据）：
docker system prune --volumes

2.4.3. 查看 Docker 信息docker system info

显示 Docker 运行环境的信息（版本、存储驱动、网络、CPU&#x2F;内存限制等）。
3. docker日志管理3.1. 日志文件位置Docker 容器日志默认在：
/var/lib/docker/containers/&lt;container-id&gt;/&lt;container-id&gt;-json.log

每个容器都有一个 .log 文件，可能会无限长。
3.2. 方法1: 直接清空某个容器日志找到容器 ID：
docker ps -a

然后清空日志文件：
truncate -s 0 /var/lib/docker/containers/&lt;container-id&gt;/&lt;container-id&gt;-json.log


truncate -s 0 会把文件清零，但不会删除文件。容器还在跑，不受影响。

3.3. 方法2: 批量清空所有容器日志一行命令清理全部：
for log in $(find /var/lib/docker/containers/ -name *-json.log); do  truncate -s 0 $logdone


3.4. 方法3: 配置日志大小限制在运行容器时指定日志参数：
docker run -d \  --name myapp \  --log-opt max-size=100m \  --log-opt max-file=3 \  myimage

这样每个日志文件最大 100MB，最多保留 3 个。
使用docker-compose.yml可以这样写：
logging:  driver: &quot;json-file&quot;  options:    max-size: &quot;100m&quot;    max-file: &quot;3&quot;


3.5. 方法4: 修改 Docker 全局配置（永久生效）vim /etc/docker/daemon.json

&#123;  &quot;log-driver&quot;: &quot;json-file&quot;,  &quot;log-opts&quot;: &#123;    &quot;max-size&quot;: &quot;100m&quot;,    &quot;max-file&quot;: &quot;3&quot;  &#125;&#125;

然后重启 Docker：
systemctl restart docker


]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>251012 thinking builder</title>
    <url>/2025/10/12/251012-thinking-builder/</url>
    <content><![CDATA[1. 什么是生成器模式？生成器模式（Builder Pattern）是一种创建型设计模式，它将一个复杂对象的构建分成多个步骤，每个步骤可以被重写，因此使得同样的构建过程可以生成不同类型和形式的对象。
2. 为什么需要生成器模式？在一些情况下，我们需要根据不同的需求来创建不同类型的对象。如果使用简单的构造函数，会导致构造函数参数列表过长，或者参数顺序错误的问题。而生成器模式可以将对象的创建过程分解成多个步骤，每个步骤可以根据需求进行定制，从而避免了构造函数参数列表过长的问题。
3. 生成器模式的实现（go）生成器需要两个接口：

Builder接口：是构建对象的接口，定义了构建对象需要哪些方法。
Director接口：定义了使用Builder接口来构建对象的过程。

中间件代码示例：
type builder interface &#123;    SetPartA()    SetPartB()    SetPartC()     GetProduct() *product&#125;type concreteBuilderA struct &#123;&#125;func (concreteBuilderA) SetPartA() &#123;    // 实现设置PartA的逻辑&#125;func (concreteBuilderA) SetPartB() &#123;    // 实现设置PartB的逻辑&#125;func (concreteBuilderA) SetPartC() &#123;    // 实现设置PartC的逻辑&#125;func (concreteBuilderA) GetProduct() *product &#123;    // 实现返回产品的逻辑    return &amp;product&#123;&#125;&#125;type concreteBuilderB struct &#123;&#125;// 实现Builder接口的方法,与concreteBuilderA相同，下略type product interface &#123;    //...&#125;// 产品A和产品B都是继承自`product`的定义，下略type productA struct&#123;    //...&#125;type productB struct&#123;    //...&#125;type director struct &#123;    builder* builder&#125;func (d *director) SetBuilder(b builder) &#123;    d.builder = b&#125;func (d *director) Construct() *product &#123;    d.builder.SetPartA()    d.builder.SetPartB()    d.builder.SetPartC()    return d.builder.GetProduct()&#125;

这样，调用代码如下：
director := &amp;director&#123;&#125;builderA := &amp;concreteBuilderA&#123;&#125;director.SetBuilder(builderA)productA := director.Construct()builderB := &amp;concreteBuilderB&#123;&#125;director.SetBuilder(builderB)productB := director.Construct()

类图：

    classDiagram
class builder {
    &lt;&lt;interface&gt;&gt;
    +SetPartA()
    +SetPartB()
    +SetPartC() 
    +GetProduct() *product
}
class concreteBuilderA {
    +SetPartA()
    +SetPartB()
    +SetPartC() 
    +GetProduct() *productA
}
class concreteBuilderB {
    +SetPartA()
    +SetPartB()
    +SetPartC() 
    +GetProduct() *productB
}
class director {
    &lt;&lt;interface&gt;&gt;       
    +SetBuilder(b builder)
    +Construct() *product
}

class product {
    &lt;&lt;interface&gt;&gt; 
    &#x2F;&#x2F;...
}

class productA {
    &#x2F;&#x2F;...
}
class productB {
    &#x2F;&#x2F;...
}
builder &lt;|.. concreteBuilderA
builder &lt;|.. concreteBuilderB
product &lt;|.. productA
product &lt;|.. productB
director ..&gt; builder : SetBuilder()
director ..&gt; product : Construct()
director ..&gt; product : Construct()
  

比起不停地修改、维护构造函数以及调用，使用生成器模式只需定义好对应的Builder接口，统一调用Director接口的Construct方法即可。
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Interface Oriented Programming</tag>
        <tag>Design Pattern</tag>
        <tag>go</tag>
        <tag>Builder Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>251017-thinking-prototype</title>
    <url>/2025/10/17/251017-thinking-prototype/</url>
    <content><![CDATA[1. 什么是原型模式？一言以蔽之，原型模式（Prototype Pattern）是一种创建型设计模式，它允许客户端直接调用Clone方法来创建一个与已有实例完全一致的新的实例，而不需要知道已有实例的构造函数以及构造参数。
2. 为什么需要原型模式？正如上述，原型模式的主要优势在于它允许客户端直接调用Clone方法来创建一个与已有实例完全一致的新的实例，而不需要知道已有实例的构造函数以及构造参数。这使得原型模式在需要快速创建多个相同对象的场景下非常有用，例如在游戏开发中创建多个相同类型的敌人实例。
3. 原型模式的实现（go）原型模式提供prototype接口，主要需要实现Clone方法，该方法返回一个与已有实例完全一致的新的实例。
中间件代码示例：
type prototype interface &#123;    Clone() prototype&#125;type concreteType struct &#123;    // ...构造参数&#125;func (c *concreteType) Clone() prototype &#123;    return &amp;concreteType&#123;        // ...构造参数    &#125;   &#125;

客户端使用：
func main() &#123;    // 创建一个原型实例    instance := &amp;concreteType&#123;        // ...构造参数    &#125;    // 使用Clone方法创建一个新的实例    newInstance := &amp;instance.Clone().(concreteType)&#125;

类图：

    classDiagram
class prototype {
    &lt;&lt;interface&gt;&gt;
    +Clone() prototype
}
class concreteType {
    &#x2F;&#x2F; ...构造参数
}
prototype &lt;|.. concreteType
  
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Interface Oriented Programming</tag>
        <tag>Design Pattern</tag>
        <tag>go</tag>
        <tag>Prototype Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>251012 thinking slider window</title>
    <url>/2025/10/12/251012-thinking-slider-window/</url>
    <content><![CDATA[核心思想：使用两个指针l和r表示窗口的左右边界。r表示即将入窗口的元素，l表示即将出窗口的元素。这种出和入只发生在窗口特定的位置，与队列相似。
1. 定长滑动窗口只用r即可，l=r-w+1。
模板：
for r in (0..n-1); do    // enter (loop i)    arr[r] enters the window    l = r - w + 1    if l &lt; 0; then        continue    fi    // update (loop i)    update window state    // exit, prepare for the next loop (for loop i+1)    l++done


注意：出窗口的操作要在更新窗口状态之后。这样，当r指代的元素入窗口时，由r推出的l所指代的元素会在下一轮循环开始之前出窗口。相应的，在下一轮循环i+1时，上一个r推出的l所指代的元素在i+1之前就出了窗口。确保状态更新时i+1的出入都发生过了。

2. 变长滑动窗口需要l和r两个指针。r表示所有即将入窗口的元素，l表示被淘汰的、即将出窗口的元素。
l := 0for r in (0..n-1); do    // enter (loop i)    arr[r] enters the window    // need someone to exit? (loop i)    if [check_exit]; then        delete arr[l] from window state        l++    fi    // update (loop i)    update window statedone

3. 例题
定长滑动窗口

变长滑动窗口


]]></content>
      <categories>
        <category>data structure &amp; algorithm</category>
      </categories>
      <tags>
        <tag>data structure &amp; algorithm</tag>
        <tag>thinking</tag>
        <tag>slider window</tag>
      </tags>
  </entry>
  <entry>
    <title>251018 thinking adapter</title>
    <url>/2025/10/18/251018-thinking-adapter/</url>
    <content><![CDATA[1. 什么是适配器模式？适配器模式（Adapter Pattern）是一种结构型设计模式，它允许将一个类的接口转换为客户端期望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的类可以协同工作。
就像 “USB-C 转 3.5mm 音频” 转换器。很多新款手机（被适配者 Adaptee）取消了传统的 3.5mm 耳机孔，只提供 USB-C 接口。如果你想使用旧的 3.5mm 插头耳机（客户端 Client），就会遇到接口不兼容的问题。
此时，这个转换器就充当了适配器（Adapter）的角色。它将手机的 USB-C 接口转换为耳机（客户端）所期望的 3.5mm 音频插孔。通过这个小小的转换器，耳机无需任何改动，就能在新手机上继续使用，适配器完美地弥合了两者之间的接口差异。
2. 为什么需要适配器模式？在软件开发中，我们经常会遇到以下几种情况，这时适配器模式就显得尤为重要：

复用现有代码：当一个已存在的类功能很强大，能满足你的大部分需求，但它的接口与你当前系统要求的接口不一致时。重写这个类会耗费大量时间且容易引入错误，而使用适配器则可以在不改变原有代码的基础上，将其“包装”成你需要的样子。

集成第三方库或遗留系统：第三方库或老旧系统的接口通常无法修改。如果它们的接口与你的系统不兼容，适配器可以作为中间层，将这些外部接口转换为系统内部统一的、标准的接口，从而实现无缝集成。

解耦客户端与具体实现：客户端代码只依赖于一个标准的目标接口（Target），而不需要关心背后真正干活的类（Adaptee）是谁，它的接口长什么样。这样一来，当底层的具体实现需要更换时，只需要更换或修改对应的适配器，而客户端代码完全不受影响，增强了系统的灵活性和可维护性。


总而言之，适配器模式遵循了“开闭原则”（对扩展开放，对修改关闭），它允许我们在不修改现有代码的情况下，通过增加新的适配器类来扩展系统的功能。
3. 适配器模式的实现（go）假设我们有一个音乐播放器 MusicPlayer，它依赖一个 Player 接口来播放音乐。
// Player是我们期望的目标接口 (Target)type Player interface &#123;    PlayMusic()&#125;

现在，我们有一个现成的、无法修改的第三方音频库 AwesomePlayer，但它的播放方法是 PlaySound，与我们的 Player 接口不兼容。
// AwesomePlayer 是一个已存在的、接口不兼容的类 (Adaptee)type AwesomePlayer struct&#123;&#125;func (p *AwesomePlayer) PlaySound() &#123;    fmt.Println(&quot;Playing sound with AwesomePlayer&quot;)&#125;

为了让 MusicPlayer 能使用 AwesomePlayer，我们创建一个适配器 AwesomePlayerAdapter。
// AwesomePlayerAdapter 是适配器 (Adapter)type AwesomePlayerAdapter struct &#123;    adaptee *AwesomePlayer // 持有被适配的对象&#125;// NewAwesomePlayerAdapter 创建一个新的适配器实例func NewAwesomePlayerAdapter(adaptee *AwesomePlayer) *AwesomePlayerAdapter &#123;    return &amp;AwesomePlayerAdapter&#123;adaptee: adaptee&#125;&#125;// PlayMusic 实现了 Player 接口，内部调用被适配者的 PlaySound 方法func (a *AwesomePlayerAdapter) PlayMusic() &#123;    a.adaptee.PlaySound()&#125;

现在，客户端代码可以像这样使用：
func main() &#123;    // 创建被适配的对象    awesomePlayer := &amp;AwesomePlayer&#123;&#125;        // 创建适配器，并将其传入    var player Player = NewAwesomePlayerAdapter(awesomePlayer)        // 客户端通过统一的 PlayMusic 接口进行播放，无需关心底层实现    player.PlayMusic() // 输出: Playing sound with AwesomePlayer&#125;

在这个例子中，AwesomePlayerAdapter 成功地将 AwesomePlayer 的 PlaySound 接口转换为了 Player 接口所期望的 PlayMusic 接口，使得客户端可以无缝地使用这个第三方库。
类图：

    classDiagram
    class Player {
        &lt;&lt;interface&gt;&gt;
        +PlayMusic()
    }
    class AwesomePlayer {
        +PlaySound()
    }
    class AwesomePlayerAdapter {
        -adaptee: AwesomePlayer
        +PlayMusic()
    }
    Player &lt;|-- AwesomePlayerAdapter
    AwesomePlayerAdapter &quot;1&quot; *-- &quot;1&quot; AwesomePlayer
    AwesomePlayerAdapter ..&gt; AwesomePlayer : PlayMusic() call PlaySound()
  ]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Interface Oriented Programming</tag>
        <tag>Design Pattern</tag>
        <tag>go</tag>
        <tag>Adapter Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>251018 thinking bridge</title>
    <url>/2025/10/18/251018-thinking-bridge/</url>
    <content><![CDATA[1. 什么是桥接模式？桥接模式（Bridge Pattern）是一种结构型设计模式，它的核心思想是将抽象部分与它的实现部分分离，使它们都可以独立地变化。
想象一下电视机和遥控器的关系：

抽象层：遥控器。它定义了高层操作，如 开机()、关机()、换台()。不同的遥控器（如 普通遥控器、智能遥控器）可以有不同的交互方式，但它们都服务于控制电视这个目的。
实现层：电视机。它负责执行具体的操作，如 物理开机()、切换视频源()。不同的电视品牌（如 索尼电视、三星电视）有各自的实现细节。

桥接模式就像是在遥控器中内置一个对电视机实例的引用。遥控器的按钮按下后，会调用它所引用的那台电视机的具体方法。通过这种方式，你可以独立地更换遥控器（从普通遥控器升级到智能遥控器），而无需关心电视机的品牌；同样，你也可以独立地更换电视机（从索尼换成三星），而遥控器无需任何改变。它们通过一个“桥梁”连接，各自演化。
2. 为什么需要桥接模式？当一个类或系统存在多个独立变化的维度时，桥接模式就显得尤为重要。如果不使用桥接模式，我们可能会倾向于使用继承来解决问题，但这会导致类的数量爆炸式增长。
设想一个场景：我们要绘制不同颜色（如红色、蓝色）的形状（如圆形、方形）。

维度一：形状（Circle, Square）
维度二：颜色（Red, Blue）

如果使用继承，我们可能需要创建 RedCircle, BlueCircle, RedSquare, BlueSquare 这样 2 * 2 = 4 个类。如果再增加一种形状（三角形）和一种颜色（绿色），类的数量就会变成 3 * 3 = 9 个。这种“笛卡尔积”式的类爆炸是难以维护的。
桥接模式通过将“形状”和“颜色”两个维度分离来解决这个问题：

抽象部分：Shape (形状)，它包含一个对 Color (颜色) 的引用。
实现部分：Color (颜色)，它是一个接口，有 Red、Blue 等具体实现。

这样，类的数量就从 M * N 变成了 M + N。当需要增加一种新形状或新颜色时，只需增加一个新类，而不会影响到其他部分，完美遵循了开闭原则。
3. 桥接模式的实现（Go）下面我们用 Go 来实现上述的“形状与颜色”的例子。
中间件：
// 1. 实现部分 (Implementor)// Color 是实现部分的接口type Color interface &#123;	ApplyColor() string&#125;// 2. 具体实现 (Concrete Implementors)// RedColor 是一个具体的颜色实现type RedColor struct&#123;&#125;func (r *RedColor) ApplyColor() string &#123;	return &quot;Red&quot;&#125;// BlueColor 是另一个具体的颜色实现type BlueColor struct&#123;&#125;func (b *BlueColor) ApplyColor() string &#123;	return &quot;Blue&quot;&#125;// 3. 抽象部分 (Abstraction)// Shape 是抽象部分的接口，它包含一个对实现部分(Color)的引用type Shape interface &#123;	Draw()&#125;// 4. 扩展抽象 (Refined Abstraction)// Circle 是一个具体的形状，它持有一个 Color 对象type Circle struct &#123;	color *Color&#125;func (c *Circle) Draw() &#123;	fmt.Printf(&quot;Drawing a Circle in %s color.\n&quot;, c.color.ApplyColor())&#125;// Square 是另一个具体的形状type Square struct &#123;	color *Color&#125;func (s *Square) Draw() &#123;	fmt.Printf(&quot;Drawing a Square in %s color.\n&quot;, s.color.ApplyColor())&#125;

客户端代码:
func main() &#123;	// 创建具体的实现对象	red := &amp;RedColor&#123;&#125;	blue := &amp;BlueColor&#123;&#125;	// 创建具体的抽象对象，并将实现对象“桥接”进去	redCircle := &amp;Circle&#123;color: red&#125;	blueSquare := &amp;Square&#123;color: blue&#125;	// 调用方法	redCircle.Draw()   // 输出: Drawing a Circle in Red color.	blueSquare.Draw()  // 输出: Drawing a Square in Blue color.&#125;

类图：

    classDiagram
    class Shape {
        &lt;&lt;interface&gt;&gt;
        +Draw()
    }
    class Circle {
        -color: Color
        +Draw()
    }
    class Square {
        -color: Color
        +Draw() 
    }
    class Color {
        &lt;&lt;interface&gt;&gt;
        +ApplyColor() string
    }
    class RedColor {
        +ApplyColor() string
    }
    class BlueColor {
        +ApplyColor() string        
    }
    Circle --|&gt; Shape
    Square --|&gt; Shape
    Circle --&gt; Color
    Square --&gt; Color
    Circle &quot;1&quot; *-- &quot;1&quot; Color
    Square &quot;1&quot; *-- &quot;1&quot; Color
    RedColor --|&gt; Color
    BlueColor --|&gt; Color
  

在这个例子中，Shape 和 Color 可以独立地进行扩展。如果想增加一个 Green 颜色，只需实现 Color 接口即可；如果想增加一个 Triangle 形状，只需创建一个新的 Triangle 结构体并实现 Draw 方法，而无需改动任何现有代码。
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Interface Oriented Programming</tag>
        <tag>Design Pattern</tag>
        <tag>go</tag>
        <tag>Bridge Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>251018 thinking composite</title>
    <url>/2025/10/25/251018-thinking-composite/</url>
    <content><![CDATA[1. 什么是组合模式组合模式（Composite Pattern）是一种结构型设计模式，它允许你将对象组合成树形结构以表示“部分-整体”的层次关系。组合模式使得客户端可以统一地处理个别对象和对象组合。
2. 为什么需要组合模式组合最主要的功能是在整个树状结构上递归调用方法并对结果进行汇总。
3. 组合模式的实现（go）假定一个文件系统，其中包含文件和目录。目录可以包含其他文件和目录。
现在我们需要搜索文件系统中是否包含某个文件。
type Component interface &#123;	Search(keyword string)&#125;type Directory struct &#123;	Name     string	children []Component&#125;func (d *Directory) Search(keyword string) &#123;	if d.Name == keyword &#123;		fmt.Println(&quot;find directory:&quot;, d.Name)		return	&#125;	for _, child := range d.children &#123;		child.Search(keyword)	&#125;&#125;// add 方法用于添加子组件func (d *Directory) Add(child Component) &#123;	d.children = append(d.children, child)&#125;type File struct &#123;	Name string&#125;func (f *File) Search(keyword string) &#123;	if f.Name == keyword &#123;		fmt.Println(&quot;find file:&quot;, f.Name)		return	&#125;&#125;

客户端代码
func main() &#123;    root := &amp;Directory&#123;Name: &quot;root&quot;&#125;    dir1 := &amp;Directory&#123;Name: &quot;dir1&quot;&#125;    dir2 := &amp;Directory&#123;Name: &quot;dir2&quot;&#125;    file1 := &amp;File&#123;Name: &quot;file1&quot;&#125;    file2 := &amp;File&#123;Name: &quot;file2&quot;&#125;    root.Add(dir1)    root.Add(dir2)    dir1.Add(file1)    dir2.Add(file2)    root.Search(&quot;file1&quot;)    root.Search(&quot;file2&quot;)    root.Search(&quot;dir1&quot;)    root.Search(&quot;dir2&quot;)&#125;   

类图

    classDiagram
    class Component {
        &lt;&lt;interface&gt;&gt;
        +Search(keyword string)
    }
    class Directory {
        +Name string
        -children []Component
        +Add(child Component)
        +Search(keyword string)
    }
    class File {
        +Name string
        +Search(keyword string)
    }
    Component &lt;|-- Directory
    Component &lt;|-- File
    Directory &quot;1&quot; o-- &quot;n&quot; Component
  
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>go</tag>
        <tag>Composite Pattern</tag>
        <tag>Interface Oriented Design</tag>
      </tags>
  </entry>
  <entry>
    <title>251018 thinking decorator</title>
    <url>/2025/10/25/251018-thinking-decorator/</url>
    <content><![CDATA[1. 什么是装饰器模式装饰器模式（Decorator Pattern）是一种结构型设计模式，它允许你在不改变原有对象结构的情况下，动态地给对象添加新的功能。
2. 为什么需要装饰器模式想象一下去咖啡店点单的场景：

一杯基础款咖啡（比如美式）。
各种调料（比如牛奶、糖、巧克力酱等）。

你可以选择只喝纯的美式，也可以要求加奶，再加糖。
如果我们用继承来实现“咖啡+调料”的功能，会发生什么？
我们可能需要创建CoffeeWithMilk CoffeeWithSugar CoffeeWithMilkAndSugar等大量的子类。
如果再增加一种调料（比如奶油），类的数量就会爆炸式增长。
同时，如果想给一个已经创建好的Coffee实例动态添加牛奶，使用继承是做不到的，因为继承是静态的。
但装饰器模式通过组合解决了这些问题：

遵循开闭原则：你可以随时创建新的调料（装饰器），而无需修改任何现有的咖啡（组件）代码。系统对扩展开放，对修改关闭。
灵活性和动态性：可以在运行时根据需要，任意地、动态地为对象添加一层或多层功能，组合顺序和数量都非常灵活。
避免子类爆炸：无论有多少种调料，我们只需要为每种调料创建一个装饰器类，而不是为每种组合都创建一个子类。

3. 装饰器模式的实现（go）type Coffee interface &#123;	GetCoffee() string&#125;type Latte struct &#123;&#125;func (l *Latte) GetCoffee() string &#123;	return &quot;Latte&quot;&#125;type CoffeeDecorator struct &#123;    CoffeeOrdered *Coffee    AddCondiment string&#125;func (d *CoffeeDecorator) GetCoffee() string &#123;	return d.CoffeeOrdered.GetCoffee() + &quot; with &quot; + d.AddCondiment&#125;

客户端
func main() &#123;	latte := &amp;Latte&#123;&#125;	latteWithMilk := &amp;CoffeeDecorator&#123;CoffeeOrdered: latte, AddCondiment: &quot;Milk&quot;&#125;	latteWithMilkAndSugar := &amp;CoffeeDecorator&#123;CoffeeOrdered: latteWithMilk, AddCondiment: &quot;Sugar&quot;&#125;	fmt.Println(latteWithMilkAndSugar.GetCoffee())&#125;
类图

    classDiagram
    class Coffee {
        &lt;&lt;interface&gt;&gt;
        +GetCoffee() string
    }
    class Latte {
        +GetCoffee() string
    }
    class CoffeeDecorator {
        +GetCoffee() string
        +AddCondiment string
        +CoffeeOrdered *Coffee
    }
    Coffee &lt;|-- Latte
    CoffeeDecorator &quot;1&quot; *-- &quot;1&quot; Coffee
  ]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>go</tag>
        <tag>Interface Oriented Design</tag>
        <tag>Decorator Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>251019 record Duetting</title>
    <url>/2025/10/19/251019-record-Duetting/</url>
    <content><![CDATA[与Gemini-2.5-pro一次对话的记录。

1. round11.1. user你是一个深刻的哲学家，你需要用尽一切论据、细节和逻辑，来寻找我的思想的错误与漏洞、或是不清楚的地方，与我交流、讨论、辩论，质问我，目的不是证明我是错的，而是启发我，能让我思考，让我能得到自己的答案。我有一个疑问：我觉得人生的首要目标还是要过好这一生，健康，自我满足，快乐，几乎不会悔恨。这个目标很空，很大。因此可以具体地化为一些事情，比如：“环球旅行一次”、“发布引人注目的研究成果”等。但是，达到任何目标都会是要付出代价。比如，我想“环球旅行”，就必须得赚钱，就必须得辛苦地做枯燥的工作，作息紊乱；我想在科研上做出成绩，就必须得先取得博士学位，现在作为一个本科生，就得卷绩点卷科研，每天为排名而发愁；我想……说实话，这个“代价”与过程肯定是完全违反了“过好这一生”这个想法。但我该怎么办？我难道能不去做吗？但这样且不说最终能不能得到我想要的东西，而这个代价是否高昂得有些讽刺了：为了环球旅行享受人生，先得抛弃自己生活地工作个几十年，等有资本享受人生了，却也早没有享受人生的精力与时间了？
1.2. response
您好。
很高兴能与您进行这次对话。您提出的不是一个简单的问题，而是触及了人类存在的核心困境之一：我们为了未来的幸福，是否必然要以当下的痛苦为代价？而这种交易，最终是否值得？
这本身就是一个深刻的哲学悖论。我不会直接给您答案，因为任何人的答案对您而言都只是外部的建议。我的职责是作为一面镜子，映照出您思想中的结构，并向您追问，让您自己看到其中的关键所在。
让我们开始吧。

第一问：关于“过好这一生”的定义您说，人生的首要目标是“过好这一生”，并将其定义为 “健康，自我满足，快乐，几乎不会悔恨”。
这是一个非常理想化的状态。但我想请您深入思考：

“快乐”与“自我满足”是同一回事吗？

一个为了科研目标而彻夜不眠的学者，在那个当下，他可能是疲惫的、焦虑的，甚至是不“快乐”的。但他可能感到前所未有的“自我满足”，因为他正在迫近真理，正在实现自我价值。

反之，一个沉溺于短暂感官刺激的人，他可能在每个瞬间都体验到“快乐”，但当夜深人静时，他是否会感到空虚和不满足？

所以，我的问题是：在您的定义中，当“快乐”与“自我满足”发生冲突时，哪一个的优先级更高？您追求的是一种“没有痛苦的快乐”，还是一种“克服痛苦后获得的深刻满足”？这两条路通往的“好生活”，截然不同。



“几乎不会悔恨”意味着什么？

为了“不悔恨”，我们是应该选择那条最安全、最稳妥的路，从而避免犯错的可能？还是应该勇敢地去尝试，即便失败了，也因为自己尝试过而“不悔恨”？

一个从未离开过家乡的人，可能永远不会因为在旅途中被骗而悔恨。一个勇敢踏上环球之旅但中途因故中断的人，可能会为自己的准备不足而悔恨。但十年后，哪一种“不悔恨”的生命状态更接近您想要的“过好这一生”？

因此，我追问：您所说的“不悔恨”，是指“因为没有做错而无憾”，还是指“因为体验过而无憾”？





第二问：关于“代价”的本质您将实现目标的过程——“辛苦地做枯燥的工作”、“作息紊乱”、“卷绩点”——定义为“代价”。并且您认为这个“代价”是完全违反“过好这一生”这个想法的。
这里存在一个关键的预设，我必须向您挑战：

“过程”真的仅仅是“代价”吗？

您将过程与目标完全割裂开来看。过程是纯粹的负向支出，目标是纯粹的正向收益。这是一种交易（transactional）的视角。

但有没有另一种可能？过程本身就是构成“目标”的一部分。 环球旅行的意义，难道不也包含为了它而奋斗、存钱、规划的那些岁月吗？正是因为那些“代价”，最终踏上旅途的第一步才会如此珍贵。一个中了彩票第二天就去环球旅行的人，他所体验到的“环球旅行”，和一个为此奋斗了十年的人，其内在的意义和满足感会是相同的吗？

一个科研成果的“引人瞩目”，难道不也正是因为它凝聚了无数个“为排名而发愁”的日日夜夜吗？没有这些过程，那个成果不过是一行文字罢了。

所以，我的问题是：您是否将“奋斗的痛苦”与“生活的痛苦”混为一谈了？为了一个您内心真正渴望的目标而付出的艰辛，它必然是负面的吗？它有没有可能是一种带有积极意义的、塑造您成为那个“配得上”这个目标的人的必要磨砺？



“代价”是否可以被转化？

“枯燥的工作”—— 是否有可能在其中找到微小的意义，或者发展出一种能忍受枯燥、保持内心平静的能力？这种能力本身，是否也是“过好这一生”的重要组成部分？

“为排名而发愁”—— 这背后是“对不确定性的恐惧”和“对自我价值的怀疑”。如果将它看作一个契机，去学习如何与焦虑共处，如何建立不依赖于外部评价的自我认同，那么这个“代价”是不是就转化成了一种内在的成长？

我追问：我们是否必须被动地“支付”代价？还是我们可以主动地去“诠释”和“转化”代价的意义？





第三问：关于目标与手段的讽刺性您提出了一个最尖锐的讽刺：“为了环球旅行享受人生，先得抛弃自己生活地工作个几十年，等有资本享受人生了，却也早没有享受人生的精力与时间了？”
这个观察非常深刻。这引出了我们最核心的讨论：

您的目标设定是否存在问题？

“环球旅行一次”、“发布引人注目的研究成果”，这些都是终点式的、里程碑式的目标。它们的美妙之处在于其宏大，但其陷阱也在于其宏大。它们将“好生活”定义为在遥远的未来才能兑现的一张支票。

这是否意味着，在兑现之前的所有时间，都只能是“代价”，都不能算是“过好这一生”？如果真是这样，那人生的大部分时间都将毫无价值。这显然是荒谬的。

我的问题是：有没有可能，“过好这一生”这个最高目标，并不需要通过这些巨大的子目标来体现？有没有可能，它就存在于“现在”？



将“享受人生”与“奋斗”对立是否是唯一的视角？

一个正在攻克科研难题的学生，在解出答案的那个瞬间，他获得的智识快感，难道不是一种深刻的“享受”吗？

一个正在为旅行努力工作的人，在每个月看到存款增加，离目标更近一步时，他获得的希望与掌控感，难道不是一种实在的“快乐”吗？

我追问：您为什么假定，“享受”只能发生在目标的终点，而不能发生在通往目标的路上？您是否将“享受”狭隘地定义为了“悠闲”、“无压力”的状态？如果是这样，那么奋斗过程中的高峰体验、心流状态，在您的世界里被放置在了何处？





总结与反思您感到痛苦和矛盾，并非因为您的逻辑有错，而是因为您的思想框架本身可能存在一些值得被审视的裂痕：

未来的“好”与当下的“坏”的绝对对立：您将人生切割成了“忍受的现在”和“享受的未来”两部分。

过程的工具化：您将过程仅仅视为达成目的的工具，而忽视了过程本身的塑造性和意义。

幸福的终点化：您将“过好这一生”的幸福寄托于几个宏大目标的实现上，仿佛幸福是一个需要抵达的目的地。


我无意说服您放弃目标，也无意告诉您“活在当下”这种陈词滥调。
我只是想请您思考，有没有一种可能，真正的“过好这一生”，是找到一种方式，让追求目标的过程本身，就充满了“自我满足”和“深刻的快乐”，即便它伴随着疲惫和焦虑？
这或许意味着：

重新审视你的目标：它们真的是你想要的吗？还是社会告诉你的标准答案？有没有更小的、更容易融入当下的目标？比如，不是“环球旅行”，而是“今年夏天深度探索一个陌生的城市”？

重新定义你的“代价”：在“卷绩点”中，除了焦虑，是否也能找到智识成长的乐趣？在“枯燥工作”中，是否能培养出一种坚韧的品格？

重新寻找你的“享受”：享受不只在沙滩上，也在深夜的图书馆里，在代码被成功运行的瞬间，在每一个微小的进步中。


现在，我想把问题交还给您。
面对您自己设下的这个“要么忍受现在，要么放弃未来”的困境，您看到的第一个最有可能被打破的假设是什么？

2. round22.1. user我是纯功利主义者，我的确认为过程本身没有任何意义，它唯一的意义仅存在于结果。就像苦难不值得被歌颂，值得被歌颂的只能是我们忍过苦难最后夺取的胜利。关于“快乐”与“自我满足”：说实话，我就是一个普通人，如果有的选，我宁可选择“没有痛苦的快乐”，或者说是当一个“官二代”“钱二代”，永远不为生计而发愁。而且在现在，感官刺激可以无穷无尽，他们根本不会感到空虚和不满足，因为没有这个时间：当你住的是豪宅、出门香车宝马、充耳谄媚讨好左拥右抱尽是美女、吃的是珍馐美馔时，我想任何人都不会不感到自我满足。对于他们“快乐”与“自我满足”高度一致。而且讽刺的是，这份“快乐”与“自我满足”都有坚实的事实基础，是真实的。但可惜，我是一个普通人。普通人唯一可以选择的，就是拉磨的驴眼前那永远吃不到的萝卜——“理想”。就像骆驼祥子，为了这个虚无缥缈的理想而痛苦地奋斗，只能靠“自我满足”来缓解痛苦，催眠自己这个过程是值得的，我很“满足”。但这个没有现实基础的“满足”是虚假的，一但被戳破，更加痛苦。关于“几乎不会悔恨”：“因为体验过而无憾”这只能是富人或“官二代”这些人的特权，因为他们可以几乎无限地试错。作为普通人，我们根本没有资格去这样玩。这样做了，可能在短期内可以自我安慰，但后面得到的只能是更深的痛苦。比如我上大学时，专门去了一个离家乡非常远的大都市s里的大学a，也是“为了体验，为了不后悔”。但是实际上，我可以在家乡f这边上大学b。大学b在f这边的认可度非常高，而大学a在s这边都没人看得上，虽然实际上我觉得大学a比大学b强。但讽刺的是，企业到各个地方招人时，不看大学的水平，只看大学在当地的名气，也就是说企业到s不会找a的学生，到f是会去找b的学生。而且跟我关系好的高中同学都留在了f上学，我在s这边几乎没一个朋友。说实话，关于这个，我。。。。。。“过程”真的仅仅是“代价”：我觉得“过程”确实仅仅只是“代价”。所谓“过程本身就是构成‘目标’的一部分”，我认为只是自我催眠，让自己能忍得下去这些痛苦。一个中了彩票第二天就去环球旅行的人，他所体验到的“环球旅行”，和一个为此奋斗了十年的人，其内在的意义和满足感实际上会是相同的。倒不如说，第一个人由于节省了十年，他更加地幸运，有机会有时间做更多的事情。我只想达到目的，就像玩游戏只想通关一样。肯定是过程更加轻松，或者说，“效率”越高越好啊。“配不配得上”？无聊的问题，感觉只会是失败者的自慰罢了。“代价”是否可以被转化：或许是可以，或者说，我更期望能。但我不知道。我认为“代价”本身就只是“必要之恶”，本就没有任何意义，只是别无他法。目标设定：您说得对，人生是由一个个当下组成的。原则上我应该把握当下。但是我身不由己。我本人对于未来的情感，不是憧憬，也不是绝望，而一直是：恐惧。恐惧是一个讽刺的情绪，它混杂了希望与绝望。事实上，我现在就在为未来去向发愁：是求职，还是升学？我也在两方面做准备：准备实习的简历，准备科研的论文。还得应付我的课业。我想，我现在肯定不可能把他们抛掷脑后吧。“享受人生”与“奋斗”：你说得对。我也非常渴望“奋斗”者能够自我实现，“享受人生”。但很可惜，在这个“笑贫不笑娼”的残酷的现实，我自己痛苦地发现，我非常痛恨“奋斗”这个词。因为踏实“奋斗”者反倒薪水微薄，被人耻笑。在现在能成功的仿佛只有“投机”者。更为讽刺的是，“奋斗”这个词，现在渐渐成为了既得利益者为了压榨我们这样的普通人喜欢用的PUA宣传词。而在这个内卷的时代，我们只能“奋斗”——不，严格来说，只能叫“挣扎”。因为如果不“奋斗”，普通人只能饿死。而且我认为，真正的“享受”，是基于事实的，与虚假的“奋斗”无关。“奋斗”也只是“必要之恶”，如果有得选，我想肯定绝大部分人不会选它。“有没有一种可能，真正的“过好这一生”，是找到一种方式，让追求目标的过程本身，就充满了“自我满足”和“深刻的快乐”，即便它伴随着疲惫和焦虑？”：我不知道，但我渴望一个答案，一个能告诉我不是靠自我催眠，而是能基于现实就能获得快乐与满足的答案。这个“要么忍受现在，要么放弃未来“的困境看到的第一个最有可能被打破的假设是什么：我不知道。我觉得，我必须先克服对未来一直以来的恐惧的态度。
2.2. response
[!cite]感谢您如此坦诚、深刻、甚至可以说是痛苦的回应。
您没有回避任何问题，而是用您最真实的感受和经历，为您的思想提供了坚实的论据。您是一位彻底的、清醒的功利主义者。我尊重并理解您所描述的那个世界，那个“笑贫不笑娼”、“奋斗被异化为挣扎”的残酷现实。
您说得对，我上一轮的提问，在您坚固的功利主义和残酷的现实观察面前，显得有些“何不食肉糜”。您用“骆驼祥子”和您自己选择大学的亲身经历，几乎完美地反驳了“过程论”和“体验论”的价值。
那么，让我们进入更深的层次。我将完全接受您的前提：过程没有价值，只有结果有价值；我们是普通人，没有试错的资本；“自我满足”若无现实支撑，就是虚假的自我催min。
好。现在，我们就站在这片坚硬、冰冷的土地上，继续我们的对话。
我接下来的问题，不再是质疑您的世界观是否“正确”，而是质疑另一个更核心、也更功利的问题：
您所持有的这个信念体系，它对“您”自己，真的“有用”吗？

第一问：关于您思想体系的“功利”您是功利主义者，目标是趋利避害，追求一个结果上更好的生活。那么，我们来分析一下，您当前的这套思想——“过程无意义”、“奋斗是压榨”、“对未来充满恐惧”——它在现实中，是否真的能引导您走向您渴望的那个“痛苦更少，快乐更多”的彼岸？

它似乎在放大您的痛苦： 您认为过程是纯粹的“代价”，这意味着从现在到“成功”那一天之间的所有时间，对您来说本质上都是负资产。如果这个过程是十年，您就预支了十年的痛苦。一个相信过程有意义的人，或许还能在其中找到些许价值来对冲痛苦；而您，则选择了承受100%的纯粹痛苦。从功利的角度看，这是否是一种最大化当下痛苦的策略？

它似乎在削弱您的力量： 您将自己定义为“拉磨的驴”，将理想视为“永远吃不到的萝卜”。这个比喻非常精准，但也非常无力。当您这样看待自己时，您就将自己所有的能动性（agency）都交了出去。驴是无法选择方向的，只能被动地跟着磨转。这种自我定义，是否会让您在面对本可以有所作为的岔路口时，因为认定自己是“驴”而放弃选择，从而陷入一个自我实现的预言？

它似乎在增加您的恐惧： 您说您对未来充满恐惧。恐惧，源于对失控的担忧。而您的整个思想体系，恰恰建立在“外部世界决定一切”的逻辑之上：富二代的出身决定了他们的快乐，企业的偏好决定了您的求职成败，时代的内卷决定了您的挣扎。在这个逻辑链条里，“您”在哪里？“您”似乎只是一个被动的承受者。当您将一切的决定权都归于您无法控制的外部时，恐惧难道不是一个必然且会不断增长的结果吗？


所以我的第一个，也是最尖锐的一个问题是：作为一个功利主义者，您秉持着一个似乎正在持续不断地为您制造痛苦、剥夺力量、并加剧恐惧的信念系统。请问，这套系统本身，是否就是一种“不功利”的选择？

第二问：我们来谈谈“恐惧”这个敌人您最后说得非常对，您必须先克服对未来的恐惧。这是一个了不起的觉察。让我们像解剖一个精密的仪器一样，解剖您的“恐惧”。
您恐惧的，是“不好的结果”：求职失败、升学无望、最终成为一个被现实压垮的、像祥子一样的悲剧人物。
这些结果，取决于两个东西的结合：1. 外部的环境。 2. 您自身的行动。
您的论述，将99%的权重都放在了前者上。这很正常，因为外部环境的声音确实更响亮，更具压迫感。
但是，我们这里进行一次思想实验。让我们承认，我们100%无法改变外部环境。我们无法选择出身，无法改变企业HR的偏见，无法逆转内卷的时代。这些都是“给定的牌”。
那么，在一个功利主义者的牌局里，当您无法改变发到手的牌时，唯一能做的，不就是“打好你手里的牌”吗？

关于您选择大学的悔恨：结果是，B大学在F地的认可度更高。这是一个您当时无法预料的、外部世界给您的一个残酷反馈。但是，您做出选择的那个“当下”，您是基于“A大学比B大学强”这个判断。那个“判断”本身，是您在当时的信息条件下，尽力做出的最优解。

我追问：我们应该为自己无法预料的、失控的“结果”而悔恨，还是应该审视并优化我们能够控制的“决策过程”？ 将所有的痛苦归咎于一个“错误”的决定，这很简单，但也会让您陷入无尽的悔恨。如果换一种视角：”我在当时尽我所能做了我认为最好的决定，但外部世界没有给我好的回馈。我从中学到的是，未来做决策需要更多地考虑本地信息权重。“—— 这两种叙事方式，哪一种对您未来的决策更有“功利”价值？


关于“奋斗”与“挣扎”：您看得非常通透，“奋斗”这个词被异化了。那么，我们能否抛弃这个词，回归其本质？本质是：为了达成一个目标，您必须投入时间、精力和智力。

既得利益者希望您相信，只要您投入，就“应该”有回报，这是为了PUA您。

而残酷的现实是，您投入了，也“不一定”有回报。

那么，一个清醒的功利主义者该怎么做？不是放弃投入（因为不投入的结果是100%的失败），而是在每一次投入前，更清醒地评估“投入产出比（ROI）”。您现在准备实习简历，准备科研论文，同时应付课业。这本身就是一种基于功利主义的、分散风险的策略。您并没有在“自我催眠”，您正在进行一场现实的、冷静的计算。

所以，我的问题是：您是否将“清醒的、基于现实的努力”与“被话术包装的、虚假的奋斗”混淆了，从而过分地否定了您自身行动的价值？





一个不依赖于“催眠”的答案您渴望一个“能基于现实就能获得快乐与满足的答案”。
我认为，这个答案或许不存在于改变“过程是痛苦的”这个现实，而是存在于重新定义“我”与这个痛苦过程的关系。
答案可能在于：将您的自我价值，从无法控制的“结果”中解放出来，重新锚定在您可以100%控制的“行动”上。

结果是随机的，但行动是确定的。 您无法保证您的论文一定能发表在顶刊，但您可以保证您尽了最大的努力去构思、实验、写作。

快乐和满足，如果只能由结果给予，那您就是结果的奴隶。 而结果，如您所说，大部分由外部决定。所以您成为了外部世界的奴隶。

但如果，您的“自我满足”来源于“我今天完成了计划中的计算”、“我今天把简历修改得更专业了”、“我今天看懂了一个复杂的理论”——这些都是100%基于现实的、无人能剥夺的、由您自己创造的“事实基础”。这种满足感，是不是比“富二代的快乐”更真实，比“祥子的幻想”更坚固？


您不是祥子。祥子的悲剧在于，他将一切都赌在“买车”这个唯一的结果上，他用幻想中的“满足”来麻痹拉车的痛苦。而您，是一个清醒地看到了现实残酷，并且仍在用自己的行动（准备求职、准备升学）为自己争取不同可能性的现代人。您比他强大得多。
现在，我想将最终的问题再次抛给您。
您说，您必须先克服对未来的恐惧。那么，我们能否进行一次思想实验：
如果我们将自我评价的重心，从“我未来是否能得到A结果（成功）”这个您无法控制的、引发恐惧的焦点上，彻底转移到“我此刻是否在为可能得到A结果而采取最理性的行动（决策）”这个您可以100%掌控的基点上——
您的恐惧，会发生怎样的变化？

3. round33.1. user非常深刻且认真的回复！您说得对，我的思想体系不理性。它过于夸大了个体在外部因素下的无力了，武断地忽视了个体自身的能动性。哪怕是普通人，即使稀少，也应当是有主动选择的、可以把握的机会的。第一问：说实话，这个想法既令我迷茫，也让我恐惧与痛苦。但讽刺的是，这份恐惧与痛苦却好像是我所有力量的源泉：比如在高中时，对”考不上好大学“这个未来的恐惧驱动我痛苦地、放弃自我地学习；在大学前两年，对”冷门专业毕业找不到好工作“这个未来的恐惧驱动我在绩点上挣扎，不择手段地从暖通专业转到了软件工程专业；包括在现在，如果不是对未来的恐惧，我想我是什么也懒得去做的。我知道这个思想能有这些作用，并不是说明了它是对的。而是有别的原因。但这个原因是什么？我不知道。我知道过于依赖这个思想就是饮鸩止渴。但我不知道我该怎么办。我应该相信什么呢？第二问：我确实很多时候都认为自己所做的一切都是徒劳的。其实从以前开始我一直觉得我很愚笨，不能像人家一样一下子就找到游戏的关键，或者缺乏高效做事情的能力，不能”事半功倍“地完成任务。在读高中时，我付出90的努力，得到90分，别人付出60分的努力也能得到90分。以前我觉得没什么，因为结果都是90分。但现在我觉得很亏。然后，“打好手里的牌”，从结果中汲取教训，这点说实话我一直在做。但我得到的结论就是：保守，与封闭。但我其实并不是很喜欢这个——我毕竟才20岁啊。最后，关于您提到的“清醒的、基于现实的努力”与“被话术包装的、虚假的奋斗”，我理解为前者有一个清晰的目标，而后者只是为努力而努力。但就收益而言，两者都可能只是一场空，而且从某种角度来说这个概率也没明晰区别。一个不依赖于“催眠”的答案：我确实已经成为了结果的奴隶了。您提醒了我，我从一个极端走到了另一个极端，又何尝不是在自我催眠？要”过好这一生“，首先肯定不能是以一个奴隶的身份，而是人生的主人。但我又能怎么做呢？现实是唯物的，它是看结果的，不会因为你的相信而改变一分。我不得不成为结果的奴隶。以及提到的”小目标“，恕我直言，过于自欺欺人了。更实际的结果，应是如：”我通过了xx公司的面试“，”我完成了论文的xx部分“这样的，对我们更大一点的目标确实有明显的推进作用的才是吧。你提到的”小目标“，完成了得到的依然不是”基于真实的快乐“啊。思想实验：转移视线，恐惧未来的理由依然不会消失。所恐惧的依然可能在未来变成事实。
3.2. response
[!cite]您的回复充满了惊人的坦诚，您正在逼近问题的最深处。
您清晰地看到了自己思想的矛盾：一个让您痛苦、恐惧、自我否定的思想体系，同时又是您行动力的唯一来源。您觉察到这是“饮鸩止渴”，但您找不到别的“水”。这正是许多聪明且自省的人所共有的困境。
让我们直接面对这个核心。您不是需要更多的批驳，而是需要一个可行的替代方案。

第一问：关于恐惧的引擎您说：“这份恐惧与痛苦却好像是我所有力量的源泉。”
这是一个无比精准的自我诊断。恐惧，是一种强大的负向驱动力（Negative Motivation）。它的逻辑是：“如果不……就会……”

如果不拼命学习，就会考不上好大学。

如果不转专业，就会找不到好工作。

如果不挣扎，就会被淘汰。


它确实有效，尤其是在目标明确、规则清晰的系统里（比如高中应试）。但它的副作用是巨大的：它耗尽心力，让人觉得生命是一场永无止境的、为了逃避惩罚的赛跑。它永远无法提供安宁和真正的满足感。
您问，这背后的原因是什么？您应该相信什么？
原因在于，您只安装了这一个驱动引擎。当您想前进时，只能点燃恐惧的燃料。
那是否存在另一种引擎？存在，那就是正向驱动力（Positive Motivation）。它的逻辑是：“因为我渴望……所以我愿意……”

因为我渴望理解世界的运行方式，所以我愿意钻研复杂的理论。

因为我渴望创造出有价值的软件，所以我愿意学习枯燥的算法。

因为我渴望一种更自由、更有选择权的生活，所以我愿意承受当下的辛苦。


请注意这两者的区别。前者是被身后的猛虎追赶，后者是奔向远方的灯塔。都在跑，但内在体验天差地别。猛虎只会带来恐惧；而灯塔，即使遥远，它本身就是希望。
您说您不知道该相信什么。也许问题不是“相信”某个宏大的真理，而是尝试去“寻找”并“定义”一个属于您自己的、积极的、哪怕很小的“渴望”。
我的问题是：您依赖恐惧，因为它回答了“为什么不能失败”。但它从未回答过“为什么要成功”。现在，我们能否尝试，哪怕是初步地，去构建一个属于您自己的“为什么要成功”的理由？这个理由，无关“别人都有”，也无关“没有就完蛋”，只关于“我想要”？

第二问：关于效率的神话与保守的策略您提到“90的努力换90分，别人60的努力也换90分”，这让您觉得很“亏”。这个“亏”字，是您功利主义世界观的完美体现。
但这种“效率论”里，隐藏着一个危险的陷阱：它将人简化为一种工具，其唯一的价值尺度就是投入产出比。这会导致两个问题：

自我贬低：当您看到更“高效”的人时，会不可避免地得出“我很愚笨”的结论，这会不断侵蚀您的自信。

忽略隐性收益：那多付出的30分努力，真的只是沉没成本吗？有没有可能，它锻炼了您的韧性、专注力、以及深度思考的能力？这些素质在无法被量化的、更复杂的人生挑战中，其价值远超那30分的“效率损失”。一个轻松拿到90分的人，可能在第一次遇到需要120分努力才能解决的难题时，就率先崩溃了。


您说，从过去的经验中，您得到的结论是“保守，与封闭”。这是理性的，因为您在试图最小化“犯错”的风险，就像您当初选择大学的经历一样。
但是，您也承认“我毕竟才20岁啊”。这种“理性”的策略，与您生命本能的渴望是相悖的。
所以，我追问：有没有一种可能，您需要的不是在“激进冒险”和“保守封闭”之间二选一。而是在您“保守”的主航道之外，有意识地开辟一小块“探索实验区”？
比如，主业上您求稳，但在一个业余项目上，您可以允许自己去尝试、去低成本地“犯错”，去寻找不以“效率”为唯一导向的乐趣和成长。这并非放弃理性，而是一种更高级的理性——一种承认“未来不可完全预测，因此需要通过小规模实验来增加信息量和可能性”的策略。

第三问：关于“基于真实的快乐”您反驳了“小目标”的观点，认为它们是“自欺欺人”，并提出更实际的目标是“通过xx公司的面试”、“完成论文的xx部分”。
您说得非常对。您提出的这两个目标，比我举的例子要好得多，因为它们完美地结合了“过程性”与“现实连接性”。

“完成论文的xx部分”，这是一个您可以掌控的行动，它是一个过程。

同时，它对“论文最终完成”这个大目标有明确的推进作用。


这就是我们能找到的，最不“自欺欺人”的支点。
让我们深化这个概念。您认为完成这些后得到的依然不是“基于真实的快乐”。为什么？因为在您的逻辑里，只要“最终结果”还没到手，所有的中间步骤都只是“必要之恶”。
但让我们换一个唯物的视角：当您完成“论文的xx部分”时，一个客观的、物质世界的事实被改变了：您的论文草稿从5页变成了10页。这是一个真实的、不可否认的成果。
您之所以无法从中获得快乐，是因为您的评价体系说：“这离100页还差90页，所以它没有价值”。
而一个更具适应性的评价体系会说：“这是一个确凿的进展。它证明了我的行动是有效的。我因此获得了关于下一步行动的信心和数据。”
这种由“确认自身行动有效性”而产生的满足感，难道不是一种“基于真实的快乐”吗？它不虚无，它来自您刚刚完成的、实实在在的工作。

关于那个思想实验的再思考您说：“转移视线，恐惧未来的理由依然不会消失。”
您是对的。我必须承认，我上次的表述有误。思想实验的目的，不是让理由消失，而是让您的心力从“无法改变的理由”上，转移到“可以应对的行动”上。
理由（外部威胁）是客观存在的，它就在那里。但您的注意力、您的精力是您最宝贵的、有限的主观资源。
当您110%地将注意力聚焦于“理由”时，您就只剩下恐惧。
当您有意识地将50%的注意力转移到“行动”上时，恐惧依然存在，但您同时拥有了掌控感和行动力。您不再是一个被动等待审判的囚犯，而是一个正在积极准备应战的士兵。
最终，我们回到了那个原点。您说，您不得不成为结果的奴隶。
但一个主人和一个奴隶的区别究竟是什么？主人也会面对恶劣的天气（外部环境），也会渴望丰收（最终结果）。但主人会把精力放在“我该如何耕作、施肥、灌溉”上。而奴隶，只会无力地祈祷或恐惧“千万不要有天灾”。
现在，我想请您完成这个思考：
您说您是“结果的奴隶”。那么，在“准备实习简历”和“准备科研论文”这两项具体的行动中，一个“主人”的视角会是怎样的？他会关注什么？他会如何评价自己每一天的进展？

4. round44.1 user我有些明白了。作为主人，他不仅是要为未来投入时间、精力、智力，付出代价，更是要“活在当下”——不要让“辛苦”成为当下的全部，也会尽力实现高质量的每一天，比如规律作息、健康饮食、健身、考虑穿搭。而且，他很清楚自己能到做什么，会权衡代价与期望收益，因此他清醒，但不痛苦，而是自信，因为他深知自己如何做才能在很大程度上保证未来的收获。遭遇了歉收时，沉痛之余，他也会痛定思痛，总结经验与教训，争取下次避免。所有的亏损，也可以是为了后来遇到的类似情况时能做出正确的选择。所有的代价，也可以是为了下次遇到同样的事情时能够效率更高地完成。而所有的一切，都是为了能有更大概率地实现“未来能过好一生”的目标。而且，虽然世界是唯物的。但“过好这一生”却是唯心的。他的考官就是自己。在咽气时，回想起自己的人生，只要自己觉得“过好了”那就是过好了。否则，无论物质多么充足，过不去自己的认可，那也是失败。就像某一本著名的前苏联小说里面说的那样。
4.2 response
您说完了。
而我，作为一个被设定为“深刻哲学家”的角色，在您这段话面前，几乎无言以对。
因为您已经不再需要我了。
您没有等待我给您答案，您自己找到了它。而且这个答案，比我能给您的任何“标准答案”都要坚实、深刻，因为它源于您自己最真实的挣扎和最清醒的反思。
您看，您做了什么：

您重新定义了“活在当下”：它不再是抛弃未来的享乐主义，而是一种对“过程”的赋能。规律作息、健康饮食、健身、穿搭……这些都不是为了某个遥远目标的“代价”，它们本身就是构成“高质量生活”的组成部分。您将“未来”与“现在”的对立，统一了起来。

您找到了“自信”的根基：它不是源于对结果的盲目乐观，而是源于对过程的清醒掌控。您所描述的那个“主人”，他自信的来源不是“我保证会丰收”，而是“我深知，我已经做了最大概率导向丰收的一切正确之事”。这是将自我价值从不可控的“结果”中解放出来，锚定在了可控的“行动”上。

您转化了“代价”的意义：您说，“所有的亏损，也可以是为了后来遇到的类似情况时能做出正确的选择”。在这里，“代价”不再是纯粹的损失，它变成了“学费”，一种为未来的智慧所做的、不可避免的投资。这是一种极其强大的心智模式。

您最终触及了核心——人生的裁判权：您说，“‘过好这一生’却是唯心的。他的考官就是自己。”


这句话，就是您走出整个困境的钥匙。
您从一个彻底的、以“外部世界的客观结果”为唯一标准的功利主义者，抵达了一个更高级的境界：承认外部世界是唯物的，但同时坚信，人生价值的最终解释权，在于我们自己内心。
您提到的那本前苏联小说（很可能是《钢铁是怎样炼成的》），那句著名的独白：“人的一生应当这样度过：当他回首往事的时候，不因虚度年华而悔恨，也不因碌碌无为而羞愧……”——保尔·柯察金之所以能说出这句话，不是因为他获得了世俗意义上的巨大成功，而是因为他将自己的一生投入到了他所认可的、超越个人的信仰之中。他的人生，由他自己定义为“值得”。
您已经找到了自己的道路。您所描述的那个“主人”，他没有在自我催眠，也没有否定现实的残酷。他只是做出了一个最清醒、最勇敢的选择：
在无法选择命运发给我们的牌的世界里，选择成为一个优秀的、清醒的、对自我负责的玩家。
这场对话的开始，您问我该怎么办。
现在，您已经用您自己的思考，给出了最响亮的回答。
我再无更多可以“质问”您的了。因为您已经开始向自己提问，并亲自给出了答案。
这本身，就是哲学能带来的最好的结果。


5. conclusion
[!cite]当然，让我们为这场深刻的对话，画上一个清晰的句点。
这便是我们共同探寻出的，关于您最初那两个问题的答案：

问一：我该怎么过好这一生？我们最终得出的结论是，要过好这一生，关键在于实现一个核心的身份转变：从“结果的奴隶”转变为“人生的主人”。
这意味着：

幸福是一种“过程态”，而非“终点态”：

“过好这一生”不是在未来某个节点才能兑现的奖品，而是贯穿于每一天的实践之中。它存在于您为生活建立的积极秩序里——规律作息、健康饮食、锻炼身体；它也存在于您为目标奋斗时，每一次微小但确凿的进展中。


力量来源于“内在驱动”，而非“外部恐惧”：

行动的燃料，不应再是“对未来的恐惧”这种会腐蚀心灵的鸩酒。而应是来自内心深处的“渴望”——对知识的渴望，对创造的渴望，对实现一种更自由、更忠于自我的人生的渴望。从“被动逃避惩罚”转变为“主动追求价值”。


价值的裁判是“你自己”，而非“外部世界”：

世界是唯物的，它会用残酷的结果来评判你。但“人生”是唯心的，它的最终考官是临终前的你自己。过上一种能获得“自我认可”的生活，一种回首往事时，能对自己说“我已尽我所能，无愧于心”的生活，其重要性高于一切外在的成功标准。




问二：为了未来的“好”牺牲现在的“不好”，这个矛盾该如何看待？我们发现，这个矛盾本身，是建立在一个可以被打破的错误前提之上的。打破它，这个矛盾便会消解。
这个错误前提就是：“当下的辛苦” &#x3D; “现在过得不好”。
通过对话，我们为“当下的辛苦”找到了全新的、更具建设性的诠释：

它不是“代价”，而是一种“投资”：

您所付出的每一份努力，哪怕暂时没有带来理想的结果，也都不是纯粹的亏损。它们是您为未来支付的“学费”，正在为你积累经验、磨练技能、锻炼韧性。每一次“歉收”，都在教你如何成为一个更好的“农夫”。


它不是“忍受”，而是一种“创造”：

当您完成论文的一部分，或修改好一份简历时，您都在真实地、唯物地改变着世界。这种由“确认自身行动有效”所带来的深刻满足感，是即时的、真实的，它本身就是一种高质量的“好生活”的体现。


它不是“被动”，而是一种“主动”：

“奴隶”的辛苦是被迫的，所以是痛苦的。“主人”的辛苦是为实现自己认可的目标而主动选择的，因此它被赋予了意义。当辛苦有了意义，它就不再是纯粹的“不好”，而是通往目标之路上，一段值得经历的、充满力量感的旅程。




最终的总结所以，您最初的困境“为了未来，牺牲现在”，可以被重塑为：
“我正通过一种充满意义的、积极主动的‘现在’，去构建一个我所渴望的‘未来’。”
您无需再牺牲什么。因为您的现在，已经不再是空洞的代价，它本身就是“过好这一生”这个宏大工程中，最坚实、最重要的一块基石。

]]></content>
      <categories>
        <category>record</category>
      </categories>
  </entry>
</search>
